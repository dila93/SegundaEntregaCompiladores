Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    THEN
    LBRACKET
    NEWLINE
    PERIOD
    COMMENTS
    RBRACKET

Grammar

Rule 0     S' -> list
Rule 1     list -> empty
Rule 2     list -> list asgn
Rule 3     list -> list stmt
Rule 4     asgn -> ID = expr
Rule 5     asgn -> ID ADDEQ expr
Rule 6     asgn -> ID SUBEQ expr
Rule 7     asgn -> ID MULEQ expr
Rule 8     asgn -> ID DIVEQ expr
Rule 9     asgn -> ID MODEQ expr
Rule 10    stmt -> expr
Rule 11    stmt -> return ( expr )
Rule 12    stmt -> procedure begin ( arglist )
Rule 13    stmt -> print prlist
Rule 14    stmt -> while ( cond ) stmt end
Rule 15    stmt -> for ( cond ; cond ; cond ) stmt end
Rule 16    stmt -> if ( cond ) stmt end
Rule 17    stmt -> if ( cond ) stmt end ELSE stmt end
Rule 18    stmt -> { stmtlist }
Rule 19    cond -> expr
Rule 20    begin -> <empty>
Rule 21    end -> <empty>
Rule 22    stmtlist -> empty
Rule 23    stmtlist -> stmtlist stmt
Rule 24    expr -> ID
Rule 25    term -> read ( ID )
Rule 26    expr -> BLTIN ( expr )
Rule 27    expr -> asgn
Rule 28    expr -> expr + expr
Rule 29    expr -> expr - expr
Rule 30    expr -> expr * expr
Rule 31    expr -> expr / expr
Rule 32    expr -> NUMBER
Rule 33    expr -> expr EXPONENT expr
Rule 34    expr -> term
Rule 35    term -> factor
Rule 36    factor -> ( expr )
Rule 37    expr -> expr % expr
Rule 38    expr -> expr OR expr
Rule 39    expr -> expr AND expr
Rule 40    expr -> NOT expr
Rule 41    expr -> expr LT expr
Rule 42    expr -> expr GT expr
Rule 43    expr -> expr LE expr
Rule 44    expr -> expr GE expr
Rule 45    expr -> expr EQ expr
Rule 46    expr -> expr NE expr
Rule 47    expr -> INC ID
Rule 48    expr -> DEC ID
Rule 49    expr -> ID DEC
Rule 50    expr -> ID INC
Rule 51    prlist -> STRING
Rule 52    prlist -> prlist , expr
Rule 53    prlist -> prlist , STRING
Rule 54    defn -> func procname ( arglist ) stmt
Rule 55    defn -> proc procname ( arglist ) stmt
Rule 56    procname -> function
Rule 57    procname -> procedure
Rule 58    arglist -> empty
Rule 59    arglist -> arglist , expr
Rule 60    arglist -> expr
Rule 61    empty -> <empty>
Rule 62    else -> ELSE
Rule 63    return -> RETURN

Terminals, with rules where they appear

%                    : 37
(                    : 11 12 14 15 16 17 25 26 36 54 55
)                    : 11 12 14 15 16 17 25 26 36 54 55
*                    : 30
+                    : 28
,                    : 52 53 59
-                    : 29
/                    : 31
;                    : 15 15
=                    : 4
ADDEQ                : 5
AND                  : 39
BLTIN                : 26
COMMENTS             : 
DEC                  : 48 49
DIVEQ                : 8
ELSE                 : 17 62
EQ                   : 45
EXPONENT             : 33
GE                   : 44
GT                   : 42
ID                   : 4 5 6 7 8 9 24 25 47 48 49 50
INC                  : 47 50
LBRACKET             : 
LE                   : 43
LT                   : 41
MODEQ                : 9
MULEQ                : 7
NE                   : 46
NEWLINE              : 
NOT                  : 40
NUMBER               : 32
OR                   : 38
PERIOD               : 
RBRACKET             : 
RETURN               : 63
STRING               : 51 53
SUBEQ                : 6
THEN                 : 
error                : 
for                  : 15
func                 : 54
function             : 56
if                   : 16 17
print                : 13
proc                 : 55
procedure            : 12 57
read                 : 25
while                : 14
{                    : 18
}                    : 18

Nonterminals, with rules where they appear

arglist              : 12 54 55 59
asgn                 : 2 27
begin                : 12
cond                 : 14 15 15 15 16 17
defn                 : 
else                 : 
empty                : 1 22 58
end                  : 14 15 16 17 17
expr                 : 4 5 6 7 8 9 10 11 19 26 28 28 29 29 30 30 31 31 33 33 36 37 37 38 38 39 39 40 41 41 42 42 43 43 44 44 45 45 46 46 52 59 60
factor               : 35
list                 : 2 3 0
prlist               : 13 52 53
procname             : 54 55
return               : 11
stmt                 : 3 14 15 16 17 17 23 54 55
stmtlist             : 18 23
term                 : 34

Parsing method: LALR

state 0

    (0) S' -> . list
    (1) list -> . empty
    (2) list -> . list asgn
    (3) list -> . list stmt
    (61) empty -> .

    ID              reduce using rule 61 (empty -> .)
    procedure       reduce using rule 61 (empty -> .)
    print           reduce using rule 61 (empty -> .)
    while           reduce using rule 61 (empty -> .)
    for             reduce using rule 61 (empty -> .)
    if              reduce using rule 61 (empty -> .)
    {               reduce using rule 61 (empty -> .)
    BLTIN           reduce using rule 61 (empty -> .)
    NUMBER          reduce using rule 61 (empty -> .)
    NOT             reduce using rule 61 (empty -> .)
    INC             reduce using rule 61 (empty -> .)
    DEC             reduce using rule 61 (empty -> .)
    RETURN          reduce using rule 61 (empty -> .)
    read            reduce using rule 61 (empty -> .)
    (               reduce using rule 61 (empty -> .)
    $end            reduce using rule 61 (empty -> .)

    list                           shift and go to state 1
    empty                          shift and go to state 2

state 1

    (0) S' -> list .
    (2) list -> list . asgn
    (3) list -> list . stmt
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (10) stmt -> . expr
    (11) stmt -> . return ( expr )
    (12) stmt -> . procedure begin ( arglist )
    (13) stmt -> . print prlist
    (14) stmt -> . while ( cond ) stmt end
    (15) stmt -> . for ( cond ; cond ; cond ) stmt end
    (16) stmt -> . if ( cond ) stmt end
    (17) stmt -> . if ( cond ) stmt end ELSE stmt end
    (18) stmt -> . { stmtlist }
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (63) return -> . RETURN
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    ID              shift and go to state 15
    procedure       shift and go to state 22
    print           shift and go to state 10
    while           shift and go to state 19
    for             shift and go to state 6
    if              shift and go to state 5
    {               shift and go to state 21
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    RETURN          shift and go to state 3
    read            shift and go to state 12
    (               shift and go to state 7

    return                         shift and go to state 11
    expr                           shift and go to state 18
    term                           shift and go to state 16
    stmt                           shift and go to state 13
    asgn                           shift and go to state 8
    factor                         shift and go to state 9

state 2

    (1) list -> empty .

    ID              reduce using rule 1 (list -> empty .)
    procedure       reduce using rule 1 (list -> empty .)
    print           reduce using rule 1 (list -> empty .)
    while           reduce using rule 1 (list -> empty .)
    for             reduce using rule 1 (list -> empty .)
    if              reduce using rule 1 (list -> empty .)
    {               reduce using rule 1 (list -> empty .)
    BLTIN           reduce using rule 1 (list -> empty .)
    NUMBER          reduce using rule 1 (list -> empty .)
    NOT             reduce using rule 1 (list -> empty .)
    INC             reduce using rule 1 (list -> empty .)
    DEC             reduce using rule 1 (list -> empty .)
    RETURN          reduce using rule 1 (list -> empty .)
    read            reduce using rule 1 (list -> empty .)
    (               reduce using rule 1 (list -> empty .)
    $end            reduce using rule 1 (list -> empty .)


state 3

    (63) return -> RETURN .

    (               reduce using rule 63 (return -> RETURN .)


state 4

    (32) expr -> NUMBER .

    +               reduce using rule 32 (expr -> NUMBER .)
    -               reduce using rule 32 (expr -> NUMBER .)
    *               reduce using rule 32 (expr -> NUMBER .)
    /               reduce using rule 32 (expr -> NUMBER .)
    EXPONENT        reduce using rule 32 (expr -> NUMBER .)
    %               reduce using rule 32 (expr -> NUMBER .)
    OR              reduce using rule 32 (expr -> NUMBER .)
    AND             reduce using rule 32 (expr -> NUMBER .)
    LT              reduce using rule 32 (expr -> NUMBER .)
    GT              reduce using rule 32 (expr -> NUMBER .)
    LE              reduce using rule 32 (expr -> NUMBER .)
    GE              reduce using rule 32 (expr -> NUMBER .)
    EQ              reduce using rule 32 (expr -> NUMBER .)
    NE              reduce using rule 32 (expr -> NUMBER .)
    ID              reduce using rule 32 (expr -> NUMBER .)
    procedure       reduce using rule 32 (expr -> NUMBER .)
    print           reduce using rule 32 (expr -> NUMBER .)
    while           reduce using rule 32 (expr -> NUMBER .)
    for             reduce using rule 32 (expr -> NUMBER .)
    if              reduce using rule 32 (expr -> NUMBER .)
    {               reduce using rule 32 (expr -> NUMBER .)
    BLTIN           reduce using rule 32 (expr -> NUMBER .)
    NUMBER          reduce using rule 32 (expr -> NUMBER .)
    NOT             reduce using rule 32 (expr -> NUMBER .)
    INC             reduce using rule 32 (expr -> NUMBER .)
    DEC             reduce using rule 32 (expr -> NUMBER .)
    RETURN          reduce using rule 32 (expr -> NUMBER .)
    read            reduce using rule 32 (expr -> NUMBER .)
    (               reduce using rule 32 (expr -> NUMBER .)
    $end            reduce using rule 32 (expr -> NUMBER .)
    )               reduce using rule 32 (expr -> NUMBER .)
    ;               reduce using rule 32 (expr -> NUMBER .)
    }               reduce using rule 32 (expr -> NUMBER .)
    ,               reduce using rule 32 (expr -> NUMBER .)
    ELSE            reduce using rule 32 (expr -> NUMBER .)


state 5

    (16) stmt -> if . ( cond ) stmt end
    (17) stmt -> if . ( cond ) stmt end ELSE stmt end

    (               shift and go to state 24


state 6

    (15) stmt -> for . ( cond ; cond ; cond ) stmt end

    (               shift and go to state 25


state 7

    (36) factor -> ( . expr )
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    read            shift and go to state 12
    (               shift and go to state 7

    expr                           shift and go to state 28
    term                           shift and go to state 16
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 8

    (2) list -> list asgn .
    (27) expr -> asgn .

  ! reduce/reduce conflict for ID resolved using rule 2 (list -> list asgn .)
  ! reduce/reduce conflict for procedure resolved using rule 2 (list -> list asgn .)
  ! reduce/reduce conflict for print resolved using rule 2 (list -> list asgn .)
  ! reduce/reduce conflict for while resolved using rule 2 (list -> list asgn .)
  ! reduce/reduce conflict for for resolved using rule 2 (list -> list asgn .)
  ! reduce/reduce conflict for if resolved using rule 2 (list -> list asgn .)
  ! reduce/reduce conflict for { resolved using rule 2 (list -> list asgn .)
  ! reduce/reduce conflict for BLTIN resolved using rule 2 (list -> list asgn .)
  ! reduce/reduce conflict for NUMBER resolved using rule 2 (list -> list asgn .)
  ! reduce/reduce conflict for NOT resolved using rule 2 (list -> list asgn .)
  ! reduce/reduce conflict for INC resolved using rule 2 (list -> list asgn .)
  ! reduce/reduce conflict for DEC resolved using rule 2 (list -> list asgn .)
  ! reduce/reduce conflict for RETURN resolved using rule 2 (list -> list asgn .)
  ! reduce/reduce conflict for read resolved using rule 2 (list -> list asgn .)
  ! reduce/reduce conflict for ( resolved using rule 2 (list -> list asgn .)
  ! reduce/reduce conflict for $end resolved using rule 2 (list -> list asgn .)
    ID              reduce using rule 2 (list -> list asgn .)
    procedure       reduce using rule 2 (list -> list asgn .)
    print           reduce using rule 2 (list -> list asgn .)
    while           reduce using rule 2 (list -> list asgn .)
    for             reduce using rule 2 (list -> list asgn .)
    if              reduce using rule 2 (list -> list asgn .)
    {               reduce using rule 2 (list -> list asgn .)
    BLTIN           reduce using rule 2 (list -> list asgn .)
    NUMBER          reduce using rule 2 (list -> list asgn .)
    NOT             reduce using rule 2 (list -> list asgn .)
    INC             reduce using rule 2 (list -> list asgn .)
    DEC             reduce using rule 2 (list -> list asgn .)
    RETURN          reduce using rule 2 (list -> list asgn .)
    read            reduce using rule 2 (list -> list asgn .)
    (               reduce using rule 2 (list -> list asgn .)
    $end            reduce using rule 2 (list -> list asgn .)
    +               reduce using rule 27 (expr -> asgn .)
    -               reduce using rule 27 (expr -> asgn .)
    *               reduce using rule 27 (expr -> asgn .)
    /               reduce using rule 27 (expr -> asgn .)
    EXPONENT        reduce using rule 27 (expr -> asgn .)
    %               reduce using rule 27 (expr -> asgn .)
    OR              reduce using rule 27 (expr -> asgn .)
    AND             reduce using rule 27 (expr -> asgn .)
    LT              reduce using rule 27 (expr -> asgn .)
    GT              reduce using rule 27 (expr -> asgn .)
    LE              reduce using rule 27 (expr -> asgn .)
    GE              reduce using rule 27 (expr -> asgn .)
    EQ              reduce using rule 27 (expr -> asgn .)
    NE              reduce using rule 27 (expr -> asgn .)

  ! ID              [ reduce using rule 27 (expr -> asgn .) ]
  ! procedure       [ reduce using rule 27 (expr -> asgn .) ]
  ! print           [ reduce using rule 27 (expr -> asgn .) ]
  ! while           [ reduce using rule 27 (expr -> asgn .) ]
  ! for             [ reduce using rule 27 (expr -> asgn .) ]
  ! if              [ reduce using rule 27 (expr -> asgn .) ]
  ! {               [ reduce using rule 27 (expr -> asgn .) ]
  ! BLTIN           [ reduce using rule 27 (expr -> asgn .) ]
  ! NUMBER          [ reduce using rule 27 (expr -> asgn .) ]
  ! NOT             [ reduce using rule 27 (expr -> asgn .) ]
  ! INC             [ reduce using rule 27 (expr -> asgn .) ]
  ! DEC             [ reduce using rule 27 (expr -> asgn .) ]
  ! RETURN          [ reduce using rule 27 (expr -> asgn .) ]
  ! read            [ reduce using rule 27 (expr -> asgn .) ]
  ! (               [ reduce using rule 27 (expr -> asgn .) ]
  ! $end            [ reduce using rule 27 (expr -> asgn .) ]


state 9

    (35) term -> factor .

    +               reduce using rule 35 (term -> factor .)
    -               reduce using rule 35 (term -> factor .)
    *               reduce using rule 35 (term -> factor .)
    /               reduce using rule 35 (term -> factor .)
    EXPONENT        reduce using rule 35 (term -> factor .)
    %               reduce using rule 35 (term -> factor .)
    OR              reduce using rule 35 (term -> factor .)
    AND             reduce using rule 35 (term -> factor .)
    LT              reduce using rule 35 (term -> factor .)
    GT              reduce using rule 35 (term -> factor .)
    LE              reduce using rule 35 (term -> factor .)
    GE              reduce using rule 35 (term -> factor .)
    EQ              reduce using rule 35 (term -> factor .)
    NE              reduce using rule 35 (term -> factor .)
    ID              reduce using rule 35 (term -> factor .)
    procedure       reduce using rule 35 (term -> factor .)
    print           reduce using rule 35 (term -> factor .)
    while           reduce using rule 35 (term -> factor .)
    for             reduce using rule 35 (term -> factor .)
    if              reduce using rule 35 (term -> factor .)
    {               reduce using rule 35 (term -> factor .)
    BLTIN           reduce using rule 35 (term -> factor .)
    NUMBER          reduce using rule 35 (term -> factor .)
    NOT             reduce using rule 35 (term -> factor .)
    INC             reduce using rule 35 (term -> factor .)
    DEC             reduce using rule 35 (term -> factor .)
    RETURN          reduce using rule 35 (term -> factor .)
    read            reduce using rule 35 (term -> factor .)
    (               reduce using rule 35 (term -> factor .)
    $end            reduce using rule 35 (term -> factor .)
    )               reduce using rule 35 (term -> factor .)
    ;               reduce using rule 35 (term -> factor .)
    }               reduce using rule 35 (term -> factor .)
    ,               reduce using rule 35 (term -> factor .)
    ELSE            reduce using rule 35 (term -> factor .)


state 10

    (13) stmt -> print . prlist
    (51) prlist -> . STRING
    (52) prlist -> . prlist , expr
    (53) prlist -> . prlist , STRING

    STRING          shift and go to state 30

    prlist                         shift and go to state 29

state 11

    (11) stmt -> return . ( expr )

    (               shift and go to state 31


state 12

    (25) term -> read . ( ID )

    (               shift and go to state 32


state 13

    (3) list -> list stmt .

    ID              reduce using rule 3 (list -> list stmt .)
    procedure       reduce using rule 3 (list -> list stmt .)
    print           reduce using rule 3 (list -> list stmt .)
    while           reduce using rule 3 (list -> list stmt .)
    for             reduce using rule 3 (list -> list stmt .)
    if              reduce using rule 3 (list -> list stmt .)
    {               reduce using rule 3 (list -> list stmt .)
    BLTIN           reduce using rule 3 (list -> list stmt .)
    NUMBER          reduce using rule 3 (list -> list stmt .)
    NOT             reduce using rule 3 (list -> list stmt .)
    INC             reduce using rule 3 (list -> list stmt .)
    DEC             reduce using rule 3 (list -> list stmt .)
    RETURN          reduce using rule 3 (list -> list stmt .)
    read            reduce using rule 3 (list -> list stmt .)
    (               reduce using rule 3 (list -> list stmt .)
    $end            reduce using rule 3 (list -> list stmt .)


state 14

    (26) expr -> BLTIN . ( expr )

    (               shift and go to state 33


state 15

    (4) asgn -> ID . = expr
    (5) asgn -> ID . ADDEQ expr
    (6) asgn -> ID . SUBEQ expr
    (7) asgn -> ID . MULEQ expr
    (8) asgn -> ID . DIVEQ expr
    (9) asgn -> ID . MODEQ expr
    (24) expr -> ID .
    (49) expr -> ID . DEC
    (50) expr -> ID . INC

  ! shift/reduce conflict for DEC resolved as shift
  ! shift/reduce conflict for INC resolved as shift
    =               shift and go to state 39
    ADDEQ           shift and go to state 37
    SUBEQ           shift and go to state 35
    MULEQ           shift and go to state 36
    DIVEQ           shift and go to state 40
    MODEQ           shift and go to state 34
    +               reduce using rule 24 (expr -> ID .)
    -               reduce using rule 24 (expr -> ID .)
    *               reduce using rule 24 (expr -> ID .)
    /               reduce using rule 24 (expr -> ID .)
    EXPONENT        reduce using rule 24 (expr -> ID .)
    %               reduce using rule 24 (expr -> ID .)
    OR              reduce using rule 24 (expr -> ID .)
    AND             reduce using rule 24 (expr -> ID .)
    LT              reduce using rule 24 (expr -> ID .)
    GT              reduce using rule 24 (expr -> ID .)
    LE              reduce using rule 24 (expr -> ID .)
    GE              reduce using rule 24 (expr -> ID .)
    EQ              reduce using rule 24 (expr -> ID .)
    NE              reduce using rule 24 (expr -> ID .)
    ID              reduce using rule 24 (expr -> ID .)
    procedure       reduce using rule 24 (expr -> ID .)
    print           reduce using rule 24 (expr -> ID .)
    while           reduce using rule 24 (expr -> ID .)
    for             reduce using rule 24 (expr -> ID .)
    if              reduce using rule 24 (expr -> ID .)
    {               reduce using rule 24 (expr -> ID .)
    BLTIN           reduce using rule 24 (expr -> ID .)
    NUMBER          reduce using rule 24 (expr -> ID .)
    NOT             reduce using rule 24 (expr -> ID .)
    RETURN          reduce using rule 24 (expr -> ID .)
    read            reduce using rule 24 (expr -> ID .)
    (               reduce using rule 24 (expr -> ID .)
    $end            reduce using rule 24 (expr -> ID .)
    DEC             shift and go to state 38
    INC             shift and go to state 41

  ! INC             [ reduce using rule 24 (expr -> ID .) ]
  ! DEC             [ reduce using rule 24 (expr -> ID .) ]


state 16

    (34) expr -> term .

    +               reduce using rule 34 (expr -> term .)
    -               reduce using rule 34 (expr -> term .)
    *               reduce using rule 34 (expr -> term .)
    /               reduce using rule 34 (expr -> term .)
    EXPONENT        reduce using rule 34 (expr -> term .)
    %               reduce using rule 34 (expr -> term .)
    OR              reduce using rule 34 (expr -> term .)
    AND             reduce using rule 34 (expr -> term .)
    LT              reduce using rule 34 (expr -> term .)
    GT              reduce using rule 34 (expr -> term .)
    LE              reduce using rule 34 (expr -> term .)
    GE              reduce using rule 34 (expr -> term .)
    EQ              reduce using rule 34 (expr -> term .)
    NE              reduce using rule 34 (expr -> term .)
    ID              reduce using rule 34 (expr -> term .)
    procedure       reduce using rule 34 (expr -> term .)
    print           reduce using rule 34 (expr -> term .)
    while           reduce using rule 34 (expr -> term .)
    for             reduce using rule 34 (expr -> term .)
    if              reduce using rule 34 (expr -> term .)
    {               reduce using rule 34 (expr -> term .)
    BLTIN           reduce using rule 34 (expr -> term .)
    NUMBER          reduce using rule 34 (expr -> term .)
    NOT             reduce using rule 34 (expr -> term .)
    INC             reduce using rule 34 (expr -> term .)
    DEC             reduce using rule 34 (expr -> term .)
    RETURN          reduce using rule 34 (expr -> term .)
    read            reduce using rule 34 (expr -> term .)
    (               reduce using rule 34 (expr -> term .)
    $end            reduce using rule 34 (expr -> term .)
    )               reduce using rule 34 (expr -> term .)
    ;               reduce using rule 34 (expr -> term .)
    }               reduce using rule 34 (expr -> term .)
    ,               reduce using rule 34 (expr -> term .)
    ELSE            reduce using rule 34 (expr -> term .)


state 17

    (48) expr -> DEC . ID

    ID              shift and go to state 42


state 18

    (10) stmt -> expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (33) expr -> expr . EXPONENT expr
    (37) expr -> expr . % expr
    (38) expr -> expr . OR expr
    (39) expr -> expr . AND expr
    (41) expr -> expr . LT expr
    (42) expr -> expr . GT expr
    (43) expr -> expr . LE expr
    (44) expr -> expr . GE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NE expr

    ELSE            reduce using rule 10 (stmt -> expr .)
    ID              reduce using rule 10 (stmt -> expr .)
    procedure       reduce using rule 10 (stmt -> expr .)
    print           reduce using rule 10 (stmt -> expr .)
    while           reduce using rule 10 (stmt -> expr .)
    for             reduce using rule 10 (stmt -> expr .)
    if              reduce using rule 10 (stmt -> expr .)
    {               reduce using rule 10 (stmt -> expr .)
    BLTIN           reduce using rule 10 (stmt -> expr .)
    NUMBER          reduce using rule 10 (stmt -> expr .)
    NOT             reduce using rule 10 (stmt -> expr .)
    INC             reduce using rule 10 (stmt -> expr .)
    DEC             reduce using rule 10 (stmt -> expr .)
    RETURN          reduce using rule 10 (stmt -> expr .)
    read            reduce using rule 10 (stmt -> expr .)
    (               reduce using rule 10 (stmt -> expr .)
    $end            reduce using rule 10 (stmt -> expr .)
    }               reduce using rule 10 (stmt -> expr .)
    +               shift and go to state 47
    -               shift and go to state 49
    *               shift and go to state 48
    /               shift and go to state 51
    EXPONENT        shift and go to state 46
    %               shift and go to state 45
    OR              shift and go to state 56
    AND             shift and go to state 43
    LT              shift and go to state 53
    GT              shift and go to state 44
    LE              shift and go to state 54
    GE              shift and go to state 50
    EQ              shift and go to state 55
    NE              shift and go to state 52


state 19

    (14) stmt -> while . ( cond ) stmt end

    (               shift and go to state 57


state 20

    (40) expr -> NOT . expr
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    read            shift and go to state 12
    (               shift and go to state 7

    expr                           shift and go to state 58
    term                           shift and go to state 16
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 21

    (18) stmt -> { . stmtlist }
    (22) stmtlist -> . empty
    (23) stmtlist -> . stmtlist stmt
    (61) empty -> .

    }               reduce using rule 61 (empty -> .)
    procedure       reduce using rule 61 (empty -> .)
    print           reduce using rule 61 (empty -> .)
    while           reduce using rule 61 (empty -> .)
    for             reduce using rule 61 (empty -> .)
    if              reduce using rule 61 (empty -> .)
    {               reduce using rule 61 (empty -> .)
    ID              reduce using rule 61 (empty -> .)
    BLTIN           reduce using rule 61 (empty -> .)
    NUMBER          reduce using rule 61 (empty -> .)
    NOT             reduce using rule 61 (empty -> .)
    INC             reduce using rule 61 (empty -> .)
    DEC             reduce using rule 61 (empty -> .)
    RETURN          reduce using rule 61 (empty -> .)
    read            reduce using rule 61 (empty -> .)
    (               reduce using rule 61 (empty -> .)

    empty                          shift and go to state 59
    stmtlist                       shift and go to state 60

state 22

    (12) stmt -> procedure . begin ( arglist )
    (20) begin -> .

    (               reduce using rule 20 (begin -> .)

    begin                          shift and go to state 61

state 23

    (47) expr -> INC . ID

    ID              shift and go to state 62


state 24

    (16) stmt -> if ( . cond ) stmt end
    (17) stmt -> if ( . cond ) stmt end ELSE stmt end
    (19) cond -> . expr
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    read            shift and go to state 12
    (               shift and go to state 7

    term                           shift and go to state 16
    expr                           shift and go to state 64
    asgn                           shift and go to state 26
    cond                           shift and go to state 63
    factor                         shift and go to state 9

state 25

    (15) stmt -> for ( . cond ; cond ; cond ) stmt end
    (19) cond -> . expr
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    read            shift and go to state 12
    (               shift and go to state 7

    term                           shift and go to state 16
    expr                           shift and go to state 64
    asgn                           shift and go to state 26
    cond                           shift and go to state 65
    factor                         shift and go to state 9

state 26

    (27) expr -> asgn .

    +               reduce using rule 27 (expr -> asgn .)
    -               reduce using rule 27 (expr -> asgn .)
    *               reduce using rule 27 (expr -> asgn .)
    /               reduce using rule 27 (expr -> asgn .)
    EXPONENT        reduce using rule 27 (expr -> asgn .)
    %               reduce using rule 27 (expr -> asgn .)
    OR              reduce using rule 27 (expr -> asgn .)
    AND             reduce using rule 27 (expr -> asgn .)
    LT              reduce using rule 27 (expr -> asgn .)
    GT              reduce using rule 27 (expr -> asgn .)
    LE              reduce using rule 27 (expr -> asgn .)
    GE              reduce using rule 27 (expr -> asgn .)
    EQ              reduce using rule 27 (expr -> asgn .)
    NE              reduce using rule 27 (expr -> asgn .)
    ID              reduce using rule 27 (expr -> asgn .)
    procedure       reduce using rule 27 (expr -> asgn .)
    print           reduce using rule 27 (expr -> asgn .)
    while           reduce using rule 27 (expr -> asgn .)
    for             reduce using rule 27 (expr -> asgn .)
    if              reduce using rule 27 (expr -> asgn .)
    {               reduce using rule 27 (expr -> asgn .)
    BLTIN           reduce using rule 27 (expr -> asgn .)
    NUMBER          reduce using rule 27 (expr -> asgn .)
    NOT             reduce using rule 27 (expr -> asgn .)
    INC             reduce using rule 27 (expr -> asgn .)
    DEC             reduce using rule 27 (expr -> asgn .)
    RETURN          reduce using rule 27 (expr -> asgn .)
    read            reduce using rule 27 (expr -> asgn .)
    (               reduce using rule 27 (expr -> asgn .)
    $end            reduce using rule 27 (expr -> asgn .)
    )               reduce using rule 27 (expr -> asgn .)
    ;               reduce using rule 27 (expr -> asgn .)
    }               reduce using rule 27 (expr -> asgn .)
    ,               reduce using rule 27 (expr -> asgn .)
    ELSE            reduce using rule 27 (expr -> asgn .)


state 27

    (24) expr -> ID .
    (49) expr -> ID . DEC
    (50) expr -> ID . INC
    (4) asgn -> ID . = expr
    (5) asgn -> ID . ADDEQ expr
    (6) asgn -> ID . SUBEQ expr
    (7) asgn -> ID . MULEQ expr
    (8) asgn -> ID . DIVEQ expr
    (9) asgn -> ID . MODEQ expr

  ! shift/reduce conflict for DEC resolved as shift
  ! shift/reduce conflict for INC resolved as shift
    +               reduce using rule 24 (expr -> ID .)
    -               reduce using rule 24 (expr -> ID .)
    *               reduce using rule 24 (expr -> ID .)
    /               reduce using rule 24 (expr -> ID .)
    EXPONENT        reduce using rule 24 (expr -> ID .)
    %               reduce using rule 24 (expr -> ID .)
    OR              reduce using rule 24 (expr -> ID .)
    AND             reduce using rule 24 (expr -> ID .)
    LT              reduce using rule 24 (expr -> ID .)
    GT              reduce using rule 24 (expr -> ID .)
    LE              reduce using rule 24 (expr -> ID .)
    GE              reduce using rule 24 (expr -> ID .)
    EQ              reduce using rule 24 (expr -> ID .)
    NE              reduce using rule 24 (expr -> ID .)
    ID              reduce using rule 24 (expr -> ID .)
    procedure       reduce using rule 24 (expr -> ID .)
    print           reduce using rule 24 (expr -> ID .)
    while           reduce using rule 24 (expr -> ID .)
    for             reduce using rule 24 (expr -> ID .)
    if              reduce using rule 24 (expr -> ID .)
    {               reduce using rule 24 (expr -> ID .)
    BLTIN           reduce using rule 24 (expr -> ID .)
    NUMBER          reduce using rule 24 (expr -> ID .)
    NOT             reduce using rule 24 (expr -> ID .)
    RETURN          reduce using rule 24 (expr -> ID .)
    read            reduce using rule 24 (expr -> ID .)
    (               reduce using rule 24 (expr -> ID .)
    $end            reduce using rule 24 (expr -> ID .)
    )               reduce using rule 24 (expr -> ID .)
    ;               reduce using rule 24 (expr -> ID .)
    }               reduce using rule 24 (expr -> ID .)
    ,               reduce using rule 24 (expr -> ID .)
    ELSE            reduce using rule 24 (expr -> ID .)
    DEC             shift and go to state 38
    INC             shift and go to state 41
    =               shift and go to state 39
    ADDEQ           shift and go to state 37
    SUBEQ           shift and go to state 35
    MULEQ           shift and go to state 36
    DIVEQ           shift and go to state 40
    MODEQ           shift and go to state 34

  ! INC             [ reduce using rule 24 (expr -> ID .) ]
  ! DEC             [ reduce using rule 24 (expr -> ID .) ]


state 28

    (36) factor -> ( expr . )
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (33) expr -> expr . EXPONENT expr
    (37) expr -> expr . % expr
    (38) expr -> expr . OR expr
    (39) expr -> expr . AND expr
    (41) expr -> expr . LT expr
    (42) expr -> expr . GT expr
    (43) expr -> expr . LE expr
    (44) expr -> expr . GE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NE expr

    )               shift and go to state 66
    +               shift and go to state 47
    -               shift and go to state 49
    *               shift and go to state 48
    /               shift and go to state 51
    EXPONENT        shift and go to state 46
    %               shift and go to state 45
    OR              shift and go to state 56
    AND             shift and go to state 43
    LT              shift and go to state 53
    GT              shift and go to state 44
    LE              shift and go to state 54
    GE              shift and go to state 50
    EQ              shift and go to state 55
    NE              shift and go to state 52


state 29

    (13) stmt -> print prlist .
    (52) prlist -> prlist . , expr
    (53) prlist -> prlist . , STRING

    ELSE            reduce using rule 13 (stmt -> print prlist .)
    ID              reduce using rule 13 (stmt -> print prlist .)
    procedure       reduce using rule 13 (stmt -> print prlist .)
    print           reduce using rule 13 (stmt -> print prlist .)
    while           reduce using rule 13 (stmt -> print prlist .)
    for             reduce using rule 13 (stmt -> print prlist .)
    if              reduce using rule 13 (stmt -> print prlist .)
    {               reduce using rule 13 (stmt -> print prlist .)
    BLTIN           reduce using rule 13 (stmt -> print prlist .)
    NUMBER          reduce using rule 13 (stmt -> print prlist .)
    NOT             reduce using rule 13 (stmt -> print prlist .)
    INC             reduce using rule 13 (stmt -> print prlist .)
    DEC             reduce using rule 13 (stmt -> print prlist .)
    RETURN          reduce using rule 13 (stmt -> print prlist .)
    read            reduce using rule 13 (stmt -> print prlist .)
    (               reduce using rule 13 (stmt -> print prlist .)
    $end            reduce using rule 13 (stmt -> print prlist .)
    }               reduce using rule 13 (stmt -> print prlist .)
    ,               shift and go to state 67


state 30

    (51) prlist -> STRING .

    ,               reduce using rule 51 (prlist -> STRING .)
    ID              reduce using rule 51 (prlist -> STRING .)
    procedure       reduce using rule 51 (prlist -> STRING .)
    print           reduce using rule 51 (prlist -> STRING .)
    while           reduce using rule 51 (prlist -> STRING .)
    for             reduce using rule 51 (prlist -> STRING .)
    if              reduce using rule 51 (prlist -> STRING .)
    {               reduce using rule 51 (prlist -> STRING .)
    BLTIN           reduce using rule 51 (prlist -> STRING .)
    NUMBER          reduce using rule 51 (prlist -> STRING .)
    NOT             reduce using rule 51 (prlist -> STRING .)
    INC             reduce using rule 51 (prlist -> STRING .)
    DEC             reduce using rule 51 (prlist -> STRING .)
    RETURN          reduce using rule 51 (prlist -> STRING .)
    read            reduce using rule 51 (prlist -> STRING .)
    (               reduce using rule 51 (prlist -> STRING .)
    $end            reduce using rule 51 (prlist -> STRING .)
    }               reduce using rule 51 (prlist -> STRING .)
    ELSE            reduce using rule 51 (prlist -> STRING .)


state 31

    (11) stmt -> return ( . expr )
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    read            shift and go to state 12
    (               shift and go to state 7

    expr                           shift and go to state 68
    term                           shift and go to state 16
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 32

    (25) term -> read ( . ID )

    ID              shift and go to state 69


state 33

    (26) expr -> BLTIN ( . expr )
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    read            shift and go to state 12
    (               shift and go to state 7

    expr                           shift and go to state 70
    term                           shift and go to state 16
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 34

    (9) asgn -> ID MODEQ . expr
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    read            shift and go to state 12
    (               shift and go to state 7

    expr                           shift and go to state 71
    term                           shift and go to state 16
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 35

    (6) asgn -> ID SUBEQ . expr
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    read            shift and go to state 12
    (               shift and go to state 7

    expr                           shift and go to state 72
    term                           shift and go to state 16
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 36

    (7) asgn -> ID MULEQ . expr
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    read            shift and go to state 12
    (               shift and go to state 7

    expr                           shift and go to state 73
    term                           shift and go to state 16
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 37

    (5) asgn -> ID ADDEQ . expr
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    read            shift and go to state 12
    (               shift and go to state 7

    expr                           shift and go to state 74
    term                           shift and go to state 16
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 38

    (49) expr -> ID DEC .

    +               reduce using rule 49 (expr -> ID DEC .)
    -               reduce using rule 49 (expr -> ID DEC .)
    *               reduce using rule 49 (expr -> ID DEC .)
    /               reduce using rule 49 (expr -> ID DEC .)
    EXPONENT        reduce using rule 49 (expr -> ID DEC .)
    %               reduce using rule 49 (expr -> ID DEC .)
    OR              reduce using rule 49 (expr -> ID DEC .)
    AND             reduce using rule 49 (expr -> ID DEC .)
    LT              reduce using rule 49 (expr -> ID DEC .)
    GT              reduce using rule 49 (expr -> ID DEC .)
    LE              reduce using rule 49 (expr -> ID DEC .)
    GE              reduce using rule 49 (expr -> ID DEC .)
    EQ              reduce using rule 49 (expr -> ID DEC .)
    NE              reduce using rule 49 (expr -> ID DEC .)
    ID              reduce using rule 49 (expr -> ID DEC .)
    procedure       reduce using rule 49 (expr -> ID DEC .)
    print           reduce using rule 49 (expr -> ID DEC .)
    while           reduce using rule 49 (expr -> ID DEC .)
    for             reduce using rule 49 (expr -> ID DEC .)
    if              reduce using rule 49 (expr -> ID DEC .)
    {               reduce using rule 49 (expr -> ID DEC .)
    BLTIN           reduce using rule 49 (expr -> ID DEC .)
    NUMBER          reduce using rule 49 (expr -> ID DEC .)
    NOT             reduce using rule 49 (expr -> ID DEC .)
    INC             reduce using rule 49 (expr -> ID DEC .)
    DEC             reduce using rule 49 (expr -> ID DEC .)
    RETURN          reduce using rule 49 (expr -> ID DEC .)
    read            reduce using rule 49 (expr -> ID DEC .)
    (               reduce using rule 49 (expr -> ID DEC .)
    $end            reduce using rule 49 (expr -> ID DEC .)
    )               reduce using rule 49 (expr -> ID DEC .)
    ;               reduce using rule 49 (expr -> ID DEC .)
    }               reduce using rule 49 (expr -> ID DEC .)
    ,               reduce using rule 49 (expr -> ID DEC .)
    ELSE            reduce using rule 49 (expr -> ID DEC .)


state 39

    (4) asgn -> ID = . expr
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    read            shift and go to state 12
    (               shift and go to state 7

    expr                           shift and go to state 75
    term                           shift and go to state 16
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 40

    (8) asgn -> ID DIVEQ . expr
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    read            shift and go to state 12
    (               shift and go to state 7

    expr                           shift and go to state 76
    term                           shift and go to state 16
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 41

    (50) expr -> ID INC .

    +               reduce using rule 50 (expr -> ID INC .)
    -               reduce using rule 50 (expr -> ID INC .)
    *               reduce using rule 50 (expr -> ID INC .)
    /               reduce using rule 50 (expr -> ID INC .)
    EXPONENT        reduce using rule 50 (expr -> ID INC .)
    %               reduce using rule 50 (expr -> ID INC .)
    OR              reduce using rule 50 (expr -> ID INC .)
    AND             reduce using rule 50 (expr -> ID INC .)
    LT              reduce using rule 50 (expr -> ID INC .)
    GT              reduce using rule 50 (expr -> ID INC .)
    LE              reduce using rule 50 (expr -> ID INC .)
    GE              reduce using rule 50 (expr -> ID INC .)
    EQ              reduce using rule 50 (expr -> ID INC .)
    NE              reduce using rule 50 (expr -> ID INC .)
    ID              reduce using rule 50 (expr -> ID INC .)
    procedure       reduce using rule 50 (expr -> ID INC .)
    print           reduce using rule 50 (expr -> ID INC .)
    while           reduce using rule 50 (expr -> ID INC .)
    for             reduce using rule 50 (expr -> ID INC .)
    if              reduce using rule 50 (expr -> ID INC .)
    {               reduce using rule 50 (expr -> ID INC .)
    BLTIN           reduce using rule 50 (expr -> ID INC .)
    NUMBER          reduce using rule 50 (expr -> ID INC .)
    NOT             reduce using rule 50 (expr -> ID INC .)
    INC             reduce using rule 50 (expr -> ID INC .)
    DEC             reduce using rule 50 (expr -> ID INC .)
    RETURN          reduce using rule 50 (expr -> ID INC .)
    read            reduce using rule 50 (expr -> ID INC .)
    (               reduce using rule 50 (expr -> ID INC .)
    $end            reduce using rule 50 (expr -> ID INC .)
    )               reduce using rule 50 (expr -> ID INC .)
    ;               reduce using rule 50 (expr -> ID INC .)
    }               reduce using rule 50 (expr -> ID INC .)
    ,               reduce using rule 50 (expr -> ID INC .)
    ELSE            reduce using rule 50 (expr -> ID INC .)


state 42

    (48) expr -> DEC ID .

    +               reduce using rule 48 (expr -> DEC ID .)
    -               reduce using rule 48 (expr -> DEC ID .)
    *               reduce using rule 48 (expr -> DEC ID .)
    /               reduce using rule 48 (expr -> DEC ID .)
    EXPONENT        reduce using rule 48 (expr -> DEC ID .)
    %               reduce using rule 48 (expr -> DEC ID .)
    OR              reduce using rule 48 (expr -> DEC ID .)
    AND             reduce using rule 48 (expr -> DEC ID .)
    LT              reduce using rule 48 (expr -> DEC ID .)
    GT              reduce using rule 48 (expr -> DEC ID .)
    LE              reduce using rule 48 (expr -> DEC ID .)
    GE              reduce using rule 48 (expr -> DEC ID .)
    EQ              reduce using rule 48 (expr -> DEC ID .)
    NE              reduce using rule 48 (expr -> DEC ID .)
    ID              reduce using rule 48 (expr -> DEC ID .)
    procedure       reduce using rule 48 (expr -> DEC ID .)
    print           reduce using rule 48 (expr -> DEC ID .)
    while           reduce using rule 48 (expr -> DEC ID .)
    for             reduce using rule 48 (expr -> DEC ID .)
    if              reduce using rule 48 (expr -> DEC ID .)
    {               reduce using rule 48 (expr -> DEC ID .)
    BLTIN           reduce using rule 48 (expr -> DEC ID .)
    NUMBER          reduce using rule 48 (expr -> DEC ID .)
    NOT             reduce using rule 48 (expr -> DEC ID .)
    INC             reduce using rule 48 (expr -> DEC ID .)
    DEC             reduce using rule 48 (expr -> DEC ID .)
    RETURN          reduce using rule 48 (expr -> DEC ID .)
    read            reduce using rule 48 (expr -> DEC ID .)
    (               reduce using rule 48 (expr -> DEC ID .)
    $end            reduce using rule 48 (expr -> DEC ID .)
    )               reduce using rule 48 (expr -> DEC ID .)
    ;               reduce using rule 48 (expr -> DEC ID .)
    }               reduce using rule 48 (expr -> DEC ID .)
    ,               reduce using rule 48 (expr -> DEC ID .)
    ELSE            reduce using rule 48 (expr -> DEC ID .)


state 43

    (39) expr -> expr AND . expr
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    read            shift and go to state 12
    (               shift and go to state 7

    expr                           shift and go to state 77
    term                           shift and go to state 16
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 44

    (42) expr -> expr GT . expr
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    read            shift and go to state 12
    (               shift and go to state 7

    expr                           shift and go to state 78
    term                           shift and go to state 16
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 45

    (37) expr -> expr % . expr
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    read            shift and go to state 12
    (               shift and go to state 7

    expr                           shift and go to state 79
    term                           shift and go to state 16
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 46

    (33) expr -> expr EXPONENT . expr
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    read            shift and go to state 12
    (               shift and go to state 7

    expr                           shift and go to state 80
    term                           shift and go to state 16
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 47

    (28) expr -> expr + . expr
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    read            shift and go to state 12
    (               shift and go to state 7

    expr                           shift and go to state 81
    term                           shift and go to state 16
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 48

    (30) expr -> expr * . expr
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    read            shift and go to state 12
    (               shift and go to state 7

    expr                           shift and go to state 82
    term                           shift and go to state 16
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 49

    (29) expr -> expr - . expr
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    read            shift and go to state 12
    (               shift and go to state 7

    expr                           shift and go to state 83
    term                           shift and go to state 16
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 50

    (44) expr -> expr GE . expr
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    read            shift and go to state 12
    (               shift and go to state 7

    expr                           shift and go to state 84
    term                           shift and go to state 16
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 51

    (31) expr -> expr / . expr
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    read            shift and go to state 12
    (               shift and go to state 7

    expr                           shift and go to state 85
    term                           shift and go to state 16
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 52

    (46) expr -> expr NE . expr
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    read            shift and go to state 12
    (               shift and go to state 7

    expr                           shift and go to state 86
    term                           shift and go to state 16
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 53

    (41) expr -> expr LT . expr
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    read            shift and go to state 12
    (               shift and go to state 7

    expr                           shift and go to state 87
    term                           shift and go to state 16
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 54

    (43) expr -> expr LE . expr
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    read            shift and go to state 12
    (               shift and go to state 7

    expr                           shift and go to state 88
    term                           shift and go to state 16
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 55

    (45) expr -> expr EQ . expr
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    read            shift and go to state 12
    (               shift and go to state 7

    expr                           shift and go to state 89
    term                           shift and go to state 16
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 56

    (38) expr -> expr OR . expr
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    read            shift and go to state 12
    (               shift and go to state 7

    expr                           shift and go to state 90
    term                           shift and go to state 16
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 57

    (14) stmt -> while ( . cond ) stmt end
    (19) cond -> . expr
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    read            shift and go to state 12
    (               shift and go to state 7

    term                           shift and go to state 16
    expr                           shift and go to state 64
    asgn                           shift and go to state 26
    cond                           shift and go to state 91
    factor                         shift and go to state 9

state 58

    (40) expr -> NOT expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (33) expr -> expr . EXPONENT expr
    (37) expr -> expr . % expr
    (38) expr -> expr . OR expr
    (39) expr -> expr . AND expr
    (41) expr -> expr . LT expr
    (42) expr -> expr . GT expr
    (43) expr -> expr . LE expr
    (44) expr -> expr . GE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NE expr

    +               reduce using rule 40 (expr -> NOT expr .)
    -               reduce using rule 40 (expr -> NOT expr .)
    *               reduce using rule 40 (expr -> NOT expr .)
    /               reduce using rule 40 (expr -> NOT expr .)
    %               reduce using rule 40 (expr -> NOT expr .)
    OR              reduce using rule 40 (expr -> NOT expr .)
    AND             reduce using rule 40 (expr -> NOT expr .)
    LT              reduce using rule 40 (expr -> NOT expr .)
    GT              reduce using rule 40 (expr -> NOT expr .)
    LE              reduce using rule 40 (expr -> NOT expr .)
    GE              reduce using rule 40 (expr -> NOT expr .)
    EQ              reduce using rule 40 (expr -> NOT expr .)
    NE              reduce using rule 40 (expr -> NOT expr .)
    ID              reduce using rule 40 (expr -> NOT expr .)
    procedure       reduce using rule 40 (expr -> NOT expr .)
    print           reduce using rule 40 (expr -> NOT expr .)
    while           reduce using rule 40 (expr -> NOT expr .)
    for             reduce using rule 40 (expr -> NOT expr .)
    if              reduce using rule 40 (expr -> NOT expr .)
    {               reduce using rule 40 (expr -> NOT expr .)
    BLTIN           reduce using rule 40 (expr -> NOT expr .)
    NUMBER          reduce using rule 40 (expr -> NOT expr .)
    NOT             reduce using rule 40 (expr -> NOT expr .)
    INC             reduce using rule 40 (expr -> NOT expr .)
    DEC             reduce using rule 40 (expr -> NOT expr .)
    RETURN          reduce using rule 40 (expr -> NOT expr .)
    read            reduce using rule 40 (expr -> NOT expr .)
    (               reduce using rule 40 (expr -> NOT expr .)
    $end            reduce using rule 40 (expr -> NOT expr .)
    )               reduce using rule 40 (expr -> NOT expr .)
    ;               reduce using rule 40 (expr -> NOT expr .)
    }               reduce using rule 40 (expr -> NOT expr .)
    ,               reduce using rule 40 (expr -> NOT expr .)
    ELSE            reduce using rule 40 (expr -> NOT expr .)
    EXPONENT        shift and go to state 46

  ! EXPONENT        [ reduce using rule 40 (expr -> NOT expr .) ]
  ! +               [ shift and go to state 47 ]
  ! -               [ shift and go to state 49 ]
  ! *               [ shift and go to state 48 ]
  ! /               [ shift and go to state 51 ]
  ! %               [ shift and go to state 45 ]
  ! OR              [ shift and go to state 56 ]
  ! AND             [ shift and go to state 43 ]
  ! LT              [ shift and go to state 53 ]
  ! GT              [ shift and go to state 44 ]
  ! LE              [ shift and go to state 54 ]
  ! GE              [ shift and go to state 50 ]
  ! EQ              [ shift and go to state 55 ]
  ! NE              [ shift and go to state 52 ]


state 59

    (22) stmtlist -> empty .

    }               reduce using rule 22 (stmtlist -> empty .)
    procedure       reduce using rule 22 (stmtlist -> empty .)
    print           reduce using rule 22 (stmtlist -> empty .)
    while           reduce using rule 22 (stmtlist -> empty .)
    for             reduce using rule 22 (stmtlist -> empty .)
    if              reduce using rule 22 (stmtlist -> empty .)
    {               reduce using rule 22 (stmtlist -> empty .)
    ID              reduce using rule 22 (stmtlist -> empty .)
    BLTIN           reduce using rule 22 (stmtlist -> empty .)
    NUMBER          reduce using rule 22 (stmtlist -> empty .)
    NOT             reduce using rule 22 (stmtlist -> empty .)
    INC             reduce using rule 22 (stmtlist -> empty .)
    DEC             reduce using rule 22 (stmtlist -> empty .)
    RETURN          reduce using rule 22 (stmtlist -> empty .)
    read            reduce using rule 22 (stmtlist -> empty .)
    (               reduce using rule 22 (stmtlist -> empty .)


state 60

    (18) stmt -> { stmtlist . }
    (23) stmtlist -> stmtlist . stmt
    (10) stmt -> . expr
    (11) stmt -> . return ( expr )
    (12) stmt -> . procedure begin ( arglist )
    (13) stmt -> . print prlist
    (14) stmt -> . while ( cond ) stmt end
    (15) stmt -> . for ( cond ; cond ; cond ) stmt end
    (16) stmt -> . if ( cond ) stmt end
    (17) stmt -> . if ( cond ) stmt end ELSE stmt end
    (18) stmt -> . { stmtlist }
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (63) return -> . RETURN
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    }               shift and go to state 93
    procedure       shift and go to state 22
    print           shift and go to state 10
    while           shift and go to state 19
    for             shift and go to state 6
    if              shift and go to state 5
    {               shift and go to state 21
    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    RETURN          shift and go to state 3
    read            shift and go to state 12
    (               shift and go to state 7

    return                         shift and go to state 11
    expr                           shift and go to state 18
    term                           shift and go to state 16
    stmt                           shift and go to state 92
    asgn                           shift and go to state 26
    factor                         shift and go to state 9

state 61

    (12) stmt -> procedure begin . ( arglist )

    (               shift and go to state 94


state 62

    (47) expr -> INC ID .

    +               reduce using rule 47 (expr -> INC ID .)
    -               reduce using rule 47 (expr -> INC ID .)
    *               reduce using rule 47 (expr -> INC ID .)
    /               reduce using rule 47 (expr -> INC ID .)
    EXPONENT        reduce using rule 47 (expr -> INC ID .)
    %               reduce using rule 47 (expr -> INC ID .)
    OR              reduce using rule 47 (expr -> INC ID .)
    AND             reduce using rule 47 (expr -> INC ID .)
    LT              reduce using rule 47 (expr -> INC ID .)
    GT              reduce using rule 47 (expr -> INC ID .)
    LE              reduce using rule 47 (expr -> INC ID .)
    GE              reduce using rule 47 (expr -> INC ID .)
    EQ              reduce using rule 47 (expr -> INC ID .)
    NE              reduce using rule 47 (expr -> INC ID .)
    ID              reduce using rule 47 (expr -> INC ID .)
    procedure       reduce using rule 47 (expr -> INC ID .)
    print           reduce using rule 47 (expr -> INC ID .)
    while           reduce using rule 47 (expr -> INC ID .)
    for             reduce using rule 47 (expr -> INC ID .)
    if              reduce using rule 47 (expr -> INC ID .)
    {               reduce using rule 47 (expr -> INC ID .)
    BLTIN           reduce using rule 47 (expr -> INC ID .)
    NUMBER          reduce using rule 47 (expr -> INC ID .)
    NOT             reduce using rule 47 (expr -> INC ID .)
    INC             reduce using rule 47 (expr -> INC ID .)
    DEC             reduce using rule 47 (expr -> INC ID .)
    RETURN          reduce using rule 47 (expr -> INC ID .)
    read            reduce using rule 47 (expr -> INC ID .)
    (               reduce using rule 47 (expr -> INC ID .)
    $end            reduce using rule 47 (expr -> INC ID .)
    )               reduce using rule 47 (expr -> INC ID .)
    ;               reduce using rule 47 (expr -> INC ID .)
    }               reduce using rule 47 (expr -> INC ID .)
    ,               reduce using rule 47 (expr -> INC ID .)
    ELSE            reduce using rule 47 (expr -> INC ID .)


state 63

    (16) stmt -> if ( cond . ) stmt end
    (17) stmt -> if ( cond . ) stmt end ELSE stmt end

    )               shift and go to state 95


state 64

    (19) cond -> expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (33) expr -> expr . EXPONENT expr
    (37) expr -> expr . % expr
    (38) expr -> expr . OR expr
    (39) expr -> expr . AND expr
    (41) expr -> expr . LT expr
    (42) expr -> expr . GT expr
    (43) expr -> expr . LE expr
    (44) expr -> expr . GE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NE expr

    ;               reduce using rule 19 (cond -> expr .)
    )               reduce using rule 19 (cond -> expr .)
    +               shift and go to state 47
    -               shift and go to state 49
    *               shift and go to state 48
    /               shift and go to state 51
    EXPONENT        shift and go to state 46
    %               shift and go to state 45
    OR              shift and go to state 56
    AND             shift and go to state 43
    LT              shift and go to state 53
    GT              shift and go to state 44
    LE              shift and go to state 54
    GE              shift and go to state 50
    EQ              shift and go to state 55
    NE              shift and go to state 52


state 65

    (15) stmt -> for ( cond . ; cond ; cond ) stmt end

    ;               shift and go to state 96


state 66

    (36) factor -> ( expr ) .

    )               reduce using rule 36 (factor -> ( expr ) .)
    +               reduce using rule 36 (factor -> ( expr ) .)
    -               reduce using rule 36 (factor -> ( expr ) .)
    *               reduce using rule 36 (factor -> ( expr ) .)
    /               reduce using rule 36 (factor -> ( expr ) .)
    EXPONENT        reduce using rule 36 (factor -> ( expr ) .)
    %               reduce using rule 36 (factor -> ( expr ) .)
    OR              reduce using rule 36 (factor -> ( expr ) .)
    AND             reduce using rule 36 (factor -> ( expr ) .)
    LT              reduce using rule 36 (factor -> ( expr ) .)
    GT              reduce using rule 36 (factor -> ( expr ) .)
    LE              reduce using rule 36 (factor -> ( expr ) .)
    GE              reduce using rule 36 (factor -> ( expr ) .)
    EQ              reduce using rule 36 (factor -> ( expr ) .)
    NE              reduce using rule 36 (factor -> ( expr ) .)
    ID              reduce using rule 36 (factor -> ( expr ) .)
    procedure       reduce using rule 36 (factor -> ( expr ) .)
    print           reduce using rule 36 (factor -> ( expr ) .)
    while           reduce using rule 36 (factor -> ( expr ) .)
    for             reduce using rule 36 (factor -> ( expr ) .)
    if              reduce using rule 36 (factor -> ( expr ) .)
    {               reduce using rule 36 (factor -> ( expr ) .)
    BLTIN           reduce using rule 36 (factor -> ( expr ) .)
    NUMBER          reduce using rule 36 (factor -> ( expr ) .)
    NOT             reduce using rule 36 (factor -> ( expr ) .)
    INC             reduce using rule 36 (factor -> ( expr ) .)
    DEC             reduce using rule 36 (factor -> ( expr ) .)
    RETURN          reduce using rule 36 (factor -> ( expr ) .)
    read            reduce using rule 36 (factor -> ( expr ) .)
    (               reduce using rule 36 (factor -> ( expr ) .)
    $end            reduce using rule 36 (factor -> ( expr ) .)
    ;               reduce using rule 36 (factor -> ( expr ) .)
    }               reduce using rule 36 (factor -> ( expr ) .)
    ,               reduce using rule 36 (factor -> ( expr ) .)
    ELSE            reduce using rule 36 (factor -> ( expr ) .)


state 67

    (52) prlist -> prlist , . expr
    (53) prlist -> prlist , . STRING
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    STRING          shift and go to state 97
    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    read            shift and go to state 12
    (               shift and go to state 7

    expr                           shift and go to state 98
    term                           shift and go to state 16
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 68

    (11) stmt -> return ( expr . )
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (33) expr -> expr . EXPONENT expr
    (37) expr -> expr . % expr
    (38) expr -> expr . OR expr
    (39) expr -> expr . AND expr
    (41) expr -> expr . LT expr
    (42) expr -> expr . GT expr
    (43) expr -> expr . LE expr
    (44) expr -> expr . GE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NE expr

    )               shift and go to state 99
    +               shift and go to state 47
    -               shift and go to state 49
    *               shift and go to state 48
    /               shift and go to state 51
    EXPONENT        shift and go to state 46
    %               shift and go to state 45
    OR              shift and go to state 56
    AND             shift and go to state 43
    LT              shift and go to state 53
    GT              shift and go to state 44
    LE              shift and go to state 54
    GE              shift and go to state 50
    EQ              shift and go to state 55
    NE              shift and go to state 52


state 69

    (25) term -> read ( ID . )

    )               shift and go to state 100


state 70

    (26) expr -> BLTIN ( expr . )
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (33) expr -> expr . EXPONENT expr
    (37) expr -> expr . % expr
    (38) expr -> expr . OR expr
    (39) expr -> expr . AND expr
    (41) expr -> expr . LT expr
    (42) expr -> expr . GT expr
    (43) expr -> expr . LE expr
    (44) expr -> expr . GE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NE expr

    )               shift and go to state 101
    +               shift and go to state 47
    -               shift and go to state 49
    *               shift and go to state 48
    /               shift and go to state 51
    EXPONENT        shift and go to state 46
    %               shift and go to state 45
    OR              shift and go to state 56
    AND             shift and go to state 43
    LT              shift and go to state 53
    GT              shift and go to state 44
    LE              shift and go to state 54
    GE              shift and go to state 50
    EQ              shift and go to state 55
    NE              shift and go to state 52


state 71

    (9) asgn -> ID MODEQ expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (33) expr -> expr . EXPONENT expr
    (37) expr -> expr . % expr
    (38) expr -> expr . OR expr
    (39) expr -> expr . AND expr
    (41) expr -> expr . LT expr
    (42) expr -> expr . GT expr
    (43) expr -> expr . LE expr
    (44) expr -> expr . GE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NE expr

    ;               reduce using rule 9 (asgn -> ID MODEQ expr .)
    ELSE            reduce using rule 9 (asgn -> ID MODEQ expr .)
    ID              reduce using rule 9 (asgn -> ID MODEQ expr .)
    procedure       reduce using rule 9 (asgn -> ID MODEQ expr .)
    print           reduce using rule 9 (asgn -> ID MODEQ expr .)
    while           reduce using rule 9 (asgn -> ID MODEQ expr .)
    for             reduce using rule 9 (asgn -> ID MODEQ expr .)
    if              reduce using rule 9 (asgn -> ID MODEQ expr .)
    {               reduce using rule 9 (asgn -> ID MODEQ expr .)
    BLTIN           reduce using rule 9 (asgn -> ID MODEQ expr .)
    NUMBER          reduce using rule 9 (asgn -> ID MODEQ expr .)
    NOT             reduce using rule 9 (asgn -> ID MODEQ expr .)
    INC             reduce using rule 9 (asgn -> ID MODEQ expr .)
    DEC             reduce using rule 9 (asgn -> ID MODEQ expr .)
    RETURN          reduce using rule 9 (asgn -> ID MODEQ expr .)
    read            reduce using rule 9 (asgn -> ID MODEQ expr .)
    (               reduce using rule 9 (asgn -> ID MODEQ expr .)
    $end            reduce using rule 9 (asgn -> ID MODEQ expr .)
    }               reduce using rule 9 (asgn -> ID MODEQ expr .)
    )               reduce using rule 9 (asgn -> ID MODEQ expr .)
    ,               reduce using rule 9 (asgn -> ID MODEQ expr .)
    +               shift and go to state 47
    -               shift and go to state 49
    *               shift and go to state 48
    /               shift and go to state 51
    EXPONENT        shift and go to state 46
    %               shift and go to state 45
    OR              shift and go to state 56
    AND             shift and go to state 43
    LT              shift and go to state 53
    GT              shift and go to state 44
    LE              shift and go to state 54
    GE              shift and go to state 50
    EQ              shift and go to state 55
    NE              shift and go to state 52

  ! +               [ reduce using rule 9 (asgn -> ID MODEQ expr .) ]
  ! -               [ reduce using rule 9 (asgn -> ID MODEQ expr .) ]
  ! *               [ reduce using rule 9 (asgn -> ID MODEQ expr .) ]
  ! /               [ reduce using rule 9 (asgn -> ID MODEQ expr .) ]
  ! EXPONENT        [ reduce using rule 9 (asgn -> ID MODEQ expr .) ]
  ! %               [ reduce using rule 9 (asgn -> ID MODEQ expr .) ]
  ! OR              [ reduce using rule 9 (asgn -> ID MODEQ expr .) ]
  ! AND             [ reduce using rule 9 (asgn -> ID MODEQ expr .) ]
  ! LT              [ reduce using rule 9 (asgn -> ID MODEQ expr .) ]
  ! GT              [ reduce using rule 9 (asgn -> ID MODEQ expr .) ]
  ! LE              [ reduce using rule 9 (asgn -> ID MODEQ expr .) ]
  ! GE              [ reduce using rule 9 (asgn -> ID MODEQ expr .) ]
  ! EQ              [ reduce using rule 9 (asgn -> ID MODEQ expr .) ]
  ! NE              [ reduce using rule 9 (asgn -> ID MODEQ expr .) ]


state 72

    (6) asgn -> ID SUBEQ expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (33) expr -> expr . EXPONENT expr
    (37) expr -> expr . % expr
    (38) expr -> expr . OR expr
    (39) expr -> expr . AND expr
    (41) expr -> expr . LT expr
    (42) expr -> expr . GT expr
    (43) expr -> expr . LE expr
    (44) expr -> expr . GE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NE expr

    ;               reduce using rule 6 (asgn -> ID SUBEQ expr .)
    ELSE            reduce using rule 6 (asgn -> ID SUBEQ expr .)
    ID              reduce using rule 6 (asgn -> ID SUBEQ expr .)
    procedure       reduce using rule 6 (asgn -> ID SUBEQ expr .)
    print           reduce using rule 6 (asgn -> ID SUBEQ expr .)
    while           reduce using rule 6 (asgn -> ID SUBEQ expr .)
    for             reduce using rule 6 (asgn -> ID SUBEQ expr .)
    if              reduce using rule 6 (asgn -> ID SUBEQ expr .)
    {               reduce using rule 6 (asgn -> ID SUBEQ expr .)
    BLTIN           reduce using rule 6 (asgn -> ID SUBEQ expr .)
    NUMBER          reduce using rule 6 (asgn -> ID SUBEQ expr .)
    NOT             reduce using rule 6 (asgn -> ID SUBEQ expr .)
    INC             reduce using rule 6 (asgn -> ID SUBEQ expr .)
    DEC             reduce using rule 6 (asgn -> ID SUBEQ expr .)
    RETURN          reduce using rule 6 (asgn -> ID SUBEQ expr .)
    read            reduce using rule 6 (asgn -> ID SUBEQ expr .)
    (               reduce using rule 6 (asgn -> ID SUBEQ expr .)
    $end            reduce using rule 6 (asgn -> ID SUBEQ expr .)
    }               reduce using rule 6 (asgn -> ID SUBEQ expr .)
    )               reduce using rule 6 (asgn -> ID SUBEQ expr .)
    ,               reduce using rule 6 (asgn -> ID SUBEQ expr .)
    +               shift and go to state 47
    -               shift and go to state 49
    *               shift and go to state 48
    /               shift and go to state 51
    EXPONENT        shift and go to state 46
    %               shift and go to state 45
    OR              shift and go to state 56
    AND             shift and go to state 43
    LT              shift and go to state 53
    GT              shift and go to state 44
    LE              shift and go to state 54
    GE              shift and go to state 50
    EQ              shift and go to state 55
    NE              shift and go to state 52

  ! +               [ reduce using rule 6 (asgn -> ID SUBEQ expr .) ]
  ! -               [ reduce using rule 6 (asgn -> ID SUBEQ expr .) ]
  ! *               [ reduce using rule 6 (asgn -> ID SUBEQ expr .) ]
  ! /               [ reduce using rule 6 (asgn -> ID SUBEQ expr .) ]
  ! EXPONENT        [ reduce using rule 6 (asgn -> ID SUBEQ expr .) ]
  ! %               [ reduce using rule 6 (asgn -> ID SUBEQ expr .) ]
  ! OR              [ reduce using rule 6 (asgn -> ID SUBEQ expr .) ]
  ! AND             [ reduce using rule 6 (asgn -> ID SUBEQ expr .) ]
  ! LT              [ reduce using rule 6 (asgn -> ID SUBEQ expr .) ]
  ! GT              [ reduce using rule 6 (asgn -> ID SUBEQ expr .) ]
  ! LE              [ reduce using rule 6 (asgn -> ID SUBEQ expr .) ]
  ! GE              [ reduce using rule 6 (asgn -> ID SUBEQ expr .) ]
  ! EQ              [ reduce using rule 6 (asgn -> ID SUBEQ expr .) ]
  ! NE              [ reduce using rule 6 (asgn -> ID SUBEQ expr .) ]


state 73

    (7) asgn -> ID MULEQ expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (33) expr -> expr . EXPONENT expr
    (37) expr -> expr . % expr
    (38) expr -> expr . OR expr
    (39) expr -> expr . AND expr
    (41) expr -> expr . LT expr
    (42) expr -> expr . GT expr
    (43) expr -> expr . LE expr
    (44) expr -> expr . GE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NE expr

    ;               reduce using rule 7 (asgn -> ID MULEQ expr .)
    ELSE            reduce using rule 7 (asgn -> ID MULEQ expr .)
    ID              reduce using rule 7 (asgn -> ID MULEQ expr .)
    procedure       reduce using rule 7 (asgn -> ID MULEQ expr .)
    print           reduce using rule 7 (asgn -> ID MULEQ expr .)
    while           reduce using rule 7 (asgn -> ID MULEQ expr .)
    for             reduce using rule 7 (asgn -> ID MULEQ expr .)
    if              reduce using rule 7 (asgn -> ID MULEQ expr .)
    {               reduce using rule 7 (asgn -> ID MULEQ expr .)
    BLTIN           reduce using rule 7 (asgn -> ID MULEQ expr .)
    NUMBER          reduce using rule 7 (asgn -> ID MULEQ expr .)
    NOT             reduce using rule 7 (asgn -> ID MULEQ expr .)
    INC             reduce using rule 7 (asgn -> ID MULEQ expr .)
    DEC             reduce using rule 7 (asgn -> ID MULEQ expr .)
    RETURN          reduce using rule 7 (asgn -> ID MULEQ expr .)
    read            reduce using rule 7 (asgn -> ID MULEQ expr .)
    (               reduce using rule 7 (asgn -> ID MULEQ expr .)
    $end            reduce using rule 7 (asgn -> ID MULEQ expr .)
    }               reduce using rule 7 (asgn -> ID MULEQ expr .)
    )               reduce using rule 7 (asgn -> ID MULEQ expr .)
    ,               reduce using rule 7 (asgn -> ID MULEQ expr .)
    +               shift and go to state 47
    -               shift and go to state 49
    *               shift and go to state 48
    /               shift and go to state 51
    EXPONENT        shift and go to state 46
    %               shift and go to state 45
    OR              shift and go to state 56
    AND             shift and go to state 43
    LT              shift and go to state 53
    GT              shift and go to state 44
    LE              shift and go to state 54
    GE              shift and go to state 50
    EQ              shift and go to state 55
    NE              shift and go to state 52

  ! +               [ reduce using rule 7 (asgn -> ID MULEQ expr .) ]
  ! -               [ reduce using rule 7 (asgn -> ID MULEQ expr .) ]
  ! *               [ reduce using rule 7 (asgn -> ID MULEQ expr .) ]
  ! /               [ reduce using rule 7 (asgn -> ID MULEQ expr .) ]
  ! EXPONENT        [ reduce using rule 7 (asgn -> ID MULEQ expr .) ]
  ! %               [ reduce using rule 7 (asgn -> ID MULEQ expr .) ]
  ! OR              [ reduce using rule 7 (asgn -> ID MULEQ expr .) ]
  ! AND             [ reduce using rule 7 (asgn -> ID MULEQ expr .) ]
  ! LT              [ reduce using rule 7 (asgn -> ID MULEQ expr .) ]
  ! GT              [ reduce using rule 7 (asgn -> ID MULEQ expr .) ]
  ! LE              [ reduce using rule 7 (asgn -> ID MULEQ expr .) ]
  ! GE              [ reduce using rule 7 (asgn -> ID MULEQ expr .) ]
  ! EQ              [ reduce using rule 7 (asgn -> ID MULEQ expr .) ]
  ! NE              [ reduce using rule 7 (asgn -> ID MULEQ expr .) ]


state 74

    (5) asgn -> ID ADDEQ expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (33) expr -> expr . EXPONENT expr
    (37) expr -> expr . % expr
    (38) expr -> expr . OR expr
    (39) expr -> expr . AND expr
    (41) expr -> expr . LT expr
    (42) expr -> expr . GT expr
    (43) expr -> expr . LE expr
    (44) expr -> expr . GE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NE expr

    ;               reduce using rule 5 (asgn -> ID ADDEQ expr .)
    ELSE            reduce using rule 5 (asgn -> ID ADDEQ expr .)
    ID              reduce using rule 5 (asgn -> ID ADDEQ expr .)
    procedure       reduce using rule 5 (asgn -> ID ADDEQ expr .)
    print           reduce using rule 5 (asgn -> ID ADDEQ expr .)
    while           reduce using rule 5 (asgn -> ID ADDEQ expr .)
    for             reduce using rule 5 (asgn -> ID ADDEQ expr .)
    if              reduce using rule 5 (asgn -> ID ADDEQ expr .)
    {               reduce using rule 5 (asgn -> ID ADDEQ expr .)
    BLTIN           reduce using rule 5 (asgn -> ID ADDEQ expr .)
    NUMBER          reduce using rule 5 (asgn -> ID ADDEQ expr .)
    NOT             reduce using rule 5 (asgn -> ID ADDEQ expr .)
    INC             reduce using rule 5 (asgn -> ID ADDEQ expr .)
    DEC             reduce using rule 5 (asgn -> ID ADDEQ expr .)
    RETURN          reduce using rule 5 (asgn -> ID ADDEQ expr .)
    read            reduce using rule 5 (asgn -> ID ADDEQ expr .)
    (               reduce using rule 5 (asgn -> ID ADDEQ expr .)
    $end            reduce using rule 5 (asgn -> ID ADDEQ expr .)
    }               reduce using rule 5 (asgn -> ID ADDEQ expr .)
    )               reduce using rule 5 (asgn -> ID ADDEQ expr .)
    ,               reduce using rule 5 (asgn -> ID ADDEQ expr .)
    +               shift and go to state 47
    -               shift and go to state 49
    *               shift and go to state 48
    /               shift and go to state 51
    EXPONENT        shift and go to state 46
    %               shift and go to state 45
    OR              shift and go to state 56
    AND             shift and go to state 43
    LT              shift and go to state 53
    GT              shift and go to state 44
    LE              shift and go to state 54
    GE              shift and go to state 50
    EQ              shift and go to state 55
    NE              shift and go to state 52

  ! +               [ reduce using rule 5 (asgn -> ID ADDEQ expr .) ]
  ! -               [ reduce using rule 5 (asgn -> ID ADDEQ expr .) ]
  ! *               [ reduce using rule 5 (asgn -> ID ADDEQ expr .) ]
  ! /               [ reduce using rule 5 (asgn -> ID ADDEQ expr .) ]
  ! EXPONENT        [ reduce using rule 5 (asgn -> ID ADDEQ expr .) ]
  ! %               [ reduce using rule 5 (asgn -> ID ADDEQ expr .) ]
  ! OR              [ reduce using rule 5 (asgn -> ID ADDEQ expr .) ]
  ! AND             [ reduce using rule 5 (asgn -> ID ADDEQ expr .) ]
  ! LT              [ reduce using rule 5 (asgn -> ID ADDEQ expr .) ]
  ! GT              [ reduce using rule 5 (asgn -> ID ADDEQ expr .) ]
  ! LE              [ reduce using rule 5 (asgn -> ID ADDEQ expr .) ]
  ! GE              [ reduce using rule 5 (asgn -> ID ADDEQ expr .) ]
  ! EQ              [ reduce using rule 5 (asgn -> ID ADDEQ expr .) ]
  ! NE              [ reduce using rule 5 (asgn -> ID ADDEQ expr .) ]


state 75

    (4) asgn -> ID = expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (33) expr -> expr . EXPONENT expr
    (37) expr -> expr . % expr
    (38) expr -> expr . OR expr
    (39) expr -> expr . AND expr
    (41) expr -> expr . LT expr
    (42) expr -> expr . GT expr
    (43) expr -> expr . LE expr
    (44) expr -> expr . GE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NE expr

    ;               reduce using rule 4 (asgn -> ID = expr .)
    ELSE            reduce using rule 4 (asgn -> ID = expr .)
    ID              reduce using rule 4 (asgn -> ID = expr .)
    procedure       reduce using rule 4 (asgn -> ID = expr .)
    print           reduce using rule 4 (asgn -> ID = expr .)
    while           reduce using rule 4 (asgn -> ID = expr .)
    for             reduce using rule 4 (asgn -> ID = expr .)
    if              reduce using rule 4 (asgn -> ID = expr .)
    {               reduce using rule 4 (asgn -> ID = expr .)
    BLTIN           reduce using rule 4 (asgn -> ID = expr .)
    NUMBER          reduce using rule 4 (asgn -> ID = expr .)
    NOT             reduce using rule 4 (asgn -> ID = expr .)
    INC             reduce using rule 4 (asgn -> ID = expr .)
    DEC             reduce using rule 4 (asgn -> ID = expr .)
    RETURN          reduce using rule 4 (asgn -> ID = expr .)
    read            reduce using rule 4 (asgn -> ID = expr .)
    (               reduce using rule 4 (asgn -> ID = expr .)
    $end            reduce using rule 4 (asgn -> ID = expr .)
    }               reduce using rule 4 (asgn -> ID = expr .)
    )               reduce using rule 4 (asgn -> ID = expr .)
    ,               reduce using rule 4 (asgn -> ID = expr .)
    +               shift and go to state 47
    -               shift and go to state 49
    *               shift and go to state 48
    /               shift and go to state 51
    EXPONENT        shift and go to state 46
    %               shift and go to state 45
    OR              shift and go to state 56
    AND             shift and go to state 43
    LT              shift and go to state 53
    GT              shift and go to state 44
    LE              shift and go to state 54
    GE              shift and go to state 50
    EQ              shift and go to state 55
    NE              shift and go to state 52

  ! +               [ reduce using rule 4 (asgn -> ID = expr .) ]
  ! -               [ reduce using rule 4 (asgn -> ID = expr .) ]
  ! *               [ reduce using rule 4 (asgn -> ID = expr .) ]
  ! /               [ reduce using rule 4 (asgn -> ID = expr .) ]
  ! EXPONENT        [ reduce using rule 4 (asgn -> ID = expr .) ]
  ! %               [ reduce using rule 4 (asgn -> ID = expr .) ]
  ! OR              [ reduce using rule 4 (asgn -> ID = expr .) ]
  ! AND             [ reduce using rule 4 (asgn -> ID = expr .) ]
  ! LT              [ reduce using rule 4 (asgn -> ID = expr .) ]
  ! GT              [ reduce using rule 4 (asgn -> ID = expr .) ]
  ! LE              [ reduce using rule 4 (asgn -> ID = expr .) ]
  ! GE              [ reduce using rule 4 (asgn -> ID = expr .) ]
  ! EQ              [ reduce using rule 4 (asgn -> ID = expr .) ]
  ! NE              [ reduce using rule 4 (asgn -> ID = expr .) ]


state 76

    (8) asgn -> ID DIVEQ expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (33) expr -> expr . EXPONENT expr
    (37) expr -> expr . % expr
    (38) expr -> expr . OR expr
    (39) expr -> expr . AND expr
    (41) expr -> expr . LT expr
    (42) expr -> expr . GT expr
    (43) expr -> expr . LE expr
    (44) expr -> expr . GE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NE expr

    ;               reduce using rule 8 (asgn -> ID DIVEQ expr .)
    ELSE            reduce using rule 8 (asgn -> ID DIVEQ expr .)
    ID              reduce using rule 8 (asgn -> ID DIVEQ expr .)
    procedure       reduce using rule 8 (asgn -> ID DIVEQ expr .)
    print           reduce using rule 8 (asgn -> ID DIVEQ expr .)
    while           reduce using rule 8 (asgn -> ID DIVEQ expr .)
    for             reduce using rule 8 (asgn -> ID DIVEQ expr .)
    if              reduce using rule 8 (asgn -> ID DIVEQ expr .)
    {               reduce using rule 8 (asgn -> ID DIVEQ expr .)
    BLTIN           reduce using rule 8 (asgn -> ID DIVEQ expr .)
    NUMBER          reduce using rule 8 (asgn -> ID DIVEQ expr .)
    NOT             reduce using rule 8 (asgn -> ID DIVEQ expr .)
    INC             reduce using rule 8 (asgn -> ID DIVEQ expr .)
    DEC             reduce using rule 8 (asgn -> ID DIVEQ expr .)
    RETURN          reduce using rule 8 (asgn -> ID DIVEQ expr .)
    read            reduce using rule 8 (asgn -> ID DIVEQ expr .)
    (               reduce using rule 8 (asgn -> ID DIVEQ expr .)
    $end            reduce using rule 8 (asgn -> ID DIVEQ expr .)
    }               reduce using rule 8 (asgn -> ID DIVEQ expr .)
    )               reduce using rule 8 (asgn -> ID DIVEQ expr .)
    ,               reduce using rule 8 (asgn -> ID DIVEQ expr .)
    +               shift and go to state 47
    -               shift and go to state 49
    *               shift and go to state 48
    /               shift and go to state 51
    EXPONENT        shift and go to state 46
    %               shift and go to state 45
    OR              shift and go to state 56
    AND             shift and go to state 43
    LT              shift and go to state 53
    GT              shift and go to state 44
    LE              shift and go to state 54
    GE              shift and go to state 50
    EQ              shift and go to state 55
    NE              shift and go to state 52

  ! +               [ reduce using rule 8 (asgn -> ID DIVEQ expr .) ]
  ! -               [ reduce using rule 8 (asgn -> ID DIVEQ expr .) ]
  ! *               [ reduce using rule 8 (asgn -> ID DIVEQ expr .) ]
  ! /               [ reduce using rule 8 (asgn -> ID DIVEQ expr .) ]
  ! EXPONENT        [ reduce using rule 8 (asgn -> ID DIVEQ expr .) ]
  ! %               [ reduce using rule 8 (asgn -> ID DIVEQ expr .) ]
  ! OR              [ reduce using rule 8 (asgn -> ID DIVEQ expr .) ]
  ! AND             [ reduce using rule 8 (asgn -> ID DIVEQ expr .) ]
  ! LT              [ reduce using rule 8 (asgn -> ID DIVEQ expr .) ]
  ! GT              [ reduce using rule 8 (asgn -> ID DIVEQ expr .) ]
  ! LE              [ reduce using rule 8 (asgn -> ID DIVEQ expr .) ]
  ! GE              [ reduce using rule 8 (asgn -> ID DIVEQ expr .) ]
  ! EQ              [ reduce using rule 8 (asgn -> ID DIVEQ expr .) ]
  ! NE              [ reduce using rule 8 (asgn -> ID DIVEQ expr .) ]


state 77

    (39) expr -> expr AND expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (33) expr -> expr . EXPONENT expr
    (37) expr -> expr . % expr
    (38) expr -> expr . OR expr
    (39) expr -> expr . AND expr
    (41) expr -> expr . LT expr
    (42) expr -> expr . GT expr
    (43) expr -> expr . LE expr
    (44) expr -> expr . GE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NE expr

    OR              reduce using rule 39 (expr -> expr AND expr .)
    AND             reduce using rule 39 (expr -> expr AND expr .)
    ID              reduce using rule 39 (expr -> expr AND expr .)
    procedure       reduce using rule 39 (expr -> expr AND expr .)
    print           reduce using rule 39 (expr -> expr AND expr .)
    while           reduce using rule 39 (expr -> expr AND expr .)
    for             reduce using rule 39 (expr -> expr AND expr .)
    if              reduce using rule 39 (expr -> expr AND expr .)
    {               reduce using rule 39 (expr -> expr AND expr .)
    BLTIN           reduce using rule 39 (expr -> expr AND expr .)
    NUMBER          reduce using rule 39 (expr -> expr AND expr .)
    NOT             reduce using rule 39 (expr -> expr AND expr .)
    INC             reduce using rule 39 (expr -> expr AND expr .)
    DEC             reduce using rule 39 (expr -> expr AND expr .)
    RETURN          reduce using rule 39 (expr -> expr AND expr .)
    read            reduce using rule 39 (expr -> expr AND expr .)
    (               reduce using rule 39 (expr -> expr AND expr .)
    $end            reduce using rule 39 (expr -> expr AND expr .)
    )               reduce using rule 39 (expr -> expr AND expr .)
    ;               reduce using rule 39 (expr -> expr AND expr .)
    }               reduce using rule 39 (expr -> expr AND expr .)
    ,               reduce using rule 39 (expr -> expr AND expr .)
    ELSE            reduce using rule 39 (expr -> expr AND expr .)
    +               shift and go to state 47
    -               shift and go to state 49
    *               shift and go to state 48
    /               shift and go to state 51
    EXPONENT        shift and go to state 46
    %               shift and go to state 45
    LT              shift and go to state 53
    GT              shift and go to state 44
    LE              shift and go to state 54
    GE              shift and go to state 50
    EQ              shift and go to state 55
    NE              shift and go to state 52

  ! +               [ reduce using rule 39 (expr -> expr AND expr .) ]
  ! -               [ reduce using rule 39 (expr -> expr AND expr .) ]
  ! *               [ reduce using rule 39 (expr -> expr AND expr .) ]
  ! /               [ reduce using rule 39 (expr -> expr AND expr .) ]
  ! EXPONENT        [ reduce using rule 39 (expr -> expr AND expr .) ]
  ! %               [ reduce using rule 39 (expr -> expr AND expr .) ]
  ! LT              [ reduce using rule 39 (expr -> expr AND expr .) ]
  ! GT              [ reduce using rule 39 (expr -> expr AND expr .) ]
  ! LE              [ reduce using rule 39 (expr -> expr AND expr .) ]
  ! GE              [ reduce using rule 39 (expr -> expr AND expr .) ]
  ! EQ              [ reduce using rule 39 (expr -> expr AND expr .) ]
  ! NE              [ reduce using rule 39 (expr -> expr AND expr .) ]
  ! OR              [ shift and go to state 56 ]
  ! AND             [ shift and go to state 43 ]


state 78

    (42) expr -> expr GT expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (33) expr -> expr . EXPONENT expr
    (37) expr -> expr . % expr
    (38) expr -> expr . OR expr
    (39) expr -> expr . AND expr
    (41) expr -> expr . LT expr
    (42) expr -> expr . GT expr
    (43) expr -> expr . LE expr
    (44) expr -> expr . GE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NE expr

    OR              reduce using rule 42 (expr -> expr GT expr .)
    AND             reduce using rule 42 (expr -> expr GT expr .)
    LT              reduce using rule 42 (expr -> expr GT expr .)
    GT              reduce using rule 42 (expr -> expr GT expr .)
    LE              reduce using rule 42 (expr -> expr GT expr .)
    GE              reduce using rule 42 (expr -> expr GT expr .)
    EQ              reduce using rule 42 (expr -> expr GT expr .)
    NE              reduce using rule 42 (expr -> expr GT expr .)
    ID              reduce using rule 42 (expr -> expr GT expr .)
    procedure       reduce using rule 42 (expr -> expr GT expr .)
    print           reduce using rule 42 (expr -> expr GT expr .)
    while           reduce using rule 42 (expr -> expr GT expr .)
    for             reduce using rule 42 (expr -> expr GT expr .)
    if              reduce using rule 42 (expr -> expr GT expr .)
    {               reduce using rule 42 (expr -> expr GT expr .)
    BLTIN           reduce using rule 42 (expr -> expr GT expr .)
    NUMBER          reduce using rule 42 (expr -> expr GT expr .)
    NOT             reduce using rule 42 (expr -> expr GT expr .)
    INC             reduce using rule 42 (expr -> expr GT expr .)
    DEC             reduce using rule 42 (expr -> expr GT expr .)
    RETURN          reduce using rule 42 (expr -> expr GT expr .)
    read            reduce using rule 42 (expr -> expr GT expr .)
    (               reduce using rule 42 (expr -> expr GT expr .)
    $end            reduce using rule 42 (expr -> expr GT expr .)
    )               reduce using rule 42 (expr -> expr GT expr .)
    ;               reduce using rule 42 (expr -> expr GT expr .)
    }               reduce using rule 42 (expr -> expr GT expr .)
    ,               reduce using rule 42 (expr -> expr GT expr .)
    ELSE            reduce using rule 42 (expr -> expr GT expr .)
    +               shift and go to state 47
    -               shift and go to state 49
    *               shift and go to state 48
    /               shift and go to state 51
    EXPONENT        shift and go to state 46
    %               shift and go to state 45

  ! +               [ reduce using rule 42 (expr -> expr GT expr .) ]
  ! -               [ reduce using rule 42 (expr -> expr GT expr .) ]
  ! *               [ reduce using rule 42 (expr -> expr GT expr .) ]
  ! /               [ reduce using rule 42 (expr -> expr GT expr .) ]
  ! EXPONENT        [ reduce using rule 42 (expr -> expr GT expr .) ]
  ! %               [ reduce using rule 42 (expr -> expr GT expr .) ]
  ! OR              [ shift and go to state 56 ]
  ! AND             [ shift and go to state 43 ]
  ! LT              [ shift and go to state 53 ]
  ! GT              [ shift and go to state 44 ]
  ! LE              [ shift and go to state 54 ]
  ! GE              [ shift and go to state 50 ]
  ! EQ              [ shift and go to state 55 ]
  ! NE              [ shift and go to state 52 ]


state 79

    (37) expr -> expr % expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (33) expr -> expr . EXPONENT expr
    (37) expr -> expr . % expr
    (38) expr -> expr . OR expr
    (39) expr -> expr . AND expr
    (41) expr -> expr . LT expr
    (42) expr -> expr . GT expr
    (43) expr -> expr . LE expr
    (44) expr -> expr . GE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NE expr

    +               reduce using rule 37 (expr -> expr % expr .)
    -               reduce using rule 37 (expr -> expr % expr .)
    *               reduce using rule 37 (expr -> expr % expr .)
    /               reduce using rule 37 (expr -> expr % expr .)
    %               reduce using rule 37 (expr -> expr % expr .)
    OR              reduce using rule 37 (expr -> expr % expr .)
    AND             reduce using rule 37 (expr -> expr % expr .)
    LT              reduce using rule 37 (expr -> expr % expr .)
    GT              reduce using rule 37 (expr -> expr % expr .)
    LE              reduce using rule 37 (expr -> expr % expr .)
    GE              reduce using rule 37 (expr -> expr % expr .)
    EQ              reduce using rule 37 (expr -> expr % expr .)
    NE              reduce using rule 37 (expr -> expr % expr .)
    ID              reduce using rule 37 (expr -> expr % expr .)
    procedure       reduce using rule 37 (expr -> expr % expr .)
    print           reduce using rule 37 (expr -> expr % expr .)
    while           reduce using rule 37 (expr -> expr % expr .)
    for             reduce using rule 37 (expr -> expr % expr .)
    if              reduce using rule 37 (expr -> expr % expr .)
    {               reduce using rule 37 (expr -> expr % expr .)
    BLTIN           reduce using rule 37 (expr -> expr % expr .)
    NUMBER          reduce using rule 37 (expr -> expr % expr .)
    NOT             reduce using rule 37 (expr -> expr % expr .)
    INC             reduce using rule 37 (expr -> expr % expr .)
    DEC             reduce using rule 37 (expr -> expr % expr .)
    RETURN          reduce using rule 37 (expr -> expr % expr .)
    read            reduce using rule 37 (expr -> expr % expr .)
    (               reduce using rule 37 (expr -> expr % expr .)
    $end            reduce using rule 37 (expr -> expr % expr .)
    )               reduce using rule 37 (expr -> expr % expr .)
    ;               reduce using rule 37 (expr -> expr % expr .)
    }               reduce using rule 37 (expr -> expr % expr .)
    ,               reduce using rule 37 (expr -> expr % expr .)
    ELSE            reduce using rule 37 (expr -> expr % expr .)
    EXPONENT        shift and go to state 46

  ! EXPONENT        [ reduce using rule 37 (expr -> expr % expr .) ]
  ! +               [ shift and go to state 47 ]
  ! -               [ shift and go to state 49 ]
  ! *               [ shift and go to state 48 ]
  ! /               [ shift and go to state 51 ]
  ! %               [ shift and go to state 45 ]
  ! OR              [ shift and go to state 56 ]
  ! AND             [ shift and go to state 43 ]
  ! LT              [ shift and go to state 53 ]
  ! GT              [ shift and go to state 44 ]
  ! LE              [ shift and go to state 54 ]
  ! GE              [ shift and go to state 50 ]
  ! EQ              [ shift and go to state 55 ]
  ! NE              [ shift and go to state 52 ]


state 80

    (33) expr -> expr EXPONENT expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (33) expr -> expr . EXPONENT expr
    (37) expr -> expr . % expr
    (38) expr -> expr . OR expr
    (39) expr -> expr . AND expr
    (41) expr -> expr . LT expr
    (42) expr -> expr . GT expr
    (43) expr -> expr . LE expr
    (44) expr -> expr . GE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NE expr

    +               reduce using rule 33 (expr -> expr EXPONENT expr .)
    -               reduce using rule 33 (expr -> expr EXPONENT expr .)
    *               reduce using rule 33 (expr -> expr EXPONENT expr .)
    /               reduce using rule 33 (expr -> expr EXPONENT expr .)
    %               reduce using rule 33 (expr -> expr EXPONENT expr .)
    OR              reduce using rule 33 (expr -> expr EXPONENT expr .)
    AND             reduce using rule 33 (expr -> expr EXPONENT expr .)
    LT              reduce using rule 33 (expr -> expr EXPONENT expr .)
    GT              reduce using rule 33 (expr -> expr EXPONENT expr .)
    LE              reduce using rule 33 (expr -> expr EXPONENT expr .)
    GE              reduce using rule 33 (expr -> expr EXPONENT expr .)
    EQ              reduce using rule 33 (expr -> expr EXPONENT expr .)
    NE              reduce using rule 33 (expr -> expr EXPONENT expr .)
    ID              reduce using rule 33 (expr -> expr EXPONENT expr .)
    procedure       reduce using rule 33 (expr -> expr EXPONENT expr .)
    print           reduce using rule 33 (expr -> expr EXPONENT expr .)
    while           reduce using rule 33 (expr -> expr EXPONENT expr .)
    for             reduce using rule 33 (expr -> expr EXPONENT expr .)
    if              reduce using rule 33 (expr -> expr EXPONENT expr .)
    {               reduce using rule 33 (expr -> expr EXPONENT expr .)
    BLTIN           reduce using rule 33 (expr -> expr EXPONENT expr .)
    NUMBER          reduce using rule 33 (expr -> expr EXPONENT expr .)
    NOT             reduce using rule 33 (expr -> expr EXPONENT expr .)
    INC             reduce using rule 33 (expr -> expr EXPONENT expr .)
    DEC             reduce using rule 33 (expr -> expr EXPONENT expr .)
    RETURN          reduce using rule 33 (expr -> expr EXPONENT expr .)
    read            reduce using rule 33 (expr -> expr EXPONENT expr .)
    (               reduce using rule 33 (expr -> expr EXPONENT expr .)
    $end            reduce using rule 33 (expr -> expr EXPONENT expr .)
    )               reduce using rule 33 (expr -> expr EXPONENT expr .)
    ;               reduce using rule 33 (expr -> expr EXPONENT expr .)
    }               reduce using rule 33 (expr -> expr EXPONENT expr .)
    ,               reduce using rule 33 (expr -> expr EXPONENT expr .)
    ELSE            reduce using rule 33 (expr -> expr EXPONENT expr .)
    EXPONENT        shift and go to state 46

  ! EXPONENT        [ reduce using rule 33 (expr -> expr EXPONENT expr .) ]
  ! +               [ shift and go to state 47 ]
  ! -               [ shift and go to state 49 ]
  ! *               [ shift and go to state 48 ]
  ! /               [ shift and go to state 51 ]
  ! %               [ shift and go to state 45 ]
  ! OR              [ shift and go to state 56 ]
  ! AND             [ shift and go to state 43 ]
  ! LT              [ shift and go to state 53 ]
  ! GT              [ shift and go to state 44 ]
  ! LE              [ shift and go to state 54 ]
  ! GE              [ shift and go to state 50 ]
  ! EQ              [ shift and go to state 55 ]
  ! NE              [ shift and go to state 52 ]


state 81

    (28) expr -> expr + expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (33) expr -> expr . EXPONENT expr
    (37) expr -> expr . % expr
    (38) expr -> expr . OR expr
    (39) expr -> expr . AND expr
    (41) expr -> expr . LT expr
    (42) expr -> expr . GT expr
    (43) expr -> expr . LE expr
    (44) expr -> expr . GE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NE expr

    +               reduce using rule 28 (expr -> expr + expr .)
    -               reduce using rule 28 (expr -> expr + expr .)
    OR              reduce using rule 28 (expr -> expr + expr .)
    AND             reduce using rule 28 (expr -> expr + expr .)
    LT              reduce using rule 28 (expr -> expr + expr .)
    GT              reduce using rule 28 (expr -> expr + expr .)
    LE              reduce using rule 28 (expr -> expr + expr .)
    GE              reduce using rule 28 (expr -> expr + expr .)
    EQ              reduce using rule 28 (expr -> expr + expr .)
    NE              reduce using rule 28 (expr -> expr + expr .)
    ID              reduce using rule 28 (expr -> expr + expr .)
    procedure       reduce using rule 28 (expr -> expr + expr .)
    print           reduce using rule 28 (expr -> expr + expr .)
    while           reduce using rule 28 (expr -> expr + expr .)
    for             reduce using rule 28 (expr -> expr + expr .)
    if              reduce using rule 28 (expr -> expr + expr .)
    {               reduce using rule 28 (expr -> expr + expr .)
    BLTIN           reduce using rule 28 (expr -> expr + expr .)
    NUMBER          reduce using rule 28 (expr -> expr + expr .)
    NOT             reduce using rule 28 (expr -> expr + expr .)
    INC             reduce using rule 28 (expr -> expr + expr .)
    DEC             reduce using rule 28 (expr -> expr + expr .)
    RETURN          reduce using rule 28 (expr -> expr + expr .)
    read            reduce using rule 28 (expr -> expr + expr .)
    (               reduce using rule 28 (expr -> expr + expr .)
    $end            reduce using rule 28 (expr -> expr + expr .)
    )               reduce using rule 28 (expr -> expr + expr .)
    ;               reduce using rule 28 (expr -> expr + expr .)
    }               reduce using rule 28 (expr -> expr + expr .)
    ,               reduce using rule 28 (expr -> expr + expr .)
    ELSE            reduce using rule 28 (expr -> expr + expr .)
    *               shift and go to state 48
    /               shift and go to state 51
    EXPONENT        shift and go to state 46
    %               shift and go to state 45

  ! *               [ reduce using rule 28 (expr -> expr + expr .) ]
  ! /               [ reduce using rule 28 (expr -> expr + expr .) ]
  ! EXPONENT        [ reduce using rule 28 (expr -> expr + expr .) ]
  ! %               [ reduce using rule 28 (expr -> expr + expr .) ]
  ! +               [ shift and go to state 47 ]
  ! -               [ shift and go to state 49 ]
  ! OR              [ shift and go to state 56 ]
  ! AND             [ shift and go to state 43 ]
  ! LT              [ shift and go to state 53 ]
  ! GT              [ shift and go to state 44 ]
  ! LE              [ shift and go to state 54 ]
  ! GE              [ shift and go to state 50 ]
  ! EQ              [ shift and go to state 55 ]
  ! NE              [ shift and go to state 52 ]


state 82

    (30) expr -> expr * expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (33) expr -> expr . EXPONENT expr
    (37) expr -> expr . % expr
    (38) expr -> expr . OR expr
    (39) expr -> expr . AND expr
    (41) expr -> expr . LT expr
    (42) expr -> expr . GT expr
    (43) expr -> expr . LE expr
    (44) expr -> expr . GE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NE expr

    +               reduce using rule 30 (expr -> expr * expr .)
    -               reduce using rule 30 (expr -> expr * expr .)
    *               reduce using rule 30 (expr -> expr * expr .)
    /               reduce using rule 30 (expr -> expr * expr .)
    %               reduce using rule 30 (expr -> expr * expr .)
    OR              reduce using rule 30 (expr -> expr * expr .)
    AND             reduce using rule 30 (expr -> expr * expr .)
    LT              reduce using rule 30 (expr -> expr * expr .)
    GT              reduce using rule 30 (expr -> expr * expr .)
    LE              reduce using rule 30 (expr -> expr * expr .)
    GE              reduce using rule 30 (expr -> expr * expr .)
    EQ              reduce using rule 30 (expr -> expr * expr .)
    NE              reduce using rule 30 (expr -> expr * expr .)
    ID              reduce using rule 30 (expr -> expr * expr .)
    procedure       reduce using rule 30 (expr -> expr * expr .)
    print           reduce using rule 30 (expr -> expr * expr .)
    while           reduce using rule 30 (expr -> expr * expr .)
    for             reduce using rule 30 (expr -> expr * expr .)
    if              reduce using rule 30 (expr -> expr * expr .)
    {               reduce using rule 30 (expr -> expr * expr .)
    BLTIN           reduce using rule 30 (expr -> expr * expr .)
    NUMBER          reduce using rule 30 (expr -> expr * expr .)
    NOT             reduce using rule 30 (expr -> expr * expr .)
    INC             reduce using rule 30 (expr -> expr * expr .)
    DEC             reduce using rule 30 (expr -> expr * expr .)
    RETURN          reduce using rule 30 (expr -> expr * expr .)
    read            reduce using rule 30 (expr -> expr * expr .)
    (               reduce using rule 30 (expr -> expr * expr .)
    $end            reduce using rule 30 (expr -> expr * expr .)
    )               reduce using rule 30 (expr -> expr * expr .)
    ;               reduce using rule 30 (expr -> expr * expr .)
    }               reduce using rule 30 (expr -> expr * expr .)
    ,               reduce using rule 30 (expr -> expr * expr .)
    ELSE            reduce using rule 30 (expr -> expr * expr .)
    EXPONENT        shift and go to state 46

  ! EXPONENT        [ reduce using rule 30 (expr -> expr * expr .) ]
  ! +               [ shift and go to state 47 ]
  ! -               [ shift and go to state 49 ]
  ! *               [ shift and go to state 48 ]
  ! /               [ shift and go to state 51 ]
  ! %               [ shift and go to state 45 ]
  ! OR              [ shift and go to state 56 ]
  ! AND             [ shift and go to state 43 ]
  ! LT              [ shift and go to state 53 ]
  ! GT              [ shift and go to state 44 ]
  ! LE              [ shift and go to state 54 ]
  ! GE              [ shift and go to state 50 ]
  ! EQ              [ shift and go to state 55 ]
  ! NE              [ shift and go to state 52 ]


state 83

    (29) expr -> expr - expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (33) expr -> expr . EXPONENT expr
    (37) expr -> expr . % expr
    (38) expr -> expr . OR expr
    (39) expr -> expr . AND expr
    (41) expr -> expr . LT expr
    (42) expr -> expr . GT expr
    (43) expr -> expr . LE expr
    (44) expr -> expr . GE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NE expr

    +               reduce using rule 29 (expr -> expr - expr .)
    -               reduce using rule 29 (expr -> expr - expr .)
    OR              reduce using rule 29 (expr -> expr - expr .)
    AND             reduce using rule 29 (expr -> expr - expr .)
    LT              reduce using rule 29 (expr -> expr - expr .)
    GT              reduce using rule 29 (expr -> expr - expr .)
    LE              reduce using rule 29 (expr -> expr - expr .)
    GE              reduce using rule 29 (expr -> expr - expr .)
    EQ              reduce using rule 29 (expr -> expr - expr .)
    NE              reduce using rule 29 (expr -> expr - expr .)
    ID              reduce using rule 29 (expr -> expr - expr .)
    procedure       reduce using rule 29 (expr -> expr - expr .)
    print           reduce using rule 29 (expr -> expr - expr .)
    while           reduce using rule 29 (expr -> expr - expr .)
    for             reduce using rule 29 (expr -> expr - expr .)
    if              reduce using rule 29 (expr -> expr - expr .)
    {               reduce using rule 29 (expr -> expr - expr .)
    BLTIN           reduce using rule 29 (expr -> expr - expr .)
    NUMBER          reduce using rule 29 (expr -> expr - expr .)
    NOT             reduce using rule 29 (expr -> expr - expr .)
    INC             reduce using rule 29 (expr -> expr - expr .)
    DEC             reduce using rule 29 (expr -> expr - expr .)
    RETURN          reduce using rule 29 (expr -> expr - expr .)
    read            reduce using rule 29 (expr -> expr - expr .)
    (               reduce using rule 29 (expr -> expr - expr .)
    $end            reduce using rule 29 (expr -> expr - expr .)
    )               reduce using rule 29 (expr -> expr - expr .)
    ;               reduce using rule 29 (expr -> expr - expr .)
    }               reduce using rule 29 (expr -> expr - expr .)
    ,               reduce using rule 29 (expr -> expr - expr .)
    ELSE            reduce using rule 29 (expr -> expr - expr .)
    *               shift and go to state 48
    /               shift and go to state 51
    EXPONENT        shift and go to state 46
    %               shift and go to state 45

  ! *               [ reduce using rule 29 (expr -> expr - expr .) ]
  ! /               [ reduce using rule 29 (expr -> expr - expr .) ]
  ! EXPONENT        [ reduce using rule 29 (expr -> expr - expr .) ]
  ! %               [ reduce using rule 29 (expr -> expr - expr .) ]
  ! +               [ shift and go to state 47 ]
  ! -               [ shift and go to state 49 ]
  ! OR              [ shift and go to state 56 ]
  ! AND             [ shift and go to state 43 ]
  ! LT              [ shift and go to state 53 ]
  ! GT              [ shift and go to state 44 ]
  ! LE              [ shift and go to state 54 ]
  ! GE              [ shift and go to state 50 ]
  ! EQ              [ shift and go to state 55 ]
  ! NE              [ shift and go to state 52 ]


state 84

    (44) expr -> expr GE expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (33) expr -> expr . EXPONENT expr
    (37) expr -> expr . % expr
    (38) expr -> expr . OR expr
    (39) expr -> expr . AND expr
    (41) expr -> expr . LT expr
    (42) expr -> expr . GT expr
    (43) expr -> expr . LE expr
    (44) expr -> expr . GE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NE expr

    OR              reduce using rule 44 (expr -> expr GE expr .)
    AND             reduce using rule 44 (expr -> expr GE expr .)
    LT              reduce using rule 44 (expr -> expr GE expr .)
    GT              reduce using rule 44 (expr -> expr GE expr .)
    LE              reduce using rule 44 (expr -> expr GE expr .)
    GE              reduce using rule 44 (expr -> expr GE expr .)
    EQ              reduce using rule 44 (expr -> expr GE expr .)
    NE              reduce using rule 44 (expr -> expr GE expr .)
    ID              reduce using rule 44 (expr -> expr GE expr .)
    procedure       reduce using rule 44 (expr -> expr GE expr .)
    print           reduce using rule 44 (expr -> expr GE expr .)
    while           reduce using rule 44 (expr -> expr GE expr .)
    for             reduce using rule 44 (expr -> expr GE expr .)
    if              reduce using rule 44 (expr -> expr GE expr .)
    {               reduce using rule 44 (expr -> expr GE expr .)
    BLTIN           reduce using rule 44 (expr -> expr GE expr .)
    NUMBER          reduce using rule 44 (expr -> expr GE expr .)
    NOT             reduce using rule 44 (expr -> expr GE expr .)
    INC             reduce using rule 44 (expr -> expr GE expr .)
    DEC             reduce using rule 44 (expr -> expr GE expr .)
    RETURN          reduce using rule 44 (expr -> expr GE expr .)
    read            reduce using rule 44 (expr -> expr GE expr .)
    (               reduce using rule 44 (expr -> expr GE expr .)
    $end            reduce using rule 44 (expr -> expr GE expr .)
    )               reduce using rule 44 (expr -> expr GE expr .)
    ;               reduce using rule 44 (expr -> expr GE expr .)
    }               reduce using rule 44 (expr -> expr GE expr .)
    ,               reduce using rule 44 (expr -> expr GE expr .)
    ELSE            reduce using rule 44 (expr -> expr GE expr .)
    +               shift and go to state 47
    -               shift and go to state 49
    *               shift and go to state 48
    /               shift and go to state 51
    EXPONENT        shift and go to state 46
    %               shift and go to state 45

  ! +               [ reduce using rule 44 (expr -> expr GE expr .) ]
  ! -               [ reduce using rule 44 (expr -> expr GE expr .) ]
  ! *               [ reduce using rule 44 (expr -> expr GE expr .) ]
  ! /               [ reduce using rule 44 (expr -> expr GE expr .) ]
  ! EXPONENT        [ reduce using rule 44 (expr -> expr GE expr .) ]
  ! %               [ reduce using rule 44 (expr -> expr GE expr .) ]
  ! OR              [ shift and go to state 56 ]
  ! AND             [ shift and go to state 43 ]
  ! LT              [ shift and go to state 53 ]
  ! GT              [ shift and go to state 44 ]
  ! LE              [ shift and go to state 54 ]
  ! GE              [ shift and go to state 50 ]
  ! EQ              [ shift and go to state 55 ]
  ! NE              [ shift and go to state 52 ]


state 85

    (31) expr -> expr / expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (33) expr -> expr . EXPONENT expr
    (37) expr -> expr . % expr
    (38) expr -> expr . OR expr
    (39) expr -> expr . AND expr
    (41) expr -> expr . LT expr
    (42) expr -> expr . GT expr
    (43) expr -> expr . LE expr
    (44) expr -> expr . GE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NE expr

    +               reduce using rule 31 (expr -> expr / expr .)
    -               reduce using rule 31 (expr -> expr / expr .)
    *               reduce using rule 31 (expr -> expr / expr .)
    /               reduce using rule 31 (expr -> expr / expr .)
    %               reduce using rule 31 (expr -> expr / expr .)
    OR              reduce using rule 31 (expr -> expr / expr .)
    AND             reduce using rule 31 (expr -> expr / expr .)
    LT              reduce using rule 31 (expr -> expr / expr .)
    GT              reduce using rule 31 (expr -> expr / expr .)
    LE              reduce using rule 31 (expr -> expr / expr .)
    GE              reduce using rule 31 (expr -> expr / expr .)
    EQ              reduce using rule 31 (expr -> expr / expr .)
    NE              reduce using rule 31 (expr -> expr / expr .)
    ID              reduce using rule 31 (expr -> expr / expr .)
    procedure       reduce using rule 31 (expr -> expr / expr .)
    print           reduce using rule 31 (expr -> expr / expr .)
    while           reduce using rule 31 (expr -> expr / expr .)
    for             reduce using rule 31 (expr -> expr / expr .)
    if              reduce using rule 31 (expr -> expr / expr .)
    {               reduce using rule 31 (expr -> expr / expr .)
    BLTIN           reduce using rule 31 (expr -> expr / expr .)
    NUMBER          reduce using rule 31 (expr -> expr / expr .)
    NOT             reduce using rule 31 (expr -> expr / expr .)
    INC             reduce using rule 31 (expr -> expr / expr .)
    DEC             reduce using rule 31 (expr -> expr / expr .)
    RETURN          reduce using rule 31 (expr -> expr / expr .)
    read            reduce using rule 31 (expr -> expr / expr .)
    (               reduce using rule 31 (expr -> expr / expr .)
    $end            reduce using rule 31 (expr -> expr / expr .)
    )               reduce using rule 31 (expr -> expr / expr .)
    ;               reduce using rule 31 (expr -> expr / expr .)
    }               reduce using rule 31 (expr -> expr / expr .)
    ,               reduce using rule 31 (expr -> expr / expr .)
    ELSE            reduce using rule 31 (expr -> expr / expr .)
    EXPONENT        shift and go to state 46

  ! EXPONENT        [ reduce using rule 31 (expr -> expr / expr .) ]
  ! +               [ shift and go to state 47 ]
  ! -               [ shift and go to state 49 ]
  ! *               [ shift and go to state 48 ]
  ! /               [ shift and go to state 51 ]
  ! %               [ shift and go to state 45 ]
  ! OR              [ shift and go to state 56 ]
  ! AND             [ shift and go to state 43 ]
  ! LT              [ shift and go to state 53 ]
  ! GT              [ shift and go to state 44 ]
  ! LE              [ shift and go to state 54 ]
  ! GE              [ shift and go to state 50 ]
  ! EQ              [ shift and go to state 55 ]
  ! NE              [ shift and go to state 52 ]


state 86

    (46) expr -> expr NE expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (33) expr -> expr . EXPONENT expr
    (37) expr -> expr . % expr
    (38) expr -> expr . OR expr
    (39) expr -> expr . AND expr
    (41) expr -> expr . LT expr
    (42) expr -> expr . GT expr
    (43) expr -> expr . LE expr
    (44) expr -> expr . GE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NE expr

    OR              reduce using rule 46 (expr -> expr NE expr .)
    AND             reduce using rule 46 (expr -> expr NE expr .)
    LT              reduce using rule 46 (expr -> expr NE expr .)
    GT              reduce using rule 46 (expr -> expr NE expr .)
    LE              reduce using rule 46 (expr -> expr NE expr .)
    GE              reduce using rule 46 (expr -> expr NE expr .)
    EQ              reduce using rule 46 (expr -> expr NE expr .)
    NE              reduce using rule 46 (expr -> expr NE expr .)
    ID              reduce using rule 46 (expr -> expr NE expr .)
    procedure       reduce using rule 46 (expr -> expr NE expr .)
    print           reduce using rule 46 (expr -> expr NE expr .)
    while           reduce using rule 46 (expr -> expr NE expr .)
    for             reduce using rule 46 (expr -> expr NE expr .)
    if              reduce using rule 46 (expr -> expr NE expr .)
    {               reduce using rule 46 (expr -> expr NE expr .)
    BLTIN           reduce using rule 46 (expr -> expr NE expr .)
    NUMBER          reduce using rule 46 (expr -> expr NE expr .)
    NOT             reduce using rule 46 (expr -> expr NE expr .)
    INC             reduce using rule 46 (expr -> expr NE expr .)
    DEC             reduce using rule 46 (expr -> expr NE expr .)
    RETURN          reduce using rule 46 (expr -> expr NE expr .)
    read            reduce using rule 46 (expr -> expr NE expr .)
    (               reduce using rule 46 (expr -> expr NE expr .)
    $end            reduce using rule 46 (expr -> expr NE expr .)
    )               reduce using rule 46 (expr -> expr NE expr .)
    ;               reduce using rule 46 (expr -> expr NE expr .)
    }               reduce using rule 46 (expr -> expr NE expr .)
    ,               reduce using rule 46 (expr -> expr NE expr .)
    ELSE            reduce using rule 46 (expr -> expr NE expr .)
    +               shift and go to state 47
    -               shift and go to state 49
    *               shift and go to state 48
    /               shift and go to state 51
    EXPONENT        shift and go to state 46
    %               shift and go to state 45

  ! +               [ reduce using rule 46 (expr -> expr NE expr .) ]
  ! -               [ reduce using rule 46 (expr -> expr NE expr .) ]
  ! *               [ reduce using rule 46 (expr -> expr NE expr .) ]
  ! /               [ reduce using rule 46 (expr -> expr NE expr .) ]
  ! EXPONENT        [ reduce using rule 46 (expr -> expr NE expr .) ]
  ! %               [ reduce using rule 46 (expr -> expr NE expr .) ]
  ! OR              [ shift and go to state 56 ]
  ! AND             [ shift and go to state 43 ]
  ! LT              [ shift and go to state 53 ]
  ! GT              [ shift and go to state 44 ]
  ! LE              [ shift and go to state 54 ]
  ! GE              [ shift and go to state 50 ]
  ! EQ              [ shift and go to state 55 ]
  ! NE              [ shift and go to state 52 ]


state 87

    (41) expr -> expr LT expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (33) expr -> expr . EXPONENT expr
    (37) expr -> expr . % expr
    (38) expr -> expr . OR expr
    (39) expr -> expr . AND expr
    (41) expr -> expr . LT expr
    (42) expr -> expr . GT expr
    (43) expr -> expr . LE expr
    (44) expr -> expr . GE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NE expr

    OR              reduce using rule 41 (expr -> expr LT expr .)
    AND             reduce using rule 41 (expr -> expr LT expr .)
    LT              reduce using rule 41 (expr -> expr LT expr .)
    GT              reduce using rule 41 (expr -> expr LT expr .)
    LE              reduce using rule 41 (expr -> expr LT expr .)
    GE              reduce using rule 41 (expr -> expr LT expr .)
    EQ              reduce using rule 41 (expr -> expr LT expr .)
    NE              reduce using rule 41 (expr -> expr LT expr .)
    ID              reduce using rule 41 (expr -> expr LT expr .)
    procedure       reduce using rule 41 (expr -> expr LT expr .)
    print           reduce using rule 41 (expr -> expr LT expr .)
    while           reduce using rule 41 (expr -> expr LT expr .)
    for             reduce using rule 41 (expr -> expr LT expr .)
    if              reduce using rule 41 (expr -> expr LT expr .)
    {               reduce using rule 41 (expr -> expr LT expr .)
    BLTIN           reduce using rule 41 (expr -> expr LT expr .)
    NUMBER          reduce using rule 41 (expr -> expr LT expr .)
    NOT             reduce using rule 41 (expr -> expr LT expr .)
    INC             reduce using rule 41 (expr -> expr LT expr .)
    DEC             reduce using rule 41 (expr -> expr LT expr .)
    RETURN          reduce using rule 41 (expr -> expr LT expr .)
    read            reduce using rule 41 (expr -> expr LT expr .)
    (               reduce using rule 41 (expr -> expr LT expr .)
    $end            reduce using rule 41 (expr -> expr LT expr .)
    )               reduce using rule 41 (expr -> expr LT expr .)
    ;               reduce using rule 41 (expr -> expr LT expr .)
    }               reduce using rule 41 (expr -> expr LT expr .)
    ,               reduce using rule 41 (expr -> expr LT expr .)
    ELSE            reduce using rule 41 (expr -> expr LT expr .)
    +               shift and go to state 47
    -               shift and go to state 49
    *               shift and go to state 48
    /               shift and go to state 51
    EXPONENT        shift and go to state 46
    %               shift and go to state 45

  ! +               [ reduce using rule 41 (expr -> expr LT expr .) ]
  ! -               [ reduce using rule 41 (expr -> expr LT expr .) ]
  ! *               [ reduce using rule 41 (expr -> expr LT expr .) ]
  ! /               [ reduce using rule 41 (expr -> expr LT expr .) ]
  ! EXPONENT        [ reduce using rule 41 (expr -> expr LT expr .) ]
  ! %               [ reduce using rule 41 (expr -> expr LT expr .) ]
  ! OR              [ shift and go to state 56 ]
  ! AND             [ shift and go to state 43 ]
  ! LT              [ shift and go to state 53 ]
  ! GT              [ shift and go to state 44 ]
  ! LE              [ shift and go to state 54 ]
  ! GE              [ shift and go to state 50 ]
  ! EQ              [ shift and go to state 55 ]
  ! NE              [ shift and go to state 52 ]


state 88

    (43) expr -> expr LE expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (33) expr -> expr . EXPONENT expr
    (37) expr -> expr . % expr
    (38) expr -> expr . OR expr
    (39) expr -> expr . AND expr
    (41) expr -> expr . LT expr
    (42) expr -> expr . GT expr
    (43) expr -> expr . LE expr
    (44) expr -> expr . GE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NE expr

    OR              reduce using rule 43 (expr -> expr LE expr .)
    AND             reduce using rule 43 (expr -> expr LE expr .)
    LT              reduce using rule 43 (expr -> expr LE expr .)
    GT              reduce using rule 43 (expr -> expr LE expr .)
    LE              reduce using rule 43 (expr -> expr LE expr .)
    GE              reduce using rule 43 (expr -> expr LE expr .)
    EQ              reduce using rule 43 (expr -> expr LE expr .)
    NE              reduce using rule 43 (expr -> expr LE expr .)
    ID              reduce using rule 43 (expr -> expr LE expr .)
    procedure       reduce using rule 43 (expr -> expr LE expr .)
    print           reduce using rule 43 (expr -> expr LE expr .)
    while           reduce using rule 43 (expr -> expr LE expr .)
    for             reduce using rule 43 (expr -> expr LE expr .)
    if              reduce using rule 43 (expr -> expr LE expr .)
    {               reduce using rule 43 (expr -> expr LE expr .)
    BLTIN           reduce using rule 43 (expr -> expr LE expr .)
    NUMBER          reduce using rule 43 (expr -> expr LE expr .)
    NOT             reduce using rule 43 (expr -> expr LE expr .)
    INC             reduce using rule 43 (expr -> expr LE expr .)
    DEC             reduce using rule 43 (expr -> expr LE expr .)
    RETURN          reduce using rule 43 (expr -> expr LE expr .)
    read            reduce using rule 43 (expr -> expr LE expr .)
    (               reduce using rule 43 (expr -> expr LE expr .)
    $end            reduce using rule 43 (expr -> expr LE expr .)
    )               reduce using rule 43 (expr -> expr LE expr .)
    ;               reduce using rule 43 (expr -> expr LE expr .)
    }               reduce using rule 43 (expr -> expr LE expr .)
    ,               reduce using rule 43 (expr -> expr LE expr .)
    ELSE            reduce using rule 43 (expr -> expr LE expr .)
    +               shift and go to state 47
    -               shift and go to state 49
    *               shift and go to state 48
    /               shift and go to state 51
    EXPONENT        shift and go to state 46
    %               shift and go to state 45

  ! +               [ reduce using rule 43 (expr -> expr LE expr .) ]
  ! -               [ reduce using rule 43 (expr -> expr LE expr .) ]
  ! *               [ reduce using rule 43 (expr -> expr LE expr .) ]
  ! /               [ reduce using rule 43 (expr -> expr LE expr .) ]
  ! EXPONENT        [ reduce using rule 43 (expr -> expr LE expr .) ]
  ! %               [ reduce using rule 43 (expr -> expr LE expr .) ]
  ! OR              [ shift and go to state 56 ]
  ! AND             [ shift and go to state 43 ]
  ! LT              [ shift and go to state 53 ]
  ! GT              [ shift and go to state 44 ]
  ! LE              [ shift and go to state 54 ]
  ! GE              [ shift and go to state 50 ]
  ! EQ              [ shift and go to state 55 ]
  ! NE              [ shift and go to state 52 ]


state 89

    (45) expr -> expr EQ expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (33) expr -> expr . EXPONENT expr
    (37) expr -> expr . % expr
    (38) expr -> expr . OR expr
    (39) expr -> expr . AND expr
    (41) expr -> expr . LT expr
    (42) expr -> expr . GT expr
    (43) expr -> expr . LE expr
    (44) expr -> expr . GE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NE expr

    OR              reduce using rule 45 (expr -> expr EQ expr .)
    AND             reduce using rule 45 (expr -> expr EQ expr .)
    LT              reduce using rule 45 (expr -> expr EQ expr .)
    GT              reduce using rule 45 (expr -> expr EQ expr .)
    LE              reduce using rule 45 (expr -> expr EQ expr .)
    GE              reduce using rule 45 (expr -> expr EQ expr .)
    EQ              reduce using rule 45 (expr -> expr EQ expr .)
    NE              reduce using rule 45 (expr -> expr EQ expr .)
    ID              reduce using rule 45 (expr -> expr EQ expr .)
    procedure       reduce using rule 45 (expr -> expr EQ expr .)
    print           reduce using rule 45 (expr -> expr EQ expr .)
    while           reduce using rule 45 (expr -> expr EQ expr .)
    for             reduce using rule 45 (expr -> expr EQ expr .)
    if              reduce using rule 45 (expr -> expr EQ expr .)
    {               reduce using rule 45 (expr -> expr EQ expr .)
    BLTIN           reduce using rule 45 (expr -> expr EQ expr .)
    NUMBER          reduce using rule 45 (expr -> expr EQ expr .)
    NOT             reduce using rule 45 (expr -> expr EQ expr .)
    INC             reduce using rule 45 (expr -> expr EQ expr .)
    DEC             reduce using rule 45 (expr -> expr EQ expr .)
    RETURN          reduce using rule 45 (expr -> expr EQ expr .)
    read            reduce using rule 45 (expr -> expr EQ expr .)
    (               reduce using rule 45 (expr -> expr EQ expr .)
    $end            reduce using rule 45 (expr -> expr EQ expr .)
    )               reduce using rule 45 (expr -> expr EQ expr .)
    ;               reduce using rule 45 (expr -> expr EQ expr .)
    }               reduce using rule 45 (expr -> expr EQ expr .)
    ,               reduce using rule 45 (expr -> expr EQ expr .)
    ELSE            reduce using rule 45 (expr -> expr EQ expr .)
    +               shift and go to state 47
    -               shift and go to state 49
    *               shift and go to state 48
    /               shift and go to state 51
    EXPONENT        shift and go to state 46
    %               shift and go to state 45

  ! +               [ reduce using rule 45 (expr -> expr EQ expr .) ]
  ! -               [ reduce using rule 45 (expr -> expr EQ expr .) ]
  ! *               [ reduce using rule 45 (expr -> expr EQ expr .) ]
  ! /               [ reduce using rule 45 (expr -> expr EQ expr .) ]
  ! EXPONENT        [ reduce using rule 45 (expr -> expr EQ expr .) ]
  ! %               [ reduce using rule 45 (expr -> expr EQ expr .) ]
  ! OR              [ shift and go to state 56 ]
  ! AND             [ shift and go to state 43 ]
  ! LT              [ shift and go to state 53 ]
  ! GT              [ shift and go to state 44 ]
  ! LE              [ shift and go to state 54 ]
  ! GE              [ shift and go to state 50 ]
  ! EQ              [ shift and go to state 55 ]
  ! NE              [ shift and go to state 52 ]


state 90

    (38) expr -> expr OR expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (33) expr -> expr . EXPONENT expr
    (37) expr -> expr . % expr
    (38) expr -> expr . OR expr
    (39) expr -> expr . AND expr
    (41) expr -> expr . LT expr
    (42) expr -> expr . GT expr
    (43) expr -> expr . LE expr
    (44) expr -> expr . GE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NE expr

    OR              reduce using rule 38 (expr -> expr OR expr .)
    ID              reduce using rule 38 (expr -> expr OR expr .)
    procedure       reduce using rule 38 (expr -> expr OR expr .)
    print           reduce using rule 38 (expr -> expr OR expr .)
    while           reduce using rule 38 (expr -> expr OR expr .)
    for             reduce using rule 38 (expr -> expr OR expr .)
    if              reduce using rule 38 (expr -> expr OR expr .)
    {               reduce using rule 38 (expr -> expr OR expr .)
    BLTIN           reduce using rule 38 (expr -> expr OR expr .)
    NUMBER          reduce using rule 38 (expr -> expr OR expr .)
    NOT             reduce using rule 38 (expr -> expr OR expr .)
    INC             reduce using rule 38 (expr -> expr OR expr .)
    DEC             reduce using rule 38 (expr -> expr OR expr .)
    RETURN          reduce using rule 38 (expr -> expr OR expr .)
    read            reduce using rule 38 (expr -> expr OR expr .)
    (               reduce using rule 38 (expr -> expr OR expr .)
    $end            reduce using rule 38 (expr -> expr OR expr .)
    )               reduce using rule 38 (expr -> expr OR expr .)
    ;               reduce using rule 38 (expr -> expr OR expr .)
    }               reduce using rule 38 (expr -> expr OR expr .)
    ,               reduce using rule 38 (expr -> expr OR expr .)
    ELSE            reduce using rule 38 (expr -> expr OR expr .)
    +               shift and go to state 47
    -               shift and go to state 49
    *               shift and go to state 48
    /               shift and go to state 51
    EXPONENT        shift and go to state 46
    %               shift and go to state 45
    AND             shift and go to state 43
    LT              shift and go to state 53
    GT              shift and go to state 44
    LE              shift and go to state 54
    GE              shift and go to state 50
    EQ              shift and go to state 55
    NE              shift and go to state 52

  ! +               [ reduce using rule 38 (expr -> expr OR expr .) ]
  ! -               [ reduce using rule 38 (expr -> expr OR expr .) ]
  ! *               [ reduce using rule 38 (expr -> expr OR expr .) ]
  ! /               [ reduce using rule 38 (expr -> expr OR expr .) ]
  ! EXPONENT        [ reduce using rule 38 (expr -> expr OR expr .) ]
  ! %               [ reduce using rule 38 (expr -> expr OR expr .) ]
  ! AND             [ reduce using rule 38 (expr -> expr OR expr .) ]
  ! LT              [ reduce using rule 38 (expr -> expr OR expr .) ]
  ! GT              [ reduce using rule 38 (expr -> expr OR expr .) ]
  ! LE              [ reduce using rule 38 (expr -> expr OR expr .) ]
  ! GE              [ reduce using rule 38 (expr -> expr OR expr .) ]
  ! EQ              [ reduce using rule 38 (expr -> expr OR expr .) ]
  ! NE              [ reduce using rule 38 (expr -> expr OR expr .) ]
  ! OR              [ shift and go to state 56 ]


state 91

    (14) stmt -> while ( cond . ) stmt end

    )               shift and go to state 102


state 92

    (23) stmtlist -> stmtlist stmt .

    }               reduce using rule 23 (stmtlist -> stmtlist stmt .)
    procedure       reduce using rule 23 (stmtlist -> stmtlist stmt .)
    print           reduce using rule 23 (stmtlist -> stmtlist stmt .)
    while           reduce using rule 23 (stmtlist -> stmtlist stmt .)
    for             reduce using rule 23 (stmtlist -> stmtlist stmt .)
    if              reduce using rule 23 (stmtlist -> stmtlist stmt .)
    {               reduce using rule 23 (stmtlist -> stmtlist stmt .)
    ID              reduce using rule 23 (stmtlist -> stmtlist stmt .)
    BLTIN           reduce using rule 23 (stmtlist -> stmtlist stmt .)
    NUMBER          reduce using rule 23 (stmtlist -> stmtlist stmt .)
    NOT             reduce using rule 23 (stmtlist -> stmtlist stmt .)
    INC             reduce using rule 23 (stmtlist -> stmtlist stmt .)
    DEC             reduce using rule 23 (stmtlist -> stmtlist stmt .)
    RETURN          reduce using rule 23 (stmtlist -> stmtlist stmt .)
    read            reduce using rule 23 (stmtlist -> stmtlist stmt .)
    (               reduce using rule 23 (stmtlist -> stmtlist stmt .)


state 93

    (18) stmt -> { stmtlist } .

    ELSE            reduce using rule 18 (stmt -> { stmtlist } .)
    ID              reduce using rule 18 (stmt -> { stmtlist } .)
    procedure       reduce using rule 18 (stmt -> { stmtlist } .)
    print           reduce using rule 18 (stmt -> { stmtlist } .)
    while           reduce using rule 18 (stmt -> { stmtlist } .)
    for             reduce using rule 18 (stmt -> { stmtlist } .)
    if              reduce using rule 18 (stmt -> { stmtlist } .)
    {               reduce using rule 18 (stmt -> { stmtlist } .)
    BLTIN           reduce using rule 18 (stmt -> { stmtlist } .)
    NUMBER          reduce using rule 18 (stmt -> { stmtlist } .)
    NOT             reduce using rule 18 (stmt -> { stmtlist } .)
    INC             reduce using rule 18 (stmt -> { stmtlist } .)
    DEC             reduce using rule 18 (stmt -> { stmtlist } .)
    RETURN          reduce using rule 18 (stmt -> { stmtlist } .)
    read            reduce using rule 18 (stmt -> { stmtlist } .)
    (               reduce using rule 18 (stmt -> { stmtlist } .)
    $end            reduce using rule 18 (stmt -> { stmtlist } .)
    }               reduce using rule 18 (stmt -> { stmtlist } .)


state 94

    (12) stmt -> procedure begin ( . arglist )
    (58) arglist -> . empty
    (59) arglist -> . arglist , expr
    (60) arglist -> . expr
    (61) empty -> .
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    )               reduce using rule 61 (empty -> .)
    ,               reduce using rule 61 (empty -> .)
    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    read            shift and go to state 12
    (               shift and go to state 7

    expr                           shift and go to state 105
    term                           shift and go to state 16
    asgn                           shift and go to state 26
    factor                         shift and go to state 9
    arglist                        shift and go to state 103
    empty                          shift and go to state 104

state 95

    (16) stmt -> if ( cond ) . stmt end
    (17) stmt -> if ( cond ) . stmt end ELSE stmt end
    (10) stmt -> . expr
    (11) stmt -> . return ( expr )
    (12) stmt -> . procedure begin ( arglist )
    (13) stmt -> . print prlist
    (14) stmt -> . while ( cond ) stmt end
    (15) stmt -> . for ( cond ; cond ; cond ) stmt end
    (16) stmt -> . if ( cond ) stmt end
    (17) stmt -> . if ( cond ) stmt end ELSE stmt end
    (18) stmt -> . { stmtlist }
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (63) return -> . RETURN
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    procedure       shift and go to state 22
    print           shift and go to state 10
    while           shift and go to state 19
    for             shift and go to state 6
    if              shift and go to state 5
    {               shift and go to state 21
    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    RETURN          shift and go to state 3
    read            shift and go to state 12
    (               shift and go to state 7

    return                         shift and go to state 11
    expr                           shift and go to state 18
    term                           shift and go to state 16
    stmt                           shift and go to state 106
    asgn                           shift and go to state 26
    factor                         shift and go to state 9

state 96

    (15) stmt -> for ( cond ; . cond ; cond ) stmt end
    (19) cond -> . expr
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    read            shift and go to state 12
    (               shift and go to state 7

    term                           shift and go to state 16
    expr                           shift and go to state 64
    asgn                           shift and go to state 26
    cond                           shift and go to state 107
    factor                         shift and go to state 9

state 97

    (53) prlist -> prlist , STRING .

    ,               reduce using rule 53 (prlist -> prlist , STRING .)
    ID              reduce using rule 53 (prlist -> prlist , STRING .)
    procedure       reduce using rule 53 (prlist -> prlist , STRING .)
    print           reduce using rule 53 (prlist -> prlist , STRING .)
    while           reduce using rule 53 (prlist -> prlist , STRING .)
    for             reduce using rule 53 (prlist -> prlist , STRING .)
    if              reduce using rule 53 (prlist -> prlist , STRING .)
    {               reduce using rule 53 (prlist -> prlist , STRING .)
    BLTIN           reduce using rule 53 (prlist -> prlist , STRING .)
    NUMBER          reduce using rule 53 (prlist -> prlist , STRING .)
    NOT             reduce using rule 53 (prlist -> prlist , STRING .)
    INC             reduce using rule 53 (prlist -> prlist , STRING .)
    DEC             reduce using rule 53 (prlist -> prlist , STRING .)
    RETURN          reduce using rule 53 (prlist -> prlist , STRING .)
    read            reduce using rule 53 (prlist -> prlist , STRING .)
    (               reduce using rule 53 (prlist -> prlist , STRING .)
    $end            reduce using rule 53 (prlist -> prlist , STRING .)
    }               reduce using rule 53 (prlist -> prlist , STRING .)
    ELSE            reduce using rule 53 (prlist -> prlist , STRING .)


state 98

    (52) prlist -> prlist , expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (33) expr -> expr . EXPONENT expr
    (37) expr -> expr . % expr
    (38) expr -> expr . OR expr
    (39) expr -> expr . AND expr
    (41) expr -> expr . LT expr
    (42) expr -> expr . GT expr
    (43) expr -> expr . LE expr
    (44) expr -> expr . GE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NE expr

    ,               reduce using rule 52 (prlist -> prlist , expr .)
    ID              reduce using rule 52 (prlist -> prlist , expr .)
    procedure       reduce using rule 52 (prlist -> prlist , expr .)
    print           reduce using rule 52 (prlist -> prlist , expr .)
    while           reduce using rule 52 (prlist -> prlist , expr .)
    for             reduce using rule 52 (prlist -> prlist , expr .)
    if              reduce using rule 52 (prlist -> prlist , expr .)
    {               reduce using rule 52 (prlist -> prlist , expr .)
    BLTIN           reduce using rule 52 (prlist -> prlist , expr .)
    NUMBER          reduce using rule 52 (prlist -> prlist , expr .)
    NOT             reduce using rule 52 (prlist -> prlist , expr .)
    INC             reduce using rule 52 (prlist -> prlist , expr .)
    DEC             reduce using rule 52 (prlist -> prlist , expr .)
    RETURN          reduce using rule 52 (prlist -> prlist , expr .)
    read            reduce using rule 52 (prlist -> prlist , expr .)
    (               reduce using rule 52 (prlist -> prlist , expr .)
    $end            reduce using rule 52 (prlist -> prlist , expr .)
    }               reduce using rule 52 (prlist -> prlist , expr .)
    ELSE            reduce using rule 52 (prlist -> prlist , expr .)
    +               shift and go to state 47
    -               shift and go to state 49
    *               shift and go to state 48
    /               shift and go to state 51
    EXPONENT        shift and go to state 46
    %               shift and go to state 45
    OR              shift and go to state 56
    AND             shift and go to state 43
    LT              shift and go to state 53
    GT              shift and go to state 44
    LE              shift and go to state 54
    GE              shift and go to state 50
    EQ              shift and go to state 55
    NE              shift and go to state 52


state 99

    (11) stmt -> return ( expr ) .

    ELSE            reduce using rule 11 (stmt -> return ( expr ) .)
    ID              reduce using rule 11 (stmt -> return ( expr ) .)
    procedure       reduce using rule 11 (stmt -> return ( expr ) .)
    print           reduce using rule 11 (stmt -> return ( expr ) .)
    while           reduce using rule 11 (stmt -> return ( expr ) .)
    for             reduce using rule 11 (stmt -> return ( expr ) .)
    if              reduce using rule 11 (stmt -> return ( expr ) .)
    {               reduce using rule 11 (stmt -> return ( expr ) .)
    BLTIN           reduce using rule 11 (stmt -> return ( expr ) .)
    NUMBER          reduce using rule 11 (stmt -> return ( expr ) .)
    NOT             reduce using rule 11 (stmt -> return ( expr ) .)
    INC             reduce using rule 11 (stmt -> return ( expr ) .)
    DEC             reduce using rule 11 (stmt -> return ( expr ) .)
    RETURN          reduce using rule 11 (stmt -> return ( expr ) .)
    read            reduce using rule 11 (stmt -> return ( expr ) .)
    (               reduce using rule 11 (stmt -> return ( expr ) .)
    $end            reduce using rule 11 (stmt -> return ( expr ) .)
    }               reduce using rule 11 (stmt -> return ( expr ) .)


state 100

    (25) term -> read ( ID ) .

    +               reduce using rule 25 (term -> read ( ID ) .)
    -               reduce using rule 25 (term -> read ( ID ) .)
    *               reduce using rule 25 (term -> read ( ID ) .)
    /               reduce using rule 25 (term -> read ( ID ) .)
    EXPONENT        reduce using rule 25 (term -> read ( ID ) .)
    %               reduce using rule 25 (term -> read ( ID ) .)
    OR              reduce using rule 25 (term -> read ( ID ) .)
    AND             reduce using rule 25 (term -> read ( ID ) .)
    LT              reduce using rule 25 (term -> read ( ID ) .)
    GT              reduce using rule 25 (term -> read ( ID ) .)
    LE              reduce using rule 25 (term -> read ( ID ) .)
    GE              reduce using rule 25 (term -> read ( ID ) .)
    EQ              reduce using rule 25 (term -> read ( ID ) .)
    NE              reduce using rule 25 (term -> read ( ID ) .)
    ID              reduce using rule 25 (term -> read ( ID ) .)
    procedure       reduce using rule 25 (term -> read ( ID ) .)
    print           reduce using rule 25 (term -> read ( ID ) .)
    while           reduce using rule 25 (term -> read ( ID ) .)
    for             reduce using rule 25 (term -> read ( ID ) .)
    if              reduce using rule 25 (term -> read ( ID ) .)
    {               reduce using rule 25 (term -> read ( ID ) .)
    BLTIN           reduce using rule 25 (term -> read ( ID ) .)
    NUMBER          reduce using rule 25 (term -> read ( ID ) .)
    NOT             reduce using rule 25 (term -> read ( ID ) .)
    INC             reduce using rule 25 (term -> read ( ID ) .)
    DEC             reduce using rule 25 (term -> read ( ID ) .)
    RETURN          reduce using rule 25 (term -> read ( ID ) .)
    read            reduce using rule 25 (term -> read ( ID ) .)
    (               reduce using rule 25 (term -> read ( ID ) .)
    $end            reduce using rule 25 (term -> read ( ID ) .)
    )               reduce using rule 25 (term -> read ( ID ) .)
    ;               reduce using rule 25 (term -> read ( ID ) .)
    }               reduce using rule 25 (term -> read ( ID ) .)
    ,               reduce using rule 25 (term -> read ( ID ) .)
    ELSE            reduce using rule 25 (term -> read ( ID ) .)


state 101

    (26) expr -> BLTIN ( expr ) .

    +               reduce using rule 26 (expr -> BLTIN ( expr ) .)
    -               reduce using rule 26 (expr -> BLTIN ( expr ) .)
    *               reduce using rule 26 (expr -> BLTIN ( expr ) .)
    /               reduce using rule 26 (expr -> BLTIN ( expr ) .)
    EXPONENT        reduce using rule 26 (expr -> BLTIN ( expr ) .)
    %               reduce using rule 26 (expr -> BLTIN ( expr ) .)
    OR              reduce using rule 26 (expr -> BLTIN ( expr ) .)
    AND             reduce using rule 26 (expr -> BLTIN ( expr ) .)
    LT              reduce using rule 26 (expr -> BLTIN ( expr ) .)
    GT              reduce using rule 26 (expr -> BLTIN ( expr ) .)
    LE              reduce using rule 26 (expr -> BLTIN ( expr ) .)
    GE              reduce using rule 26 (expr -> BLTIN ( expr ) .)
    EQ              reduce using rule 26 (expr -> BLTIN ( expr ) .)
    NE              reduce using rule 26 (expr -> BLTIN ( expr ) .)
    ID              reduce using rule 26 (expr -> BLTIN ( expr ) .)
    procedure       reduce using rule 26 (expr -> BLTIN ( expr ) .)
    print           reduce using rule 26 (expr -> BLTIN ( expr ) .)
    while           reduce using rule 26 (expr -> BLTIN ( expr ) .)
    for             reduce using rule 26 (expr -> BLTIN ( expr ) .)
    if              reduce using rule 26 (expr -> BLTIN ( expr ) .)
    {               reduce using rule 26 (expr -> BLTIN ( expr ) .)
    BLTIN           reduce using rule 26 (expr -> BLTIN ( expr ) .)
    NUMBER          reduce using rule 26 (expr -> BLTIN ( expr ) .)
    NOT             reduce using rule 26 (expr -> BLTIN ( expr ) .)
    INC             reduce using rule 26 (expr -> BLTIN ( expr ) .)
    DEC             reduce using rule 26 (expr -> BLTIN ( expr ) .)
    RETURN          reduce using rule 26 (expr -> BLTIN ( expr ) .)
    read            reduce using rule 26 (expr -> BLTIN ( expr ) .)
    (               reduce using rule 26 (expr -> BLTIN ( expr ) .)
    $end            reduce using rule 26 (expr -> BLTIN ( expr ) .)
    )               reduce using rule 26 (expr -> BLTIN ( expr ) .)
    ;               reduce using rule 26 (expr -> BLTIN ( expr ) .)
    }               reduce using rule 26 (expr -> BLTIN ( expr ) .)
    ,               reduce using rule 26 (expr -> BLTIN ( expr ) .)
    ELSE            reduce using rule 26 (expr -> BLTIN ( expr ) .)


state 102

    (14) stmt -> while ( cond ) . stmt end
    (10) stmt -> . expr
    (11) stmt -> . return ( expr )
    (12) stmt -> . procedure begin ( arglist )
    (13) stmt -> . print prlist
    (14) stmt -> . while ( cond ) stmt end
    (15) stmt -> . for ( cond ; cond ; cond ) stmt end
    (16) stmt -> . if ( cond ) stmt end
    (17) stmt -> . if ( cond ) stmt end ELSE stmt end
    (18) stmt -> . { stmtlist }
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (63) return -> . RETURN
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    procedure       shift and go to state 22
    print           shift and go to state 10
    while           shift and go to state 19
    for             shift and go to state 6
    if              shift and go to state 5
    {               shift and go to state 21
    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    RETURN          shift and go to state 3
    read            shift and go to state 12
    (               shift and go to state 7

    return                         shift and go to state 11
    expr                           shift and go to state 18
    term                           shift and go to state 16
    stmt                           shift and go to state 108
    asgn                           shift and go to state 26
    factor                         shift and go to state 9

state 103

    (12) stmt -> procedure begin ( arglist . )
    (59) arglist -> arglist . , expr

    )               shift and go to state 109
    ,               shift and go to state 110


state 104

    (58) arglist -> empty .

    )               reduce using rule 58 (arglist -> empty .)
    ,               reduce using rule 58 (arglist -> empty .)


state 105

    (60) arglist -> expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (33) expr -> expr . EXPONENT expr
    (37) expr -> expr . % expr
    (38) expr -> expr . OR expr
    (39) expr -> expr . AND expr
    (41) expr -> expr . LT expr
    (42) expr -> expr . GT expr
    (43) expr -> expr . LE expr
    (44) expr -> expr . GE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NE expr

    )               reduce using rule 60 (arglist -> expr .)
    ,               reduce using rule 60 (arglist -> expr .)
    +               shift and go to state 47
    -               shift and go to state 49
    *               shift and go to state 48
    /               shift and go to state 51
    EXPONENT        shift and go to state 46
    %               shift and go to state 45
    OR              shift and go to state 56
    AND             shift and go to state 43
    LT              shift and go to state 53
    GT              shift and go to state 44
    LE              shift and go to state 54
    GE              shift and go to state 50
    EQ              shift and go to state 55
    NE              shift and go to state 52


state 106

    (16) stmt -> if ( cond ) stmt . end
    (17) stmt -> if ( cond ) stmt . end ELSE stmt end
    (21) end -> .

    ELSE            reduce using rule 21 (end -> .)
    ID              reduce using rule 21 (end -> .)
    procedure       reduce using rule 21 (end -> .)
    print           reduce using rule 21 (end -> .)
    while           reduce using rule 21 (end -> .)
    for             reduce using rule 21 (end -> .)
    if              reduce using rule 21 (end -> .)
    {               reduce using rule 21 (end -> .)
    BLTIN           reduce using rule 21 (end -> .)
    NUMBER          reduce using rule 21 (end -> .)
    NOT             reduce using rule 21 (end -> .)
    INC             reduce using rule 21 (end -> .)
    DEC             reduce using rule 21 (end -> .)
    RETURN          reduce using rule 21 (end -> .)
    read            reduce using rule 21 (end -> .)
    (               reduce using rule 21 (end -> .)
    $end            reduce using rule 21 (end -> .)
    }               reduce using rule 21 (end -> .)

    end                            shift and go to state 111

state 107

    (15) stmt -> for ( cond ; cond . ; cond ) stmt end

    ;               shift and go to state 112


state 108

    (14) stmt -> while ( cond ) stmt . end
    (21) end -> .

    ID              reduce using rule 21 (end -> .)
    procedure       reduce using rule 21 (end -> .)
    print           reduce using rule 21 (end -> .)
    while           reduce using rule 21 (end -> .)
    for             reduce using rule 21 (end -> .)
    if              reduce using rule 21 (end -> .)
    {               reduce using rule 21 (end -> .)
    BLTIN           reduce using rule 21 (end -> .)
    NUMBER          reduce using rule 21 (end -> .)
    NOT             reduce using rule 21 (end -> .)
    INC             reduce using rule 21 (end -> .)
    DEC             reduce using rule 21 (end -> .)
    RETURN          reduce using rule 21 (end -> .)
    read            reduce using rule 21 (end -> .)
    (               reduce using rule 21 (end -> .)
    $end            reduce using rule 21 (end -> .)
    }               reduce using rule 21 (end -> .)
    ELSE            reduce using rule 21 (end -> .)

    end                            shift and go to state 113

state 109

    (12) stmt -> procedure begin ( arglist ) .

    ELSE            reduce using rule 12 (stmt -> procedure begin ( arglist ) .)
    ID              reduce using rule 12 (stmt -> procedure begin ( arglist ) .)
    procedure       reduce using rule 12 (stmt -> procedure begin ( arglist ) .)
    print           reduce using rule 12 (stmt -> procedure begin ( arglist ) .)
    while           reduce using rule 12 (stmt -> procedure begin ( arglist ) .)
    for             reduce using rule 12 (stmt -> procedure begin ( arglist ) .)
    if              reduce using rule 12 (stmt -> procedure begin ( arglist ) .)
    {               reduce using rule 12 (stmt -> procedure begin ( arglist ) .)
    BLTIN           reduce using rule 12 (stmt -> procedure begin ( arglist ) .)
    NUMBER          reduce using rule 12 (stmt -> procedure begin ( arglist ) .)
    NOT             reduce using rule 12 (stmt -> procedure begin ( arglist ) .)
    INC             reduce using rule 12 (stmt -> procedure begin ( arglist ) .)
    DEC             reduce using rule 12 (stmt -> procedure begin ( arglist ) .)
    RETURN          reduce using rule 12 (stmt -> procedure begin ( arglist ) .)
    read            reduce using rule 12 (stmt -> procedure begin ( arglist ) .)
    (               reduce using rule 12 (stmt -> procedure begin ( arglist ) .)
    $end            reduce using rule 12 (stmt -> procedure begin ( arglist ) .)
    }               reduce using rule 12 (stmt -> procedure begin ( arglist ) .)


state 110

    (59) arglist -> arglist , . expr
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    read            shift and go to state 12
    (               shift and go to state 7

    expr                           shift and go to state 114
    term                           shift and go to state 16
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 111

    (16) stmt -> if ( cond ) stmt end .
    (17) stmt -> if ( cond ) stmt end . ELSE stmt end

    ID              reduce using rule 16 (stmt -> if ( cond ) stmt end .)
    procedure       reduce using rule 16 (stmt -> if ( cond ) stmt end .)
    print           reduce using rule 16 (stmt -> if ( cond ) stmt end .)
    while           reduce using rule 16 (stmt -> if ( cond ) stmt end .)
    for             reduce using rule 16 (stmt -> if ( cond ) stmt end .)
    if              reduce using rule 16 (stmt -> if ( cond ) stmt end .)
    {               reduce using rule 16 (stmt -> if ( cond ) stmt end .)
    BLTIN           reduce using rule 16 (stmt -> if ( cond ) stmt end .)
    NUMBER          reduce using rule 16 (stmt -> if ( cond ) stmt end .)
    NOT             reduce using rule 16 (stmt -> if ( cond ) stmt end .)
    INC             reduce using rule 16 (stmt -> if ( cond ) stmt end .)
    DEC             reduce using rule 16 (stmt -> if ( cond ) stmt end .)
    RETURN          reduce using rule 16 (stmt -> if ( cond ) stmt end .)
    read            reduce using rule 16 (stmt -> if ( cond ) stmt end .)
    (               reduce using rule 16 (stmt -> if ( cond ) stmt end .)
    $end            reduce using rule 16 (stmt -> if ( cond ) stmt end .)
    }               reduce using rule 16 (stmt -> if ( cond ) stmt end .)
    ELSE            shift and go to state 115

  ! ELSE            [ reduce using rule 16 (stmt -> if ( cond ) stmt end .) ]


state 112

    (15) stmt -> for ( cond ; cond ; . cond ) stmt end
    (19) cond -> . expr
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    read            shift and go to state 12
    (               shift and go to state 7

    term                           shift and go to state 16
    expr                           shift and go to state 64
    asgn                           shift and go to state 26
    cond                           shift and go to state 116
    factor                         shift and go to state 9

state 113

    (14) stmt -> while ( cond ) stmt end .

    ELSE            reduce using rule 14 (stmt -> while ( cond ) stmt end .)
    ID              reduce using rule 14 (stmt -> while ( cond ) stmt end .)
    procedure       reduce using rule 14 (stmt -> while ( cond ) stmt end .)
    print           reduce using rule 14 (stmt -> while ( cond ) stmt end .)
    while           reduce using rule 14 (stmt -> while ( cond ) stmt end .)
    for             reduce using rule 14 (stmt -> while ( cond ) stmt end .)
    if              reduce using rule 14 (stmt -> while ( cond ) stmt end .)
    {               reduce using rule 14 (stmt -> while ( cond ) stmt end .)
    BLTIN           reduce using rule 14 (stmt -> while ( cond ) stmt end .)
    NUMBER          reduce using rule 14 (stmt -> while ( cond ) stmt end .)
    NOT             reduce using rule 14 (stmt -> while ( cond ) stmt end .)
    INC             reduce using rule 14 (stmt -> while ( cond ) stmt end .)
    DEC             reduce using rule 14 (stmt -> while ( cond ) stmt end .)
    RETURN          reduce using rule 14 (stmt -> while ( cond ) stmt end .)
    read            reduce using rule 14 (stmt -> while ( cond ) stmt end .)
    (               reduce using rule 14 (stmt -> while ( cond ) stmt end .)
    $end            reduce using rule 14 (stmt -> while ( cond ) stmt end .)
    }               reduce using rule 14 (stmt -> while ( cond ) stmt end .)


state 114

    (59) arglist -> arglist , expr .
    (28) expr -> expr . + expr
    (29) expr -> expr . - expr
    (30) expr -> expr . * expr
    (31) expr -> expr . / expr
    (33) expr -> expr . EXPONENT expr
    (37) expr -> expr . % expr
    (38) expr -> expr . OR expr
    (39) expr -> expr . AND expr
    (41) expr -> expr . LT expr
    (42) expr -> expr . GT expr
    (43) expr -> expr . LE expr
    (44) expr -> expr . GE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NE expr

    )               reduce using rule 59 (arglist -> arglist , expr .)
    ,               reduce using rule 59 (arglist -> arglist , expr .)
    +               shift and go to state 47
    -               shift and go to state 49
    *               shift and go to state 48
    /               shift and go to state 51
    EXPONENT        shift and go to state 46
    %               shift and go to state 45
    OR              shift and go to state 56
    AND             shift and go to state 43
    LT              shift and go to state 53
    GT              shift and go to state 44
    LE              shift and go to state 54
    GE              shift and go to state 50
    EQ              shift and go to state 55
    NE              shift and go to state 52


state 115

    (17) stmt -> if ( cond ) stmt end ELSE . stmt end
    (10) stmt -> . expr
    (11) stmt -> . return ( expr )
    (12) stmt -> . procedure begin ( arglist )
    (13) stmt -> . print prlist
    (14) stmt -> . while ( cond ) stmt end
    (15) stmt -> . for ( cond ; cond ; cond ) stmt end
    (16) stmt -> . if ( cond ) stmt end
    (17) stmt -> . if ( cond ) stmt end ELSE stmt end
    (18) stmt -> . { stmtlist }
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (63) return -> . RETURN
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    procedure       shift and go to state 22
    print           shift and go to state 10
    while           shift and go to state 19
    for             shift and go to state 6
    if              shift and go to state 5
    {               shift and go to state 21
    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    RETURN          shift and go to state 3
    read            shift and go to state 12
    (               shift and go to state 7

    return                         shift and go to state 11
    expr                           shift and go to state 18
    term                           shift and go to state 16
    stmt                           shift and go to state 117
    asgn                           shift and go to state 26
    factor                         shift and go to state 9

state 116

    (15) stmt -> for ( cond ; cond ; cond . ) stmt end

    )               shift and go to state 118


state 117

    (17) stmt -> if ( cond ) stmt end ELSE stmt . end
    (21) end -> .

    ID              reduce using rule 21 (end -> .)
    procedure       reduce using rule 21 (end -> .)
    print           reduce using rule 21 (end -> .)
    while           reduce using rule 21 (end -> .)
    for             reduce using rule 21 (end -> .)
    if              reduce using rule 21 (end -> .)
    {               reduce using rule 21 (end -> .)
    BLTIN           reduce using rule 21 (end -> .)
    NUMBER          reduce using rule 21 (end -> .)
    NOT             reduce using rule 21 (end -> .)
    INC             reduce using rule 21 (end -> .)
    DEC             reduce using rule 21 (end -> .)
    RETURN          reduce using rule 21 (end -> .)
    read            reduce using rule 21 (end -> .)
    (               reduce using rule 21 (end -> .)
    $end            reduce using rule 21 (end -> .)
    }               reduce using rule 21 (end -> .)
    ELSE            reduce using rule 21 (end -> .)

    end                            shift and go to state 119

state 118

    (15) stmt -> for ( cond ; cond ; cond ) . stmt end
    (10) stmt -> . expr
    (11) stmt -> . return ( expr )
    (12) stmt -> . procedure begin ( arglist )
    (13) stmt -> . print prlist
    (14) stmt -> . while ( cond ) stmt end
    (15) stmt -> . for ( cond ; cond ; cond ) stmt end
    (16) stmt -> . if ( cond ) stmt end
    (17) stmt -> . if ( cond ) stmt end ELSE stmt end
    (18) stmt -> . { stmtlist }
    (24) expr -> . ID
    (26) expr -> . BLTIN ( expr )
    (27) expr -> . asgn
    (28) expr -> . expr + expr
    (29) expr -> . expr - expr
    (30) expr -> . expr * expr
    (31) expr -> . expr / expr
    (32) expr -> . NUMBER
    (33) expr -> . expr EXPONENT expr
    (34) expr -> . term
    (37) expr -> . expr % expr
    (38) expr -> . expr OR expr
    (39) expr -> . expr AND expr
    (40) expr -> . NOT expr
    (41) expr -> . expr LT expr
    (42) expr -> . expr GT expr
    (43) expr -> . expr LE expr
    (44) expr -> . expr GE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NE expr
    (47) expr -> . INC ID
    (48) expr -> . DEC ID
    (49) expr -> . ID DEC
    (50) expr -> . ID INC
    (63) return -> . RETURN
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (25) term -> . read ( ID )
    (35) term -> . factor
    (36) factor -> . ( expr )

    procedure       shift and go to state 22
    print           shift and go to state 10
    while           shift and go to state 19
    for             shift and go to state 6
    if              shift and go to state 5
    {               shift and go to state 21
    ID              shift and go to state 27
    BLTIN           shift and go to state 14
    NUMBER          shift and go to state 4
    NOT             shift and go to state 20
    INC             shift and go to state 23
    DEC             shift and go to state 17
    RETURN          shift and go to state 3
    read            shift and go to state 12
    (               shift and go to state 7

    return                         shift and go to state 11
    expr                           shift and go to state 18
    term                           shift and go to state 16
    stmt                           shift and go to state 120
    asgn                           shift and go to state 26
    factor                         shift and go to state 9

state 119

    (17) stmt -> if ( cond ) stmt end ELSE stmt end .

    ELSE            reduce using rule 17 (stmt -> if ( cond ) stmt end ELSE stmt end .)
    ID              reduce using rule 17 (stmt -> if ( cond ) stmt end ELSE stmt end .)
    procedure       reduce using rule 17 (stmt -> if ( cond ) stmt end ELSE stmt end .)
    print           reduce using rule 17 (stmt -> if ( cond ) stmt end ELSE stmt end .)
    while           reduce using rule 17 (stmt -> if ( cond ) stmt end ELSE stmt end .)
    for             reduce using rule 17 (stmt -> if ( cond ) stmt end ELSE stmt end .)
    if              reduce using rule 17 (stmt -> if ( cond ) stmt end ELSE stmt end .)
    {               reduce using rule 17 (stmt -> if ( cond ) stmt end ELSE stmt end .)
    BLTIN           reduce using rule 17 (stmt -> if ( cond ) stmt end ELSE stmt end .)
    NUMBER          reduce using rule 17 (stmt -> if ( cond ) stmt end ELSE stmt end .)
    NOT             reduce using rule 17 (stmt -> if ( cond ) stmt end ELSE stmt end .)
    INC             reduce using rule 17 (stmt -> if ( cond ) stmt end ELSE stmt end .)
    DEC             reduce using rule 17 (stmt -> if ( cond ) stmt end ELSE stmt end .)
    RETURN          reduce using rule 17 (stmt -> if ( cond ) stmt end ELSE stmt end .)
    read            reduce using rule 17 (stmt -> if ( cond ) stmt end ELSE stmt end .)
    (               reduce using rule 17 (stmt -> if ( cond ) stmt end ELSE stmt end .)
    $end            reduce using rule 17 (stmt -> if ( cond ) stmt end ELSE stmt end .)
    }               reduce using rule 17 (stmt -> if ( cond ) stmt end ELSE stmt end .)


state 120

    (15) stmt -> for ( cond ; cond ; cond ) stmt . end
    (21) end -> .

    ID              reduce using rule 21 (end -> .)
    procedure       reduce using rule 21 (end -> .)
    print           reduce using rule 21 (end -> .)
    while           reduce using rule 21 (end -> .)
    for             reduce using rule 21 (end -> .)
    if              reduce using rule 21 (end -> .)
    {               reduce using rule 21 (end -> .)
    BLTIN           reduce using rule 21 (end -> .)
    NUMBER          reduce using rule 21 (end -> .)
    NOT             reduce using rule 21 (end -> .)
    INC             reduce using rule 21 (end -> .)
    DEC             reduce using rule 21 (end -> .)
    RETURN          reduce using rule 21 (end -> .)
    read            reduce using rule 21 (end -> .)
    (               reduce using rule 21 (end -> .)
    $end            reduce using rule 21 (end -> .)
    }               reduce using rule 21 (end -> .)
    ELSE            reduce using rule 21 (end -> .)

    end                            shift and go to state 121

state 121

    (15) stmt -> for ( cond ; cond ; cond ) stmt end .

    ELSE            reduce using rule 15 (stmt -> for ( cond ; cond ; cond ) stmt end .)
    ID              reduce using rule 15 (stmt -> for ( cond ; cond ; cond ) stmt end .)
    procedure       reduce using rule 15 (stmt -> for ( cond ; cond ; cond ) stmt end .)
    print           reduce using rule 15 (stmt -> for ( cond ; cond ; cond ) stmt end .)
    while           reduce using rule 15 (stmt -> for ( cond ; cond ; cond ) stmt end .)
    for             reduce using rule 15 (stmt -> for ( cond ; cond ; cond ) stmt end .)
    if              reduce using rule 15 (stmt -> for ( cond ; cond ; cond ) stmt end .)
    {               reduce using rule 15 (stmt -> for ( cond ; cond ; cond ) stmt end .)
    BLTIN           reduce using rule 15 (stmt -> for ( cond ; cond ; cond ) stmt end .)
    NUMBER          reduce using rule 15 (stmt -> for ( cond ; cond ; cond ) stmt end .)
    NOT             reduce using rule 15 (stmt -> for ( cond ; cond ; cond ) stmt end .)
    INC             reduce using rule 15 (stmt -> for ( cond ; cond ; cond ) stmt end .)
    DEC             reduce using rule 15 (stmt -> for ( cond ; cond ; cond ) stmt end .)
    RETURN          reduce using rule 15 (stmt -> for ( cond ; cond ; cond ) stmt end .)
    read            reduce using rule 15 (stmt -> for ( cond ; cond ; cond ) stmt end .)
    (               reduce using rule 15 (stmt -> for ( cond ; cond ; cond ) stmt end .)
    $end            reduce using rule 15 (stmt -> for ( cond ; cond ; cond ) stmt end .)
    }               reduce using rule 15 (stmt -> for ( cond ; cond ; cond ) stmt end .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for DEC in state 15 resolved as shift
WARNING: shift/reduce conflict for INC in state 15 resolved as shift
WARNING: shift/reduce conflict for DEC in state 27 resolved as shift
WARNING: shift/reduce conflict for INC in state 27 resolved as shift
WARNING: reduce/reduce conflict in state 8 resolved using rule (list -> list asgn)
WARNING: rejected rule (expr -> asgn) in state 8
