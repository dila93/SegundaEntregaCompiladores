Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> list
Rule 1     list -> empty
Rule 2     list -> list asgn
Rule 3     list -> list stmt
Rule 4     asgn -> ID = expr
Rule 5     asgn -> ID ADDEQ expr
Rule 6     asgn -> ID SUBEQ expr
Rule 7     asgn -> ID MULEQ expr
Rule 8     asgn -> ID DIVEQ expr
Rule 9     asgn -> ID MODEQ expr
Rule 10    stmt -> expr
Rule 11    stmt -> return LPAREN expr RPAREN
Rule 12    stmt -> procedure begin LPAREN arglist RPAREN
Rule 13    stmt -> print prlist
Rule 14    stmt -> while LPAREN cond RPAREN stmt end
Rule 15    stmt -> for LPAREN cond ; cond ; cond RPAREN stmt end
Rule 16    stmt -> if LPAREN cond RPAREN stmt end
Rule 17    stmt -> if LPAREN cond RPAREN stmt end ELSE stmt end
Rule 18    stmt -> LKEY stmtlist RKEY
Rule 19    cond -> expr
Rule 20    begin -> <empty>
Rule 21    end -> <empty>
Rule 22    else -> ELSE
Rule 23    return -> RETURN
Rule 24    stmtlist -> empty
Rule 25    stmtlist -> stmtlist stmt
Rule 26    expr -> ID
Rule 27    term -> read ( ID )
Rule 28    expr -> BLTIN ( expr )
Rule 29    expr -> asgn
Rule 30    expr -> expr + expr
Rule 31    expr -> expr - expr
Rule 32    expr -> expr * expr
Rule 33    expr -> expr / expr
Rule 34    expr -> NUMBER
Rule 35    expr -> expr EXPONENT expr
Rule 36    expr -> term
Rule 37    term -> factor
Rule 38    factor -> ( expr )
Rule 39    expr -> expr % expr
Rule 40    expr -> expr OR expr
Rule 41    expr -> expr AND expr
Rule 42    expr -> NOT expr
Rule 43    expr -> expr LT expr
Rule 44    expr -> expr GT expr
Rule 45    expr -> expr LE expr
Rule 46    expr -> expr GE expr
Rule 47    expr -> expr EQ expr
Rule 48    expr -> expr NE expr
Rule 49    expr -> INC ID
Rule 50    expr -> DEC ID
Rule 51    expr -> ID DEC
Rule 52    expr -> ID INC
Rule 53    prlist -> STRING
Rule 54    prlist -> prlist , expr
Rule 55    prlist -> prlist , STRING
Rule 56    defn -> func procname ( arglist ) stmt
Rule 57    defn -> proc procname ( arglist ) stmt
Rule 58    procname -> function
Rule 59    procname -> procedure
Rule 60    arglist -> empty
Rule 61    arglist -> arglist , expr
Rule 62    arglist -> expr
Rule 63    empty -> <empty>

Terminals, with rules where they appear

%                    : 39
(                    : 27 28 38 56 57
)                    : 27 28 38 56 57
*                    : 32
+                    : 30
,                    : 54 55 61
-                    : 31
/                    : 33
;                    : 15 15
=                    : 4
ADDEQ                : 5
AND                  : 41
BLTIN                : 28
DEC                  : 50 51
DIVEQ                : 8
ELSE                 : 17 22
EQ                   : 47
EXPONENT             : 35
GE                   : 46
GT                   : 44
ID                   : 4 5 6 7 8 9 26 27 49 50 51 52
INC                  : 49 52
LE                   : 45
LKEY                 : 18
LPAREN               : 11 12 14 15 16 17
LT                   : 43
MODEQ                : 9
MULEQ                : 7
NE                   : 48
NOT                  : 42
NUMBER               : 34
OR                   : 40
RETURN               : 23
RKEY                 : 18
RPAREN               : 11 12 14 15 16 17
STRING               : 53 55
SUBEQ                : 6
error                : 
for                  : 15
func                 : 56
function             : 58
if                   : 16 17
print                : 13
proc                 : 57
procedure            : 12 59
read                 : 27
while                : 14

Nonterminals, with rules where they appear

arglist              : 12 56 57 61
asgn                 : 2 29
begin                : 12
cond                 : 14 15 15 15 16 17
defn                 : 
else                 : 
empty                : 1 24 60
end                  : 14 15 16 17 17
expr                 : 4 5 6 7 8 9 10 11 19 28 30 30 31 31 32 32 33 33 35 35 38 39 39 40 40 41 41 42 43 43 44 44 45 45 46 46 47 47 48 48 54 61 62
factor               : 37
list                 : 2 3 0
prlist               : 13 54 55
procname             : 56 57
return               : 11
stmt                 : 3 14 15 16 17 17 25 56 57
stmtlist             : 18 25
term                 : 36

Parsing method: LALR

state 0

    (0) S' -> . list
    (1) list -> . empty
    (2) list -> . list asgn
    (3) list -> . list stmt
    (63) empty -> .

    ID              reduce using rule 63 (empty -> .)
    procedure       reduce using rule 63 (empty -> .)
    print           reduce using rule 63 (empty -> .)
    while           reduce using rule 63 (empty -> .)
    for             reduce using rule 63 (empty -> .)
    if              reduce using rule 63 (empty -> .)
    LKEY            reduce using rule 63 (empty -> .)
    BLTIN           reduce using rule 63 (empty -> .)
    NUMBER          reduce using rule 63 (empty -> .)
    NOT             reduce using rule 63 (empty -> .)
    INC             reduce using rule 63 (empty -> .)
    DEC             reduce using rule 63 (empty -> .)
    RETURN          reduce using rule 63 (empty -> .)
    read            reduce using rule 63 (empty -> .)
    (               reduce using rule 63 (empty -> .)
    $end            reduce using rule 63 (empty -> .)

    list                           shift and go to state 1
    empty                          shift and go to state 2

state 1

    (0) S' -> list .
    (2) list -> list . asgn
    (3) list -> list . stmt
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (10) stmt -> . expr
    (11) stmt -> . return LPAREN expr RPAREN
    (12) stmt -> . procedure begin LPAREN arglist RPAREN
    (13) stmt -> . print prlist
    (14) stmt -> . while LPAREN cond RPAREN stmt end
    (15) stmt -> . for LPAREN cond ; cond ; cond RPAREN stmt end
    (16) stmt -> . if LPAREN cond RPAREN stmt end
    (17) stmt -> . if LPAREN cond RPAREN stmt end ELSE stmt end
    (18) stmt -> . LKEY stmtlist RKEY
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (23) return -> . RETURN
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    ID              shift and go to state 16
    procedure       shift and go to state 22
    print           shift and go to state 10
    while           shift and go to state 20
    for             shift and go to state 6
    if              shift and go to state 5
    LKEY            shift and go to state 12
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    RETURN          shift and go to state 3
    read            shift and go to state 13
    (               shift and go to state 7

    return                         shift and go to state 11
    expr                           shift and go to state 19
    term                           shift and go to state 17
    stmt                           shift and go to state 14
    asgn                           shift and go to state 8
    factor                         shift and go to state 9

state 2

    (1) list -> empty .

    ID              reduce using rule 1 (list -> empty .)
    procedure       reduce using rule 1 (list -> empty .)
    print           reduce using rule 1 (list -> empty .)
    while           reduce using rule 1 (list -> empty .)
    for             reduce using rule 1 (list -> empty .)
    if              reduce using rule 1 (list -> empty .)
    LKEY            reduce using rule 1 (list -> empty .)
    BLTIN           reduce using rule 1 (list -> empty .)
    NUMBER          reduce using rule 1 (list -> empty .)
    NOT             reduce using rule 1 (list -> empty .)
    INC             reduce using rule 1 (list -> empty .)
    DEC             reduce using rule 1 (list -> empty .)
    RETURN          reduce using rule 1 (list -> empty .)
    read            reduce using rule 1 (list -> empty .)
    (               reduce using rule 1 (list -> empty .)
    $end            reduce using rule 1 (list -> empty .)


state 3

    (23) return -> RETURN .

    LPAREN          reduce using rule 23 (return -> RETURN .)


state 4

    (34) expr -> NUMBER .

    +               reduce using rule 34 (expr -> NUMBER .)
    -               reduce using rule 34 (expr -> NUMBER .)
    *               reduce using rule 34 (expr -> NUMBER .)
    /               reduce using rule 34 (expr -> NUMBER .)
    EXPONENT        reduce using rule 34 (expr -> NUMBER .)
    %               reduce using rule 34 (expr -> NUMBER .)
    OR              reduce using rule 34 (expr -> NUMBER .)
    AND             reduce using rule 34 (expr -> NUMBER .)
    LT              reduce using rule 34 (expr -> NUMBER .)
    GT              reduce using rule 34 (expr -> NUMBER .)
    LE              reduce using rule 34 (expr -> NUMBER .)
    GE              reduce using rule 34 (expr -> NUMBER .)
    EQ              reduce using rule 34 (expr -> NUMBER .)
    NE              reduce using rule 34 (expr -> NUMBER .)
    ID              reduce using rule 34 (expr -> NUMBER .)
    procedure       reduce using rule 34 (expr -> NUMBER .)
    print           reduce using rule 34 (expr -> NUMBER .)
    while           reduce using rule 34 (expr -> NUMBER .)
    for             reduce using rule 34 (expr -> NUMBER .)
    if              reduce using rule 34 (expr -> NUMBER .)
    LKEY            reduce using rule 34 (expr -> NUMBER .)
    BLTIN           reduce using rule 34 (expr -> NUMBER .)
    NUMBER          reduce using rule 34 (expr -> NUMBER .)
    NOT             reduce using rule 34 (expr -> NUMBER .)
    INC             reduce using rule 34 (expr -> NUMBER .)
    DEC             reduce using rule 34 (expr -> NUMBER .)
    RETURN          reduce using rule 34 (expr -> NUMBER .)
    read            reduce using rule 34 (expr -> NUMBER .)
    (               reduce using rule 34 (expr -> NUMBER .)
    $end            reduce using rule 34 (expr -> NUMBER .)
    )               reduce using rule 34 (expr -> NUMBER .)
    RPAREN          reduce using rule 34 (expr -> NUMBER .)
    ;               reduce using rule 34 (expr -> NUMBER .)
    RKEY            reduce using rule 34 (expr -> NUMBER .)
    ,               reduce using rule 34 (expr -> NUMBER .)
    ELSE            reduce using rule 34 (expr -> NUMBER .)


state 5

    (16) stmt -> if . LPAREN cond RPAREN stmt end
    (17) stmt -> if . LPAREN cond RPAREN stmt end ELSE stmt end

    LPAREN          shift and go to state 24


state 6

    (15) stmt -> for . LPAREN cond ; cond ; cond RPAREN stmt end

    LPAREN          shift and go to state 25


state 7

    (38) factor -> ( . expr )
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    read            shift and go to state 13
    (               shift and go to state 7

    expr                           shift and go to state 28
    term                           shift and go to state 17
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 8

    (2) list -> list asgn .
    (29) expr -> asgn .

  ! reduce/reduce conflict for ID resolved using rule 2 (list -> list asgn .)
  ! reduce/reduce conflict for procedure resolved using rule 2 (list -> list asgn .)
  ! reduce/reduce conflict for print resolved using rule 2 (list -> list asgn .)
  ! reduce/reduce conflict for while resolved using rule 2 (list -> list asgn .)
  ! reduce/reduce conflict for for resolved using rule 2 (list -> list asgn .)
  ! reduce/reduce conflict for if resolved using rule 2 (list -> list asgn .)
  ! reduce/reduce conflict for LKEY resolved using rule 2 (list -> list asgn .)
  ! reduce/reduce conflict for BLTIN resolved using rule 2 (list -> list asgn .)
  ! reduce/reduce conflict for NUMBER resolved using rule 2 (list -> list asgn .)
  ! reduce/reduce conflict for NOT resolved using rule 2 (list -> list asgn .)
  ! reduce/reduce conflict for INC resolved using rule 2 (list -> list asgn .)
  ! reduce/reduce conflict for DEC resolved using rule 2 (list -> list asgn .)
  ! reduce/reduce conflict for RETURN resolved using rule 2 (list -> list asgn .)
  ! reduce/reduce conflict for read resolved using rule 2 (list -> list asgn .)
  ! reduce/reduce conflict for ( resolved using rule 2 (list -> list asgn .)
  ! reduce/reduce conflict for $end resolved using rule 2 (list -> list asgn .)
    ID              reduce using rule 2 (list -> list asgn .)
    procedure       reduce using rule 2 (list -> list asgn .)
    print           reduce using rule 2 (list -> list asgn .)
    while           reduce using rule 2 (list -> list asgn .)
    for             reduce using rule 2 (list -> list asgn .)
    if              reduce using rule 2 (list -> list asgn .)
    LKEY            reduce using rule 2 (list -> list asgn .)
    BLTIN           reduce using rule 2 (list -> list asgn .)
    NUMBER          reduce using rule 2 (list -> list asgn .)
    NOT             reduce using rule 2 (list -> list asgn .)
    INC             reduce using rule 2 (list -> list asgn .)
    DEC             reduce using rule 2 (list -> list asgn .)
    RETURN          reduce using rule 2 (list -> list asgn .)
    read            reduce using rule 2 (list -> list asgn .)
    (               reduce using rule 2 (list -> list asgn .)
    $end            reduce using rule 2 (list -> list asgn .)
    +               reduce using rule 29 (expr -> asgn .)
    -               reduce using rule 29 (expr -> asgn .)
    *               reduce using rule 29 (expr -> asgn .)
    /               reduce using rule 29 (expr -> asgn .)
    EXPONENT        reduce using rule 29 (expr -> asgn .)
    %               reduce using rule 29 (expr -> asgn .)
    OR              reduce using rule 29 (expr -> asgn .)
    AND             reduce using rule 29 (expr -> asgn .)
    LT              reduce using rule 29 (expr -> asgn .)
    GT              reduce using rule 29 (expr -> asgn .)
    LE              reduce using rule 29 (expr -> asgn .)
    GE              reduce using rule 29 (expr -> asgn .)
    EQ              reduce using rule 29 (expr -> asgn .)
    NE              reduce using rule 29 (expr -> asgn .)

  ! ID              [ reduce using rule 29 (expr -> asgn .) ]
  ! procedure       [ reduce using rule 29 (expr -> asgn .) ]
  ! print           [ reduce using rule 29 (expr -> asgn .) ]
  ! while           [ reduce using rule 29 (expr -> asgn .) ]
  ! for             [ reduce using rule 29 (expr -> asgn .) ]
  ! if              [ reduce using rule 29 (expr -> asgn .) ]
  ! LKEY            [ reduce using rule 29 (expr -> asgn .) ]
  ! BLTIN           [ reduce using rule 29 (expr -> asgn .) ]
  ! NUMBER          [ reduce using rule 29 (expr -> asgn .) ]
  ! NOT             [ reduce using rule 29 (expr -> asgn .) ]
  ! INC             [ reduce using rule 29 (expr -> asgn .) ]
  ! DEC             [ reduce using rule 29 (expr -> asgn .) ]
  ! RETURN          [ reduce using rule 29 (expr -> asgn .) ]
  ! read            [ reduce using rule 29 (expr -> asgn .) ]
  ! (               [ reduce using rule 29 (expr -> asgn .) ]
  ! $end            [ reduce using rule 29 (expr -> asgn .) ]


state 9

    (37) term -> factor .

    +               reduce using rule 37 (term -> factor .)
    -               reduce using rule 37 (term -> factor .)
    *               reduce using rule 37 (term -> factor .)
    /               reduce using rule 37 (term -> factor .)
    EXPONENT        reduce using rule 37 (term -> factor .)
    %               reduce using rule 37 (term -> factor .)
    OR              reduce using rule 37 (term -> factor .)
    AND             reduce using rule 37 (term -> factor .)
    LT              reduce using rule 37 (term -> factor .)
    GT              reduce using rule 37 (term -> factor .)
    LE              reduce using rule 37 (term -> factor .)
    GE              reduce using rule 37 (term -> factor .)
    EQ              reduce using rule 37 (term -> factor .)
    NE              reduce using rule 37 (term -> factor .)
    ID              reduce using rule 37 (term -> factor .)
    procedure       reduce using rule 37 (term -> factor .)
    print           reduce using rule 37 (term -> factor .)
    while           reduce using rule 37 (term -> factor .)
    for             reduce using rule 37 (term -> factor .)
    if              reduce using rule 37 (term -> factor .)
    LKEY            reduce using rule 37 (term -> factor .)
    BLTIN           reduce using rule 37 (term -> factor .)
    NUMBER          reduce using rule 37 (term -> factor .)
    NOT             reduce using rule 37 (term -> factor .)
    INC             reduce using rule 37 (term -> factor .)
    DEC             reduce using rule 37 (term -> factor .)
    RETURN          reduce using rule 37 (term -> factor .)
    read            reduce using rule 37 (term -> factor .)
    (               reduce using rule 37 (term -> factor .)
    $end            reduce using rule 37 (term -> factor .)
    )               reduce using rule 37 (term -> factor .)
    RPAREN          reduce using rule 37 (term -> factor .)
    ;               reduce using rule 37 (term -> factor .)
    RKEY            reduce using rule 37 (term -> factor .)
    ,               reduce using rule 37 (term -> factor .)
    ELSE            reduce using rule 37 (term -> factor .)


state 10

    (13) stmt -> print . prlist
    (53) prlist -> . STRING
    (54) prlist -> . prlist , expr
    (55) prlist -> . prlist , STRING

    STRING          shift and go to state 30

    prlist                         shift and go to state 29

state 11

    (11) stmt -> return . LPAREN expr RPAREN

    LPAREN          shift and go to state 31


state 12

    (18) stmt -> LKEY . stmtlist RKEY
    (24) stmtlist -> . empty
    (25) stmtlist -> . stmtlist stmt
    (63) empty -> .

    RKEY            reduce using rule 63 (empty -> .)
    procedure       reduce using rule 63 (empty -> .)
    print           reduce using rule 63 (empty -> .)
    while           reduce using rule 63 (empty -> .)
    for             reduce using rule 63 (empty -> .)
    if              reduce using rule 63 (empty -> .)
    LKEY            reduce using rule 63 (empty -> .)
    ID              reduce using rule 63 (empty -> .)
    BLTIN           reduce using rule 63 (empty -> .)
    NUMBER          reduce using rule 63 (empty -> .)
    NOT             reduce using rule 63 (empty -> .)
    INC             reduce using rule 63 (empty -> .)
    DEC             reduce using rule 63 (empty -> .)
    RETURN          reduce using rule 63 (empty -> .)
    read            reduce using rule 63 (empty -> .)
    (               reduce using rule 63 (empty -> .)

    empty                          shift and go to state 32
    stmtlist                       shift and go to state 33

state 13

    (27) term -> read . ( ID )

    (               shift and go to state 34


state 14

    (3) list -> list stmt .

    ID              reduce using rule 3 (list -> list stmt .)
    procedure       reduce using rule 3 (list -> list stmt .)
    print           reduce using rule 3 (list -> list stmt .)
    while           reduce using rule 3 (list -> list stmt .)
    for             reduce using rule 3 (list -> list stmt .)
    if              reduce using rule 3 (list -> list stmt .)
    LKEY            reduce using rule 3 (list -> list stmt .)
    BLTIN           reduce using rule 3 (list -> list stmt .)
    NUMBER          reduce using rule 3 (list -> list stmt .)
    NOT             reduce using rule 3 (list -> list stmt .)
    INC             reduce using rule 3 (list -> list stmt .)
    DEC             reduce using rule 3 (list -> list stmt .)
    RETURN          reduce using rule 3 (list -> list stmt .)
    read            reduce using rule 3 (list -> list stmt .)
    (               reduce using rule 3 (list -> list stmt .)
    $end            reduce using rule 3 (list -> list stmt .)


state 15

    (28) expr -> BLTIN . ( expr )

    (               shift and go to state 35


state 16

    (4) asgn -> ID . = expr
    (5) asgn -> ID . ADDEQ expr
    (6) asgn -> ID . SUBEQ expr
    (7) asgn -> ID . MULEQ expr
    (8) asgn -> ID . DIVEQ expr
    (9) asgn -> ID . MODEQ expr
    (26) expr -> ID .
    (51) expr -> ID . DEC
    (52) expr -> ID . INC

  ! shift/reduce conflict for DEC resolved as shift
  ! shift/reduce conflict for INC resolved as shift
    =               shift and go to state 41
    ADDEQ           shift and go to state 39
    SUBEQ           shift and go to state 37
    MULEQ           shift and go to state 38
    DIVEQ           shift and go to state 42
    MODEQ           shift and go to state 36
    +               reduce using rule 26 (expr -> ID .)
    -               reduce using rule 26 (expr -> ID .)
    *               reduce using rule 26 (expr -> ID .)
    /               reduce using rule 26 (expr -> ID .)
    EXPONENT        reduce using rule 26 (expr -> ID .)
    %               reduce using rule 26 (expr -> ID .)
    OR              reduce using rule 26 (expr -> ID .)
    AND             reduce using rule 26 (expr -> ID .)
    LT              reduce using rule 26 (expr -> ID .)
    GT              reduce using rule 26 (expr -> ID .)
    LE              reduce using rule 26 (expr -> ID .)
    GE              reduce using rule 26 (expr -> ID .)
    EQ              reduce using rule 26 (expr -> ID .)
    NE              reduce using rule 26 (expr -> ID .)
    ID              reduce using rule 26 (expr -> ID .)
    procedure       reduce using rule 26 (expr -> ID .)
    print           reduce using rule 26 (expr -> ID .)
    while           reduce using rule 26 (expr -> ID .)
    for             reduce using rule 26 (expr -> ID .)
    if              reduce using rule 26 (expr -> ID .)
    LKEY            reduce using rule 26 (expr -> ID .)
    BLTIN           reduce using rule 26 (expr -> ID .)
    NUMBER          reduce using rule 26 (expr -> ID .)
    NOT             reduce using rule 26 (expr -> ID .)
    RETURN          reduce using rule 26 (expr -> ID .)
    read            reduce using rule 26 (expr -> ID .)
    (               reduce using rule 26 (expr -> ID .)
    $end            reduce using rule 26 (expr -> ID .)
    DEC             shift and go to state 40
    INC             shift and go to state 43

  ! INC             [ reduce using rule 26 (expr -> ID .) ]
  ! DEC             [ reduce using rule 26 (expr -> ID .) ]


state 17

    (36) expr -> term .

    +               reduce using rule 36 (expr -> term .)
    -               reduce using rule 36 (expr -> term .)
    *               reduce using rule 36 (expr -> term .)
    /               reduce using rule 36 (expr -> term .)
    EXPONENT        reduce using rule 36 (expr -> term .)
    %               reduce using rule 36 (expr -> term .)
    OR              reduce using rule 36 (expr -> term .)
    AND             reduce using rule 36 (expr -> term .)
    LT              reduce using rule 36 (expr -> term .)
    GT              reduce using rule 36 (expr -> term .)
    LE              reduce using rule 36 (expr -> term .)
    GE              reduce using rule 36 (expr -> term .)
    EQ              reduce using rule 36 (expr -> term .)
    NE              reduce using rule 36 (expr -> term .)
    ID              reduce using rule 36 (expr -> term .)
    procedure       reduce using rule 36 (expr -> term .)
    print           reduce using rule 36 (expr -> term .)
    while           reduce using rule 36 (expr -> term .)
    for             reduce using rule 36 (expr -> term .)
    if              reduce using rule 36 (expr -> term .)
    LKEY            reduce using rule 36 (expr -> term .)
    BLTIN           reduce using rule 36 (expr -> term .)
    NUMBER          reduce using rule 36 (expr -> term .)
    NOT             reduce using rule 36 (expr -> term .)
    INC             reduce using rule 36 (expr -> term .)
    DEC             reduce using rule 36 (expr -> term .)
    RETURN          reduce using rule 36 (expr -> term .)
    read            reduce using rule 36 (expr -> term .)
    (               reduce using rule 36 (expr -> term .)
    $end            reduce using rule 36 (expr -> term .)
    )               reduce using rule 36 (expr -> term .)
    RPAREN          reduce using rule 36 (expr -> term .)
    ;               reduce using rule 36 (expr -> term .)
    RKEY            reduce using rule 36 (expr -> term .)
    ,               reduce using rule 36 (expr -> term .)
    ELSE            reduce using rule 36 (expr -> term .)


state 18

    (50) expr -> DEC . ID

    ID              shift and go to state 44


state 19

    (10) stmt -> expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (35) expr -> expr . EXPONENT expr
    (39) expr -> expr . % expr
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr
    (43) expr -> expr . LT expr
    (44) expr -> expr . GT expr
    (45) expr -> expr . LE expr
    (46) expr -> expr . GE expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr

    ELSE            reduce using rule 10 (stmt -> expr .)
    ID              reduce using rule 10 (stmt -> expr .)
    procedure       reduce using rule 10 (stmt -> expr .)
    print           reduce using rule 10 (stmt -> expr .)
    while           reduce using rule 10 (stmt -> expr .)
    for             reduce using rule 10 (stmt -> expr .)
    if              reduce using rule 10 (stmt -> expr .)
    LKEY            reduce using rule 10 (stmt -> expr .)
    BLTIN           reduce using rule 10 (stmt -> expr .)
    NUMBER          reduce using rule 10 (stmt -> expr .)
    NOT             reduce using rule 10 (stmt -> expr .)
    INC             reduce using rule 10 (stmt -> expr .)
    DEC             reduce using rule 10 (stmt -> expr .)
    RETURN          reduce using rule 10 (stmt -> expr .)
    read            reduce using rule 10 (stmt -> expr .)
    (               reduce using rule 10 (stmt -> expr .)
    $end            reduce using rule 10 (stmt -> expr .)
    RKEY            reduce using rule 10 (stmt -> expr .)
    +               shift and go to state 49
    -               shift and go to state 51
    *               shift and go to state 50
    /               shift and go to state 53
    EXPONENT        shift and go to state 48
    %               shift and go to state 47
    OR              shift and go to state 58
    AND             shift and go to state 45
    LT              shift and go to state 55
    GT              shift and go to state 46
    LE              shift and go to state 56
    GE              shift and go to state 52
    EQ              shift and go to state 57
    NE              shift and go to state 54


state 20

    (14) stmt -> while . LPAREN cond RPAREN stmt end

    LPAREN          shift and go to state 59


state 21

    (42) expr -> NOT . expr
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    read            shift and go to state 13
    (               shift and go to state 7

    expr                           shift and go to state 60
    term                           shift and go to state 17
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 22

    (12) stmt -> procedure . begin LPAREN arglist RPAREN
    (20) begin -> .

    LPAREN          reduce using rule 20 (begin -> .)

    begin                          shift and go to state 61

state 23

    (49) expr -> INC . ID

    ID              shift and go to state 62


state 24

    (16) stmt -> if LPAREN . cond RPAREN stmt end
    (17) stmt -> if LPAREN . cond RPAREN stmt end ELSE stmt end
    (19) cond -> . expr
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    read            shift and go to state 13
    (               shift and go to state 7

    term                           shift and go to state 17
    expr                           shift and go to state 64
    asgn                           shift and go to state 26
    cond                           shift and go to state 63
    factor                         shift and go to state 9

state 25

    (15) stmt -> for LPAREN . cond ; cond ; cond RPAREN stmt end
    (19) cond -> . expr
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    read            shift and go to state 13
    (               shift and go to state 7

    term                           shift and go to state 17
    expr                           shift and go to state 64
    asgn                           shift and go to state 26
    cond                           shift and go to state 65
    factor                         shift and go to state 9

state 26

    (29) expr -> asgn .

    +               reduce using rule 29 (expr -> asgn .)
    -               reduce using rule 29 (expr -> asgn .)
    *               reduce using rule 29 (expr -> asgn .)
    /               reduce using rule 29 (expr -> asgn .)
    EXPONENT        reduce using rule 29 (expr -> asgn .)
    %               reduce using rule 29 (expr -> asgn .)
    OR              reduce using rule 29 (expr -> asgn .)
    AND             reduce using rule 29 (expr -> asgn .)
    LT              reduce using rule 29 (expr -> asgn .)
    GT              reduce using rule 29 (expr -> asgn .)
    LE              reduce using rule 29 (expr -> asgn .)
    GE              reduce using rule 29 (expr -> asgn .)
    EQ              reduce using rule 29 (expr -> asgn .)
    NE              reduce using rule 29 (expr -> asgn .)
    ID              reduce using rule 29 (expr -> asgn .)
    procedure       reduce using rule 29 (expr -> asgn .)
    print           reduce using rule 29 (expr -> asgn .)
    while           reduce using rule 29 (expr -> asgn .)
    for             reduce using rule 29 (expr -> asgn .)
    if              reduce using rule 29 (expr -> asgn .)
    LKEY            reduce using rule 29 (expr -> asgn .)
    BLTIN           reduce using rule 29 (expr -> asgn .)
    NUMBER          reduce using rule 29 (expr -> asgn .)
    NOT             reduce using rule 29 (expr -> asgn .)
    INC             reduce using rule 29 (expr -> asgn .)
    DEC             reduce using rule 29 (expr -> asgn .)
    RETURN          reduce using rule 29 (expr -> asgn .)
    read            reduce using rule 29 (expr -> asgn .)
    (               reduce using rule 29 (expr -> asgn .)
    $end            reduce using rule 29 (expr -> asgn .)
    )               reduce using rule 29 (expr -> asgn .)
    RPAREN          reduce using rule 29 (expr -> asgn .)
    ;               reduce using rule 29 (expr -> asgn .)
    RKEY            reduce using rule 29 (expr -> asgn .)
    ,               reduce using rule 29 (expr -> asgn .)
    ELSE            reduce using rule 29 (expr -> asgn .)


state 27

    (26) expr -> ID .
    (51) expr -> ID . DEC
    (52) expr -> ID . INC
    (4) asgn -> ID . = expr
    (5) asgn -> ID . ADDEQ expr
    (6) asgn -> ID . SUBEQ expr
    (7) asgn -> ID . MULEQ expr
    (8) asgn -> ID . DIVEQ expr
    (9) asgn -> ID . MODEQ expr

  ! shift/reduce conflict for DEC resolved as shift
  ! shift/reduce conflict for INC resolved as shift
    +               reduce using rule 26 (expr -> ID .)
    -               reduce using rule 26 (expr -> ID .)
    *               reduce using rule 26 (expr -> ID .)
    /               reduce using rule 26 (expr -> ID .)
    EXPONENT        reduce using rule 26 (expr -> ID .)
    %               reduce using rule 26 (expr -> ID .)
    OR              reduce using rule 26 (expr -> ID .)
    AND             reduce using rule 26 (expr -> ID .)
    LT              reduce using rule 26 (expr -> ID .)
    GT              reduce using rule 26 (expr -> ID .)
    LE              reduce using rule 26 (expr -> ID .)
    GE              reduce using rule 26 (expr -> ID .)
    EQ              reduce using rule 26 (expr -> ID .)
    NE              reduce using rule 26 (expr -> ID .)
    ID              reduce using rule 26 (expr -> ID .)
    procedure       reduce using rule 26 (expr -> ID .)
    print           reduce using rule 26 (expr -> ID .)
    while           reduce using rule 26 (expr -> ID .)
    for             reduce using rule 26 (expr -> ID .)
    if              reduce using rule 26 (expr -> ID .)
    LKEY            reduce using rule 26 (expr -> ID .)
    BLTIN           reduce using rule 26 (expr -> ID .)
    NUMBER          reduce using rule 26 (expr -> ID .)
    NOT             reduce using rule 26 (expr -> ID .)
    RETURN          reduce using rule 26 (expr -> ID .)
    read            reduce using rule 26 (expr -> ID .)
    (               reduce using rule 26 (expr -> ID .)
    $end            reduce using rule 26 (expr -> ID .)
    )               reduce using rule 26 (expr -> ID .)
    RPAREN          reduce using rule 26 (expr -> ID .)
    ;               reduce using rule 26 (expr -> ID .)
    RKEY            reduce using rule 26 (expr -> ID .)
    ,               reduce using rule 26 (expr -> ID .)
    ELSE            reduce using rule 26 (expr -> ID .)
    DEC             shift and go to state 40
    INC             shift and go to state 43
    =               shift and go to state 41
    ADDEQ           shift and go to state 39
    SUBEQ           shift and go to state 37
    MULEQ           shift and go to state 38
    DIVEQ           shift and go to state 42
    MODEQ           shift and go to state 36

  ! INC             [ reduce using rule 26 (expr -> ID .) ]
  ! DEC             [ reduce using rule 26 (expr -> ID .) ]


state 28

    (38) factor -> ( expr . )
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (35) expr -> expr . EXPONENT expr
    (39) expr -> expr . % expr
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr
    (43) expr -> expr . LT expr
    (44) expr -> expr . GT expr
    (45) expr -> expr . LE expr
    (46) expr -> expr . GE expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr

    )               shift and go to state 66
    +               shift and go to state 49
    -               shift and go to state 51
    *               shift and go to state 50
    /               shift and go to state 53
    EXPONENT        shift and go to state 48
    %               shift and go to state 47
    OR              shift and go to state 58
    AND             shift and go to state 45
    LT              shift and go to state 55
    GT              shift and go to state 46
    LE              shift and go to state 56
    GE              shift and go to state 52
    EQ              shift and go to state 57
    NE              shift and go to state 54


state 29

    (13) stmt -> print prlist .
    (54) prlist -> prlist . , expr
    (55) prlist -> prlist . , STRING

    ELSE            reduce using rule 13 (stmt -> print prlist .)
    ID              reduce using rule 13 (stmt -> print prlist .)
    procedure       reduce using rule 13 (stmt -> print prlist .)
    print           reduce using rule 13 (stmt -> print prlist .)
    while           reduce using rule 13 (stmt -> print prlist .)
    for             reduce using rule 13 (stmt -> print prlist .)
    if              reduce using rule 13 (stmt -> print prlist .)
    LKEY            reduce using rule 13 (stmt -> print prlist .)
    BLTIN           reduce using rule 13 (stmt -> print prlist .)
    NUMBER          reduce using rule 13 (stmt -> print prlist .)
    NOT             reduce using rule 13 (stmt -> print prlist .)
    INC             reduce using rule 13 (stmt -> print prlist .)
    DEC             reduce using rule 13 (stmt -> print prlist .)
    RETURN          reduce using rule 13 (stmt -> print prlist .)
    read            reduce using rule 13 (stmt -> print prlist .)
    (               reduce using rule 13 (stmt -> print prlist .)
    $end            reduce using rule 13 (stmt -> print prlist .)
    RKEY            reduce using rule 13 (stmt -> print prlist .)
    ,               shift and go to state 67


state 30

    (53) prlist -> STRING .

    ,               reduce using rule 53 (prlist -> STRING .)
    ID              reduce using rule 53 (prlist -> STRING .)
    procedure       reduce using rule 53 (prlist -> STRING .)
    print           reduce using rule 53 (prlist -> STRING .)
    while           reduce using rule 53 (prlist -> STRING .)
    for             reduce using rule 53 (prlist -> STRING .)
    if              reduce using rule 53 (prlist -> STRING .)
    LKEY            reduce using rule 53 (prlist -> STRING .)
    BLTIN           reduce using rule 53 (prlist -> STRING .)
    NUMBER          reduce using rule 53 (prlist -> STRING .)
    NOT             reduce using rule 53 (prlist -> STRING .)
    INC             reduce using rule 53 (prlist -> STRING .)
    DEC             reduce using rule 53 (prlist -> STRING .)
    RETURN          reduce using rule 53 (prlist -> STRING .)
    read            reduce using rule 53 (prlist -> STRING .)
    (               reduce using rule 53 (prlist -> STRING .)
    $end            reduce using rule 53 (prlist -> STRING .)
    RKEY            reduce using rule 53 (prlist -> STRING .)
    ELSE            reduce using rule 53 (prlist -> STRING .)


state 31

    (11) stmt -> return LPAREN . expr RPAREN
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    read            shift and go to state 13
    (               shift and go to state 7

    expr                           shift and go to state 68
    term                           shift and go to state 17
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 32

    (24) stmtlist -> empty .

    RKEY            reduce using rule 24 (stmtlist -> empty .)
    procedure       reduce using rule 24 (stmtlist -> empty .)
    print           reduce using rule 24 (stmtlist -> empty .)
    while           reduce using rule 24 (stmtlist -> empty .)
    for             reduce using rule 24 (stmtlist -> empty .)
    if              reduce using rule 24 (stmtlist -> empty .)
    LKEY            reduce using rule 24 (stmtlist -> empty .)
    ID              reduce using rule 24 (stmtlist -> empty .)
    BLTIN           reduce using rule 24 (stmtlist -> empty .)
    NUMBER          reduce using rule 24 (stmtlist -> empty .)
    NOT             reduce using rule 24 (stmtlist -> empty .)
    INC             reduce using rule 24 (stmtlist -> empty .)
    DEC             reduce using rule 24 (stmtlist -> empty .)
    RETURN          reduce using rule 24 (stmtlist -> empty .)
    read            reduce using rule 24 (stmtlist -> empty .)
    (               reduce using rule 24 (stmtlist -> empty .)


state 33

    (18) stmt -> LKEY stmtlist . RKEY
    (25) stmtlist -> stmtlist . stmt
    (10) stmt -> . expr
    (11) stmt -> . return LPAREN expr RPAREN
    (12) stmt -> . procedure begin LPAREN arglist RPAREN
    (13) stmt -> . print prlist
    (14) stmt -> . while LPAREN cond RPAREN stmt end
    (15) stmt -> . for LPAREN cond ; cond ; cond RPAREN stmt end
    (16) stmt -> . if LPAREN cond RPAREN stmt end
    (17) stmt -> . if LPAREN cond RPAREN stmt end ELSE stmt end
    (18) stmt -> . LKEY stmtlist RKEY
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (23) return -> . RETURN
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    RKEY            shift and go to state 69
    procedure       shift and go to state 22
    print           shift and go to state 10
    while           shift and go to state 20
    for             shift and go to state 6
    if              shift and go to state 5
    LKEY            shift and go to state 12
    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    RETURN          shift and go to state 3
    read            shift and go to state 13
    (               shift and go to state 7

    return                         shift and go to state 11
    expr                           shift and go to state 19
    term                           shift and go to state 17
    stmt                           shift and go to state 70
    asgn                           shift and go to state 26
    factor                         shift and go to state 9

state 34

    (27) term -> read ( . ID )

    ID              shift and go to state 71


state 35

    (28) expr -> BLTIN ( . expr )
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    read            shift and go to state 13
    (               shift and go to state 7

    expr                           shift and go to state 72
    term                           shift and go to state 17
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 36

    (9) asgn -> ID MODEQ . expr
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    read            shift and go to state 13
    (               shift and go to state 7

    expr                           shift and go to state 73
    term                           shift and go to state 17
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 37

    (6) asgn -> ID SUBEQ . expr
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    read            shift and go to state 13
    (               shift and go to state 7

    expr                           shift and go to state 74
    term                           shift and go to state 17
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 38

    (7) asgn -> ID MULEQ . expr
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    read            shift and go to state 13
    (               shift and go to state 7

    expr                           shift and go to state 75
    term                           shift and go to state 17
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 39

    (5) asgn -> ID ADDEQ . expr
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    read            shift and go to state 13
    (               shift and go to state 7

    expr                           shift and go to state 76
    term                           shift and go to state 17
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 40

    (51) expr -> ID DEC .

    +               reduce using rule 51 (expr -> ID DEC .)
    -               reduce using rule 51 (expr -> ID DEC .)
    *               reduce using rule 51 (expr -> ID DEC .)
    /               reduce using rule 51 (expr -> ID DEC .)
    EXPONENT        reduce using rule 51 (expr -> ID DEC .)
    %               reduce using rule 51 (expr -> ID DEC .)
    OR              reduce using rule 51 (expr -> ID DEC .)
    AND             reduce using rule 51 (expr -> ID DEC .)
    LT              reduce using rule 51 (expr -> ID DEC .)
    GT              reduce using rule 51 (expr -> ID DEC .)
    LE              reduce using rule 51 (expr -> ID DEC .)
    GE              reduce using rule 51 (expr -> ID DEC .)
    EQ              reduce using rule 51 (expr -> ID DEC .)
    NE              reduce using rule 51 (expr -> ID DEC .)
    ID              reduce using rule 51 (expr -> ID DEC .)
    procedure       reduce using rule 51 (expr -> ID DEC .)
    print           reduce using rule 51 (expr -> ID DEC .)
    while           reduce using rule 51 (expr -> ID DEC .)
    for             reduce using rule 51 (expr -> ID DEC .)
    if              reduce using rule 51 (expr -> ID DEC .)
    LKEY            reduce using rule 51 (expr -> ID DEC .)
    BLTIN           reduce using rule 51 (expr -> ID DEC .)
    NUMBER          reduce using rule 51 (expr -> ID DEC .)
    NOT             reduce using rule 51 (expr -> ID DEC .)
    INC             reduce using rule 51 (expr -> ID DEC .)
    DEC             reduce using rule 51 (expr -> ID DEC .)
    RETURN          reduce using rule 51 (expr -> ID DEC .)
    read            reduce using rule 51 (expr -> ID DEC .)
    (               reduce using rule 51 (expr -> ID DEC .)
    $end            reduce using rule 51 (expr -> ID DEC .)
    )               reduce using rule 51 (expr -> ID DEC .)
    RPAREN          reduce using rule 51 (expr -> ID DEC .)
    ;               reduce using rule 51 (expr -> ID DEC .)
    RKEY            reduce using rule 51 (expr -> ID DEC .)
    ,               reduce using rule 51 (expr -> ID DEC .)
    ELSE            reduce using rule 51 (expr -> ID DEC .)


state 41

    (4) asgn -> ID = . expr
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    read            shift and go to state 13
    (               shift and go to state 7

    expr                           shift and go to state 77
    term                           shift and go to state 17
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 42

    (8) asgn -> ID DIVEQ . expr
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    read            shift and go to state 13
    (               shift and go to state 7

    expr                           shift and go to state 78
    term                           shift and go to state 17
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 43

    (52) expr -> ID INC .

    +               reduce using rule 52 (expr -> ID INC .)
    -               reduce using rule 52 (expr -> ID INC .)
    *               reduce using rule 52 (expr -> ID INC .)
    /               reduce using rule 52 (expr -> ID INC .)
    EXPONENT        reduce using rule 52 (expr -> ID INC .)
    %               reduce using rule 52 (expr -> ID INC .)
    OR              reduce using rule 52 (expr -> ID INC .)
    AND             reduce using rule 52 (expr -> ID INC .)
    LT              reduce using rule 52 (expr -> ID INC .)
    GT              reduce using rule 52 (expr -> ID INC .)
    LE              reduce using rule 52 (expr -> ID INC .)
    GE              reduce using rule 52 (expr -> ID INC .)
    EQ              reduce using rule 52 (expr -> ID INC .)
    NE              reduce using rule 52 (expr -> ID INC .)
    ID              reduce using rule 52 (expr -> ID INC .)
    procedure       reduce using rule 52 (expr -> ID INC .)
    print           reduce using rule 52 (expr -> ID INC .)
    while           reduce using rule 52 (expr -> ID INC .)
    for             reduce using rule 52 (expr -> ID INC .)
    if              reduce using rule 52 (expr -> ID INC .)
    LKEY            reduce using rule 52 (expr -> ID INC .)
    BLTIN           reduce using rule 52 (expr -> ID INC .)
    NUMBER          reduce using rule 52 (expr -> ID INC .)
    NOT             reduce using rule 52 (expr -> ID INC .)
    INC             reduce using rule 52 (expr -> ID INC .)
    DEC             reduce using rule 52 (expr -> ID INC .)
    RETURN          reduce using rule 52 (expr -> ID INC .)
    read            reduce using rule 52 (expr -> ID INC .)
    (               reduce using rule 52 (expr -> ID INC .)
    $end            reduce using rule 52 (expr -> ID INC .)
    )               reduce using rule 52 (expr -> ID INC .)
    RPAREN          reduce using rule 52 (expr -> ID INC .)
    ;               reduce using rule 52 (expr -> ID INC .)
    RKEY            reduce using rule 52 (expr -> ID INC .)
    ,               reduce using rule 52 (expr -> ID INC .)
    ELSE            reduce using rule 52 (expr -> ID INC .)


state 44

    (50) expr -> DEC ID .

    +               reduce using rule 50 (expr -> DEC ID .)
    -               reduce using rule 50 (expr -> DEC ID .)
    *               reduce using rule 50 (expr -> DEC ID .)
    /               reduce using rule 50 (expr -> DEC ID .)
    EXPONENT        reduce using rule 50 (expr -> DEC ID .)
    %               reduce using rule 50 (expr -> DEC ID .)
    OR              reduce using rule 50 (expr -> DEC ID .)
    AND             reduce using rule 50 (expr -> DEC ID .)
    LT              reduce using rule 50 (expr -> DEC ID .)
    GT              reduce using rule 50 (expr -> DEC ID .)
    LE              reduce using rule 50 (expr -> DEC ID .)
    GE              reduce using rule 50 (expr -> DEC ID .)
    EQ              reduce using rule 50 (expr -> DEC ID .)
    NE              reduce using rule 50 (expr -> DEC ID .)
    ID              reduce using rule 50 (expr -> DEC ID .)
    procedure       reduce using rule 50 (expr -> DEC ID .)
    print           reduce using rule 50 (expr -> DEC ID .)
    while           reduce using rule 50 (expr -> DEC ID .)
    for             reduce using rule 50 (expr -> DEC ID .)
    if              reduce using rule 50 (expr -> DEC ID .)
    LKEY            reduce using rule 50 (expr -> DEC ID .)
    BLTIN           reduce using rule 50 (expr -> DEC ID .)
    NUMBER          reduce using rule 50 (expr -> DEC ID .)
    NOT             reduce using rule 50 (expr -> DEC ID .)
    INC             reduce using rule 50 (expr -> DEC ID .)
    DEC             reduce using rule 50 (expr -> DEC ID .)
    RETURN          reduce using rule 50 (expr -> DEC ID .)
    read            reduce using rule 50 (expr -> DEC ID .)
    (               reduce using rule 50 (expr -> DEC ID .)
    $end            reduce using rule 50 (expr -> DEC ID .)
    )               reduce using rule 50 (expr -> DEC ID .)
    RPAREN          reduce using rule 50 (expr -> DEC ID .)
    ;               reduce using rule 50 (expr -> DEC ID .)
    RKEY            reduce using rule 50 (expr -> DEC ID .)
    ,               reduce using rule 50 (expr -> DEC ID .)
    ELSE            reduce using rule 50 (expr -> DEC ID .)


state 45

    (41) expr -> expr AND . expr
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    read            shift and go to state 13
    (               shift and go to state 7

    expr                           shift and go to state 79
    term                           shift and go to state 17
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 46

    (44) expr -> expr GT . expr
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    read            shift and go to state 13
    (               shift and go to state 7

    expr                           shift and go to state 80
    term                           shift and go to state 17
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 47

    (39) expr -> expr % . expr
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    read            shift and go to state 13
    (               shift and go to state 7

    expr                           shift and go to state 81
    term                           shift and go to state 17
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 48

    (35) expr -> expr EXPONENT . expr
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    read            shift and go to state 13
    (               shift and go to state 7

    expr                           shift and go to state 82
    term                           shift and go to state 17
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 49

    (30) expr -> expr + . expr
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    read            shift and go to state 13
    (               shift and go to state 7

    expr                           shift and go to state 83
    term                           shift and go to state 17
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 50

    (32) expr -> expr * . expr
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    read            shift and go to state 13
    (               shift and go to state 7

    expr                           shift and go to state 84
    term                           shift and go to state 17
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 51

    (31) expr -> expr - . expr
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    read            shift and go to state 13
    (               shift and go to state 7

    expr                           shift and go to state 85
    term                           shift and go to state 17
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 52

    (46) expr -> expr GE . expr
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    read            shift and go to state 13
    (               shift and go to state 7

    expr                           shift and go to state 86
    term                           shift and go to state 17
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 53

    (33) expr -> expr / . expr
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    read            shift and go to state 13
    (               shift and go to state 7

    expr                           shift and go to state 87
    term                           shift and go to state 17
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 54

    (48) expr -> expr NE . expr
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    read            shift and go to state 13
    (               shift and go to state 7

    expr                           shift and go to state 88
    term                           shift and go to state 17
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 55

    (43) expr -> expr LT . expr
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    read            shift and go to state 13
    (               shift and go to state 7

    expr                           shift and go to state 89
    term                           shift and go to state 17
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 56

    (45) expr -> expr LE . expr
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    read            shift and go to state 13
    (               shift and go to state 7

    expr                           shift and go to state 90
    term                           shift and go to state 17
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 57

    (47) expr -> expr EQ . expr
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    read            shift and go to state 13
    (               shift and go to state 7

    expr                           shift and go to state 91
    term                           shift and go to state 17
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 58

    (40) expr -> expr OR . expr
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    read            shift and go to state 13
    (               shift and go to state 7

    expr                           shift and go to state 92
    term                           shift and go to state 17
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 59

    (14) stmt -> while LPAREN . cond RPAREN stmt end
    (19) cond -> . expr
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    read            shift and go to state 13
    (               shift and go to state 7

    term                           shift and go to state 17
    expr                           shift and go to state 64
    asgn                           shift and go to state 26
    cond                           shift and go to state 93
    factor                         shift and go to state 9

state 60

    (42) expr -> NOT expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (35) expr -> expr . EXPONENT expr
    (39) expr -> expr . % expr
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr
    (43) expr -> expr . LT expr
    (44) expr -> expr . GT expr
    (45) expr -> expr . LE expr
    (46) expr -> expr . GE expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr

    +               reduce using rule 42 (expr -> NOT expr .)
    -               reduce using rule 42 (expr -> NOT expr .)
    *               reduce using rule 42 (expr -> NOT expr .)
    /               reduce using rule 42 (expr -> NOT expr .)
    %               reduce using rule 42 (expr -> NOT expr .)
    OR              reduce using rule 42 (expr -> NOT expr .)
    AND             reduce using rule 42 (expr -> NOT expr .)
    LT              reduce using rule 42 (expr -> NOT expr .)
    GT              reduce using rule 42 (expr -> NOT expr .)
    LE              reduce using rule 42 (expr -> NOT expr .)
    GE              reduce using rule 42 (expr -> NOT expr .)
    EQ              reduce using rule 42 (expr -> NOT expr .)
    NE              reduce using rule 42 (expr -> NOT expr .)
    ID              reduce using rule 42 (expr -> NOT expr .)
    procedure       reduce using rule 42 (expr -> NOT expr .)
    print           reduce using rule 42 (expr -> NOT expr .)
    while           reduce using rule 42 (expr -> NOT expr .)
    for             reduce using rule 42 (expr -> NOT expr .)
    if              reduce using rule 42 (expr -> NOT expr .)
    LKEY            reduce using rule 42 (expr -> NOT expr .)
    BLTIN           reduce using rule 42 (expr -> NOT expr .)
    NUMBER          reduce using rule 42 (expr -> NOT expr .)
    NOT             reduce using rule 42 (expr -> NOT expr .)
    INC             reduce using rule 42 (expr -> NOT expr .)
    DEC             reduce using rule 42 (expr -> NOT expr .)
    RETURN          reduce using rule 42 (expr -> NOT expr .)
    read            reduce using rule 42 (expr -> NOT expr .)
    (               reduce using rule 42 (expr -> NOT expr .)
    $end            reduce using rule 42 (expr -> NOT expr .)
    )               reduce using rule 42 (expr -> NOT expr .)
    RPAREN          reduce using rule 42 (expr -> NOT expr .)
    ;               reduce using rule 42 (expr -> NOT expr .)
    RKEY            reduce using rule 42 (expr -> NOT expr .)
    ,               reduce using rule 42 (expr -> NOT expr .)
    ELSE            reduce using rule 42 (expr -> NOT expr .)
    EXPONENT        shift and go to state 48

  ! EXPONENT        [ reduce using rule 42 (expr -> NOT expr .) ]
  ! +               [ shift and go to state 49 ]
  ! -               [ shift and go to state 51 ]
  ! *               [ shift and go to state 50 ]
  ! /               [ shift and go to state 53 ]
  ! %               [ shift and go to state 47 ]
  ! OR              [ shift and go to state 58 ]
  ! AND             [ shift and go to state 45 ]
  ! LT              [ shift and go to state 55 ]
  ! GT              [ shift and go to state 46 ]
  ! LE              [ shift and go to state 56 ]
  ! GE              [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 57 ]
  ! NE              [ shift and go to state 54 ]


state 61

    (12) stmt -> procedure begin . LPAREN arglist RPAREN

    LPAREN          shift and go to state 94


state 62

    (49) expr -> INC ID .

    +               reduce using rule 49 (expr -> INC ID .)
    -               reduce using rule 49 (expr -> INC ID .)
    *               reduce using rule 49 (expr -> INC ID .)
    /               reduce using rule 49 (expr -> INC ID .)
    EXPONENT        reduce using rule 49 (expr -> INC ID .)
    %               reduce using rule 49 (expr -> INC ID .)
    OR              reduce using rule 49 (expr -> INC ID .)
    AND             reduce using rule 49 (expr -> INC ID .)
    LT              reduce using rule 49 (expr -> INC ID .)
    GT              reduce using rule 49 (expr -> INC ID .)
    LE              reduce using rule 49 (expr -> INC ID .)
    GE              reduce using rule 49 (expr -> INC ID .)
    EQ              reduce using rule 49 (expr -> INC ID .)
    NE              reduce using rule 49 (expr -> INC ID .)
    ID              reduce using rule 49 (expr -> INC ID .)
    procedure       reduce using rule 49 (expr -> INC ID .)
    print           reduce using rule 49 (expr -> INC ID .)
    while           reduce using rule 49 (expr -> INC ID .)
    for             reduce using rule 49 (expr -> INC ID .)
    if              reduce using rule 49 (expr -> INC ID .)
    LKEY            reduce using rule 49 (expr -> INC ID .)
    BLTIN           reduce using rule 49 (expr -> INC ID .)
    NUMBER          reduce using rule 49 (expr -> INC ID .)
    NOT             reduce using rule 49 (expr -> INC ID .)
    INC             reduce using rule 49 (expr -> INC ID .)
    DEC             reduce using rule 49 (expr -> INC ID .)
    RETURN          reduce using rule 49 (expr -> INC ID .)
    read            reduce using rule 49 (expr -> INC ID .)
    (               reduce using rule 49 (expr -> INC ID .)
    $end            reduce using rule 49 (expr -> INC ID .)
    )               reduce using rule 49 (expr -> INC ID .)
    RPAREN          reduce using rule 49 (expr -> INC ID .)
    ;               reduce using rule 49 (expr -> INC ID .)
    RKEY            reduce using rule 49 (expr -> INC ID .)
    ,               reduce using rule 49 (expr -> INC ID .)
    ELSE            reduce using rule 49 (expr -> INC ID .)


state 63

    (16) stmt -> if LPAREN cond . RPAREN stmt end
    (17) stmt -> if LPAREN cond . RPAREN stmt end ELSE stmt end

    RPAREN          shift and go to state 95


state 64

    (19) cond -> expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (35) expr -> expr . EXPONENT expr
    (39) expr -> expr . % expr
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr
    (43) expr -> expr . LT expr
    (44) expr -> expr . GT expr
    (45) expr -> expr . LE expr
    (46) expr -> expr . GE expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr

    RPAREN          reduce using rule 19 (cond -> expr .)
    ;               reduce using rule 19 (cond -> expr .)
    +               shift and go to state 49
    -               shift and go to state 51
    *               shift and go to state 50
    /               shift and go to state 53
    EXPONENT        shift and go to state 48
    %               shift and go to state 47
    OR              shift and go to state 58
    AND             shift and go to state 45
    LT              shift and go to state 55
    GT              shift and go to state 46
    LE              shift and go to state 56
    GE              shift and go to state 52
    EQ              shift and go to state 57
    NE              shift and go to state 54


state 65

    (15) stmt -> for LPAREN cond . ; cond ; cond RPAREN stmt end

    ;               shift and go to state 96


state 66

    (38) factor -> ( expr ) .

    +               reduce using rule 38 (factor -> ( expr ) .)
    -               reduce using rule 38 (factor -> ( expr ) .)
    *               reduce using rule 38 (factor -> ( expr ) .)
    /               reduce using rule 38 (factor -> ( expr ) .)
    EXPONENT        reduce using rule 38 (factor -> ( expr ) .)
    %               reduce using rule 38 (factor -> ( expr ) .)
    OR              reduce using rule 38 (factor -> ( expr ) .)
    AND             reduce using rule 38 (factor -> ( expr ) .)
    LT              reduce using rule 38 (factor -> ( expr ) .)
    GT              reduce using rule 38 (factor -> ( expr ) .)
    LE              reduce using rule 38 (factor -> ( expr ) .)
    GE              reduce using rule 38 (factor -> ( expr ) .)
    EQ              reduce using rule 38 (factor -> ( expr ) .)
    NE              reduce using rule 38 (factor -> ( expr ) .)
    RKEY            reduce using rule 38 (factor -> ( expr ) .)
    procedure       reduce using rule 38 (factor -> ( expr ) .)
    print           reduce using rule 38 (factor -> ( expr ) .)
    while           reduce using rule 38 (factor -> ( expr ) .)
    for             reduce using rule 38 (factor -> ( expr ) .)
    if              reduce using rule 38 (factor -> ( expr ) .)
    LKEY            reduce using rule 38 (factor -> ( expr ) .)
    ID              reduce using rule 38 (factor -> ( expr ) .)
    BLTIN           reduce using rule 38 (factor -> ( expr ) .)
    NUMBER          reduce using rule 38 (factor -> ( expr ) .)
    NOT             reduce using rule 38 (factor -> ( expr ) .)
    INC             reduce using rule 38 (factor -> ( expr ) .)
    DEC             reduce using rule 38 (factor -> ( expr ) .)
    RETURN          reduce using rule 38 (factor -> ( expr ) .)
    read            reduce using rule 38 (factor -> ( expr ) .)
    (               reduce using rule 38 (factor -> ( expr ) .)
    RPAREN          reduce using rule 38 (factor -> ( expr ) .)
    $end            reduce using rule 38 (factor -> ( expr ) .)
    )               reduce using rule 38 (factor -> ( expr ) .)
    ;               reduce using rule 38 (factor -> ( expr ) .)
    ,               reduce using rule 38 (factor -> ( expr ) .)
    ELSE            reduce using rule 38 (factor -> ( expr ) .)


state 67

    (54) prlist -> prlist , . expr
    (55) prlist -> prlist , . STRING
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    STRING          shift and go to state 97
    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    read            shift and go to state 13
    (               shift and go to state 7

    expr                           shift and go to state 98
    term                           shift and go to state 17
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 68

    (11) stmt -> return LPAREN expr . RPAREN
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (35) expr -> expr . EXPONENT expr
    (39) expr -> expr . % expr
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr
    (43) expr -> expr . LT expr
    (44) expr -> expr . GT expr
    (45) expr -> expr . LE expr
    (46) expr -> expr . GE expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr

    RPAREN          shift and go to state 99
    +               shift and go to state 49
    -               shift and go to state 51
    *               shift and go to state 50
    /               shift and go to state 53
    EXPONENT        shift and go to state 48
    %               shift and go to state 47
    OR              shift and go to state 58
    AND             shift and go to state 45
    LT              shift and go to state 55
    GT              shift and go to state 46
    LE              shift and go to state 56
    GE              shift and go to state 52
    EQ              shift and go to state 57
    NE              shift and go to state 54


state 69

    (18) stmt -> LKEY stmtlist RKEY .

    ELSE            reduce using rule 18 (stmt -> LKEY stmtlist RKEY .)
    ID              reduce using rule 18 (stmt -> LKEY stmtlist RKEY .)
    procedure       reduce using rule 18 (stmt -> LKEY stmtlist RKEY .)
    print           reduce using rule 18 (stmt -> LKEY stmtlist RKEY .)
    while           reduce using rule 18 (stmt -> LKEY stmtlist RKEY .)
    for             reduce using rule 18 (stmt -> LKEY stmtlist RKEY .)
    if              reduce using rule 18 (stmt -> LKEY stmtlist RKEY .)
    LKEY            reduce using rule 18 (stmt -> LKEY stmtlist RKEY .)
    BLTIN           reduce using rule 18 (stmt -> LKEY stmtlist RKEY .)
    NUMBER          reduce using rule 18 (stmt -> LKEY stmtlist RKEY .)
    NOT             reduce using rule 18 (stmt -> LKEY stmtlist RKEY .)
    INC             reduce using rule 18 (stmt -> LKEY stmtlist RKEY .)
    DEC             reduce using rule 18 (stmt -> LKEY stmtlist RKEY .)
    RETURN          reduce using rule 18 (stmt -> LKEY stmtlist RKEY .)
    read            reduce using rule 18 (stmt -> LKEY stmtlist RKEY .)
    (               reduce using rule 18 (stmt -> LKEY stmtlist RKEY .)
    $end            reduce using rule 18 (stmt -> LKEY stmtlist RKEY .)
    RKEY            reduce using rule 18 (stmt -> LKEY stmtlist RKEY .)


state 70

    (25) stmtlist -> stmtlist stmt .

    RKEY            reduce using rule 25 (stmtlist -> stmtlist stmt .)
    procedure       reduce using rule 25 (stmtlist -> stmtlist stmt .)
    print           reduce using rule 25 (stmtlist -> stmtlist stmt .)
    while           reduce using rule 25 (stmtlist -> stmtlist stmt .)
    for             reduce using rule 25 (stmtlist -> stmtlist stmt .)
    if              reduce using rule 25 (stmtlist -> stmtlist stmt .)
    LKEY            reduce using rule 25 (stmtlist -> stmtlist stmt .)
    ID              reduce using rule 25 (stmtlist -> stmtlist stmt .)
    BLTIN           reduce using rule 25 (stmtlist -> stmtlist stmt .)
    NUMBER          reduce using rule 25 (stmtlist -> stmtlist stmt .)
    NOT             reduce using rule 25 (stmtlist -> stmtlist stmt .)
    INC             reduce using rule 25 (stmtlist -> stmtlist stmt .)
    DEC             reduce using rule 25 (stmtlist -> stmtlist stmt .)
    RETURN          reduce using rule 25 (stmtlist -> stmtlist stmt .)
    read            reduce using rule 25 (stmtlist -> stmtlist stmt .)
    (               reduce using rule 25 (stmtlist -> stmtlist stmt .)


state 71

    (27) term -> read ( ID . )

    )               shift and go to state 100


state 72

    (28) expr -> BLTIN ( expr . )
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (35) expr -> expr . EXPONENT expr
    (39) expr -> expr . % expr
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr
    (43) expr -> expr . LT expr
    (44) expr -> expr . GT expr
    (45) expr -> expr . LE expr
    (46) expr -> expr . GE expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr

    )               shift and go to state 101
    +               shift and go to state 49
    -               shift and go to state 51
    *               shift and go to state 50
    /               shift and go to state 53
    EXPONENT        shift and go to state 48
    %               shift and go to state 47
    OR              shift and go to state 58
    AND             shift and go to state 45
    LT              shift and go to state 55
    GT              shift and go to state 46
    LE              shift and go to state 56
    GE              shift and go to state 52
    EQ              shift and go to state 57
    NE              shift and go to state 54


state 73

    (9) asgn -> ID MODEQ expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (35) expr -> expr . EXPONENT expr
    (39) expr -> expr . % expr
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr
    (43) expr -> expr . LT expr
    (44) expr -> expr . GT expr
    (45) expr -> expr . LE expr
    (46) expr -> expr . GE expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr

    ID              reduce using rule 9 (asgn -> ID MODEQ expr .)
    procedure       reduce using rule 9 (asgn -> ID MODEQ expr .)
    print           reduce using rule 9 (asgn -> ID MODEQ expr .)
    while           reduce using rule 9 (asgn -> ID MODEQ expr .)
    for             reduce using rule 9 (asgn -> ID MODEQ expr .)
    if              reduce using rule 9 (asgn -> ID MODEQ expr .)
    LKEY            reduce using rule 9 (asgn -> ID MODEQ expr .)
    BLTIN           reduce using rule 9 (asgn -> ID MODEQ expr .)
    NUMBER          reduce using rule 9 (asgn -> ID MODEQ expr .)
    NOT             reduce using rule 9 (asgn -> ID MODEQ expr .)
    INC             reduce using rule 9 (asgn -> ID MODEQ expr .)
    DEC             reduce using rule 9 (asgn -> ID MODEQ expr .)
    RETURN          reduce using rule 9 (asgn -> ID MODEQ expr .)
    read            reduce using rule 9 (asgn -> ID MODEQ expr .)
    (               reduce using rule 9 (asgn -> ID MODEQ expr .)
    $end            reduce using rule 9 (asgn -> ID MODEQ expr .)
    )               reduce using rule 9 (asgn -> ID MODEQ expr .)
    RPAREN          reduce using rule 9 (asgn -> ID MODEQ expr .)
    ;               reduce using rule 9 (asgn -> ID MODEQ expr .)
    RKEY            reduce using rule 9 (asgn -> ID MODEQ expr .)
    ,               reduce using rule 9 (asgn -> ID MODEQ expr .)
    ELSE            reduce using rule 9 (asgn -> ID MODEQ expr .)
    +               shift and go to state 49
    -               shift and go to state 51
    *               shift and go to state 50
    /               shift and go to state 53
    EXPONENT        shift and go to state 48
    %               shift and go to state 47
    OR              shift and go to state 58
    AND             shift and go to state 45
    LT              shift and go to state 55
    GT              shift and go to state 46
    LE              shift and go to state 56
    GE              shift and go to state 52
    EQ              shift and go to state 57
    NE              shift and go to state 54

  ! +               [ reduce using rule 9 (asgn -> ID MODEQ expr .) ]
  ! -               [ reduce using rule 9 (asgn -> ID MODEQ expr .) ]
  ! *               [ reduce using rule 9 (asgn -> ID MODEQ expr .) ]
  ! /               [ reduce using rule 9 (asgn -> ID MODEQ expr .) ]
  ! EXPONENT        [ reduce using rule 9 (asgn -> ID MODEQ expr .) ]
  ! %               [ reduce using rule 9 (asgn -> ID MODEQ expr .) ]
  ! OR              [ reduce using rule 9 (asgn -> ID MODEQ expr .) ]
  ! AND             [ reduce using rule 9 (asgn -> ID MODEQ expr .) ]
  ! LT              [ reduce using rule 9 (asgn -> ID MODEQ expr .) ]
  ! GT              [ reduce using rule 9 (asgn -> ID MODEQ expr .) ]
  ! LE              [ reduce using rule 9 (asgn -> ID MODEQ expr .) ]
  ! GE              [ reduce using rule 9 (asgn -> ID MODEQ expr .) ]
  ! EQ              [ reduce using rule 9 (asgn -> ID MODEQ expr .) ]
  ! NE              [ reduce using rule 9 (asgn -> ID MODEQ expr .) ]


state 74

    (6) asgn -> ID SUBEQ expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (35) expr -> expr . EXPONENT expr
    (39) expr -> expr . % expr
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr
    (43) expr -> expr . LT expr
    (44) expr -> expr . GT expr
    (45) expr -> expr . LE expr
    (46) expr -> expr . GE expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr

    ID              reduce using rule 6 (asgn -> ID SUBEQ expr .)
    procedure       reduce using rule 6 (asgn -> ID SUBEQ expr .)
    print           reduce using rule 6 (asgn -> ID SUBEQ expr .)
    while           reduce using rule 6 (asgn -> ID SUBEQ expr .)
    for             reduce using rule 6 (asgn -> ID SUBEQ expr .)
    if              reduce using rule 6 (asgn -> ID SUBEQ expr .)
    LKEY            reduce using rule 6 (asgn -> ID SUBEQ expr .)
    BLTIN           reduce using rule 6 (asgn -> ID SUBEQ expr .)
    NUMBER          reduce using rule 6 (asgn -> ID SUBEQ expr .)
    NOT             reduce using rule 6 (asgn -> ID SUBEQ expr .)
    INC             reduce using rule 6 (asgn -> ID SUBEQ expr .)
    DEC             reduce using rule 6 (asgn -> ID SUBEQ expr .)
    RETURN          reduce using rule 6 (asgn -> ID SUBEQ expr .)
    read            reduce using rule 6 (asgn -> ID SUBEQ expr .)
    (               reduce using rule 6 (asgn -> ID SUBEQ expr .)
    $end            reduce using rule 6 (asgn -> ID SUBEQ expr .)
    )               reduce using rule 6 (asgn -> ID SUBEQ expr .)
    RPAREN          reduce using rule 6 (asgn -> ID SUBEQ expr .)
    ;               reduce using rule 6 (asgn -> ID SUBEQ expr .)
    RKEY            reduce using rule 6 (asgn -> ID SUBEQ expr .)
    ,               reduce using rule 6 (asgn -> ID SUBEQ expr .)
    ELSE            reduce using rule 6 (asgn -> ID SUBEQ expr .)
    +               shift and go to state 49
    -               shift and go to state 51
    *               shift and go to state 50
    /               shift and go to state 53
    EXPONENT        shift and go to state 48
    %               shift and go to state 47
    OR              shift and go to state 58
    AND             shift and go to state 45
    LT              shift and go to state 55
    GT              shift and go to state 46
    LE              shift and go to state 56
    GE              shift and go to state 52
    EQ              shift and go to state 57
    NE              shift and go to state 54

  ! +               [ reduce using rule 6 (asgn -> ID SUBEQ expr .) ]
  ! -               [ reduce using rule 6 (asgn -> ID SUBEQ expr .) ]
  ! *               [ reduce using rule 6 (asgn -> ID SUBEQ expr .) ]
  ! /               [ reduce using rule 6 (asgn -> ID SUBEQ expr .) ]
  ! EXPONENT        [ reduce using rule 6 (asgn -> ID SUBEQ expr .) ]
  ! %               [ reduce using rule 6 (asgn -> ID SUBEQ expr .) ]
  ! OR              [ reduce using rule 6 (asgn -> ID SUBEQ expr .) ]
  ! AND             [ reduce using rule 6 (asgn -> ID SUBEQ expr .) ]
  ! LT              [ reduce using rule 6 (asgn -> ID SUBEQ expr .) ]
  ! GT              [ reduce using rule 6 (asgn -> ID SUBEQ expr .) ]
  ! LE              [ reduce using rule 6 (asgn -> ID SUBEQ expr .) ]
  ! GE              [ reduce using rule 6 (asgn -> ID SUBEQ expr .) ]
  ! EQ              [ reduce using rule 6 (asgn -> ID SUBEQ expr .) ]
  ! NE              [ reduce using rule 6 (asgn -> ID SUBEQ expr .) ]


state 75

    (7) asgn -> ID MULEQ expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (35) expr -> expr . EXPONENT expr
    (39) expr -> expr . % expr
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr
    (43) expr -> expr . LT expr
    (44) expr -> expr . GT expr
    (45) expr -> expr . LE expr
    (46) expr -> expr . GE expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr

    ID              reduce using rule 7 (asgn -> ID MULEQ expr .)
    procedure       reduce using rule 7 (asgn -> ID MULEQ expr .)
    print           reduce using rule 7 (asgn -> ID MULEQ expr .)
    while           reduce using rule 7 (asgn -> ID MULEQ expr .)
    for             reduce using rule 7 (asgn -> ID MULEQ expr .)
    if              reduce using rule 7 (asgn -> ID MULEQ expr .)
    LKEY            reduce using rule 7 (asgn -> ID MULEQ expr .)
    BLTIN           reduce using rule 7 (asgn -> ID MULEQ expr .)
    NUMBER          reduce using rule 7 (asgn -> ID MULEQ expr .)
    NOT             reduce using rule 7 (asgn -> ID MULEQ expr .)
    INC             reduce using rule 7 (asgn -> ID MULEQ expr .)
    DEC             reduce using rule 7 (asgn -> ID MULEQ expr .)
    RETURN          reduce using rule 7 (asgn -> ID MULEQ expr .)
    read            reduce using rule 7 (asgn -> ID MULEQ expr .)
    (               reduce using rule 7 (asgn -> ID MULEQ expr .)
    $end            reduce using rule 7 (asgn -> ID MULEQ expr .)
    )               reduce using rule 7 (asgn -> ID MULEQ expr .)
    RPAREN          reduce using rule 7 (asgn -> ID MULEQ expr .)
    ;               reduce using rule 7 (asgn -> ID MULEQ expr .)
    RKEY            reduce using rule 7 (asgn -> ID MULEQ expr .)
    ,               reduce using rule 7 (asgn -> ID MULEQ expr .)
    ELSE            reduce using rule 7 (asgn -> ID MULEQ expr .)
    +               shift and go to state 49
    -               shift and go to state 51
    *               shift and go to state 50
    /               shift and go to state 53
    EXPONENT        shift and go to state 48
    %               shift and go to state 47
    OR              shift and go to state 58
    AND             shift and go to state 45
    LT              shift and go to state 55
    GT              shift and go to state 46
    LE              shift and go to state 56
    GE              shift and go to state 52
    EQ              shift and go to state 57
    NE              shift and go to state 54

  ! +               [ reduce using rule 7 (asgn -> ID MULEQ expr .) ]
  ! -               [ reduce using rule 7 (asgn -> ID MULEQ expr .) ]
  ! *               [ reduce using rule 7 (asgn -> ID MULEQ expr .) ]
  ! /               [ reduce using rule 7 (asgn -> ID MULEQ expr .) ]
  ! EXPONENT        [ reduce using rule 7 (asgn -> ID MULEQ expr .) ]
  ! %               [ reduce using rule 7 (asgn -> ID MULEQ expr .) ]
  ! OR              [ reduce using rule 7 (asgn -> ID MULEQ expr .) ]
  ! AND             [ reduce using rule 7 (asgn -> ID MULEQ expr .) ]
  ! LT              [ reduce using rule 7 (asgn -> ID MULEQ expr .) ]
  ! GT              [ reduce using rule 7 (asgn -> ID MULEQ expr .) ]
  ! LE              [ reduce using rule 7 (asgn -> ID MULEQ expr .) ]
  ! GE              [ reduce using rule 7 (asgn -> ID MULEQ expr .) ]
  ! EQ              [ reduce using rule 7 (asgn -> ID MULEQ expr .) ]
  ! NE              [ reduce using rule 7 (asgn -> ID MULEQ expr .) ]


state 76

    (5) asgn -> ID ADDEQ expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (35) expr -> expr . EXPONENT expr
    (39) expr -> expr . % expr
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr
    (43) expr -> expr . LT expr
    (44) expr -> expr . GT expr
    (45) expr -> expr . LE expr
    (46) expr -> expr . GE expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr

    ID              reduce using rule 5 (asgn -> ID ADDEQ expr .)
    procedure       reduce using rule 5 (asgn -> ID ADDEQ expr .)
    print           reduce using rule 5 (asgn -> ID ADDEQ expr .)
    while           reduce using rule 5 (asgn -> ID ADDEQ expr .)
    for             reduce using rule 5 (asgn -> ID ADDEQ expr .)
    if              reduce using rule 5 (asgn -> ID ADDEQ expr .)
    LKEY            reduce using rule 5 (asgn -> ID ADDEQ expr .)
    BLTIN           reduce using rule 5 (asgn -> ID ADDEQ expr .)
    NUMBER          reduce using rule 5 (asgn -> ID ADDEQ expr .)
    NOT             reduce using rule 5 (asgn -> ID ADDEQ expr .)
    INC             reduce using rule 5 (asgn -> ID ADDEQ expr .)
    DEC             reduce using rule 5 (asgn -> ID ADDEQ expr .)
    RETURN          reduce using rule 5 (asgn -> ID ADDEQ expr .)
    read            reduce using rule 5 (asgn -> ID ADDEQ expr .)
    (               reduce using rule 5 (asgn -> ID ADDEQ expr .)
    $end            reduce using rule 5 (asgn -> ID ADDEQ expr .)
    )               reduce using rule 5 (asgn -> ID ADDEQ expr .)
    RPAREN          reduce using rule 5 (asgn -> ID ADDEQ expr .)
    ;               reduce using rule 5 (asgn -> ID ADDEQ expr .)
    RKEY            reduce using rule 5 (asgn -> ID ADDEQ expr .)
    ,               reduce using rule 5 (asgn -> ID ADDEQ expr .)
    ELSE            reduce using rule 5 (asgn -> ID ADDEQ expr .)
    +               shift and go to state 49
    -               shift and go to state 51
    *               shift and go to state 50
    /               shift and go to state 53
    EXPONENT        shift and go to state 48
    %               shift and go to state 47
    OR              shift and go to state 58
    AND             shift and go to state 45
    LT              shift and go to state 55
    GT              shift and go to state 46
    LE              shift and go to state 56
    GE              shift and go to state 52
    EQ              shift and go to state 57
    NE              shift and go to state 54

  ! +               [ reduce using rule 5 (asgn -> ID ADDEQ expr .) ]
  ! -               [ reduce using rule 5 (asgn -> ID ADDEQ expr .) ]
  ! *               [ reduce using rule 5 (asgn -> ID ADDEQ expr .) ]
  ! /               [ reduce using rule 5 (asgn -> ID ADDEQ expr .) ]
  ! EXPONENT        [ reduce using rule 5 (asgn -> ID ADDEQ expr .) ]
  ! %               [ reduce using rule 5 (asgn -> ID ADDEQ expr .) ]
  ! OR              [ reduce using rule 5 (asgn -> ID ADDEQ expr .) ]
  ! AND             [ reduce using rule 5 (asgn -> ID ADDEQ expr .) ]
  ! LT              [ reduce using rule 5 (asgn -> ID ADDEQ expr .) ]
  ! GT              [ reduce using rule 5 (asgn -> ID ADDEQ expr .) ]
  ! LE              [ reduce using rule 5 (asgn -> ID ADDEQ expr .) ]
  ! GE              [ reduce using rule 5 (asgn -> ID ADDEQ expr .) ]
  ! EQ              [ reduce using rule 5 (asgn -> ID ADDEQ expr .) ]
  ! NE              [ reduce using rule 5 (asgn -> ID ADDEQ expr .) ]


state 77

    (4) asgn -> ID = expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (35) expr -> expr . EXPONENT expr
    (39) expr -> expr . % expr
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr
    (43) expr -> expr . LT expr
    (44) expr -> expr . GT expr
    (45) expr -> expr . LE expr
    (46) expr -> expr . GE expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr

    ID              reduce using rule 4 (asgn -> ID = expr .)
    procedure       reduce using rule 4 (asgn -> ID = expr .)
    print           reduce using rule 4 (asgn -> ID = expr .)
    while           reduce using rule 4 (asgn -> ID = expr .)
    for             reduce using rule 4 (asgn -> ID = expr .)
    if              reduce using rule 4 (asgn -> ID = expr .)
    LKEY            reduce using rule 4 (asgn -> ID = expr .)
    BLTIN           reduce using rule 4 (asgn -> ID = expr .)
    NUMBER          reduce using rule 4 (asgn -> ID = expr .)
    NOT             reduce using rule 4 (asgn -> ID = expr .)
    INC             reduce using rule 4 (asgn -> ID = expr .)
    DEC             reduce using rule 4 (asgn -> ID = expr .)
    RETURN          reduce using rule 4 (asgn -> ID = expr .)
    read            reduce using rule 4 (asgn -> ID = expr .)
    (               reduce using rule 4 (asgn -> ID = expr .)
    $end            reduce using rule 4 (asgn -> ID = expr .)
    )               reduce using rule 4 (asgn -> ID = expr .)
    RPAREN          reduce using rule 4 (asgn -> ID = expr .)
    ;               reduce using rule 4 (asgn -> ID = expr .)
    RKEY            reduce using rule 4 (asgn -> ID = expr .)
    ,               reduce using rule 4 (asgn -> ID = expr .)
    ELSE            reduce using rule 4 (asgn -> ID = expr .)
    +               shift and go to state 49
    -               shift and go to state 51
    *               shift and go to state 50
    /               shift and go to state 53
    EXPONENT        shift and go to state 48
    %               shift and go to state 47
    OR              shift and go to state 58
    AND             shift and go to state 45
    LT              shift and go to state 55
    GT              shift and go to state 46
    LE              shift and go to state 56
    GE              shift and go to state 52
    EQ              shift and go to state 57
    NE              shift and go to state 54

  ! +               [ reduce using rule 4 (asgn -> ID = expr .) ]
  ! -               [ reduce using rule 4 (asgn -> ID = expr .) ]
  ! *               [ reduce using rule 4 (asgn -> ID = expr .) ]
  ! /               [ reduce using rule 4 (asgn -> ID = expr .) ]
  ! EXPONENT        [ reduce using rule 4 (asgn -> ID = expr .) ]
  ! %               [ reduce using rule 4 (asgn -> ID = expr .) ]
  ! OR              [ reduce using rule 4 (asgn -> ID = expr .) ]
  ! AND             [ reduce using rule 4 (asgn -> ID = expr .) ]
  ! LT              [ reduce using rule 4 (asgn -> ID = expr .) ]
  ! GT              [ reduce using rule 4 (asgn -> ID = expr .) ]
  ! LE              [ reduce using rule 4 (asgn -> ID = expr .) ]
  ! GE              [ reduce using rule 4 (asgn -> ID = expr .) ]
  ! EQ              [ reduce using rule 4 (asgn -> ID = expr .) ]
  ! NE              [ reduce using rule 4 (asgn -> ID = expr .) ]


state 78

    (8) asgn -> ID DIVEQ expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (35) expr -> expr . EXPONENT expr
    (39) expr -> expr . % expr
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr
    (43) expr -> expr . LT expr
    (44) expr -> expr . GT expr
    (45) expr -> expr . LE expr
    (46) expr -> expr . GE expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr

    ID              reduce using rule 8 (asgn -> ID DIVEQ expr .)
    procedure       reduce using rule 8 (asgn -> ID DIVEQ expr .)
    print           reduce using rule 8 (asgn -> ID DIVEQ expr .)
    while           reduce using rule 8 (asgn -> ID DIVEQ expr .)
    for             reduce using rule 8 (asgn -> ID DIVEQ expr .)
    if              reduce using rule 8 (asgn -> ID DIVEQ expr .)
    LKEY            reduce using rule 8 (asgn -> ID DIVEQ expr .)
    BLTIN           reduce using rule 8 (asgn -> ID DIVEQ expr .)
    NUMBER          reduce using rule 8 (asgn -> ID DIVEQ expr .)
    NOT             reduce using rule 8 (asgn -> ID DIVEQ expr .)
    INC             reduce using rule 8 (asgn -> ID DIVEQ expr .)
    DEC             reduce using rule 8 (asgn -> ID DIVEQ expr .)
    RETURN          reduce using rule 8 (asgn -> ID DIVEQ expr .)
    read            reduce using rule 8 (asgn -> ID DIVEQ expr .)
    (               reduce using rule 8 (asgn -> ID DIVEQ expr .)
    $end            reduce using rule 8 (asgn -> ID DIVEQ expr .)
    )               reduce using rule 8 (asgn -> ID DIVEQ expr .)
    RPAREN          reduce using rule 8 (asgn -> ID DIVEQ expr .)
    ;               reduce using rule 8 (asgn -> ID DIVEQ expr .)
    RKEY            reduce using rule 8 (asgn -> ID DIVEQ expr .)
    ,               reduce using rule 8 (asgn -> ID DIVEQ expr .)
    ELSE            reduce using rule 8 (asgn -> ID DIVEQ expr .)
    +               shift and go to state 49
    -               shift and go to state 51
    *               shift and go to state 50
    /               shift and go to state 53
    EXPONENT        shift and go to state 48
    %               shift and go to state 47
    OR              shift and go to state 58
    AND             shift and go to state 45
    LT              shift and go to state 55
    GT              shift and go to state 46
    LE              shift and go to state 56
    GE              shift and go to state 52
    EQ              shift and go to state 57
    NE              shift and go to state 54

  ! +               [ reduce using rule 8 (asgn -> ID DIVEQ expr .) ]
  ! -               [ reduce using rule 8 (asgn -> ID DIVEQ expr .) ]
  ! *               [ reduce using rule 8 (asgn -> ID DIVEQ expr .) ]
  ! /               [ reduce using rule 8 (asgn -> ID DIVEQ expr .) ]
  ! EXPONENT        [ reduce using rule 8 (asgn -> ID DIVEQ expr .) ]
  ! %               [ reduce using rule 8 (asgn -> ID DIVEQ expr .) ]
  ! OR              [ reduce using rule 8 (asgn -> ID DIVEQ expr .) ]
  ! AND             [ reduce using rule 8 (asgn -> ID DIVEQ expr .) ]
  ! LT              [ reduce using rule 8 (asgn -> ID DIVEQ expr .) ]
  ! GT              [ reduce using rule 8 (asgn -> ID DIVEQ expr .) ]
  ! LE              [ reduce using rule 8 (asgn -> ID DIVEQ expr .) ]
  ! GE              [ reduce using rule 8 (asgn -> ID DIVEQ expr .) ]
  ! EQ              [ reduce using rule 8 (asgn -> ID DIVEQ expr .) ]
  ! NE              [ reduce using rule 8 (asgn -> ID DIVEQ expr .) ]


state 79

    (41) expr -> expr AND expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (35) expr -> expr . EXPONENT expr
    (39) expr -> expr . % expr
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr
    (43) expr -> expr . LT expr
    (44) expr -> expr . GT expr
    (45) expr -> expr . LE expr
    (46) expr -> expr . GE expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr

    OR              reduce using rule 41 (expr -> expr AND expr .)
    AND             reduce using rule 41 (expr -> expr AND expr .)
    ID              reduce using rule 41 (expr -> expr AND expr .)
    procedure       reduce using rule 41 (expr -> expr AND expr .)
    print           reduce using rule 41 (expr -> expr AND expr .)
    while           reduce using rule 41 (expr -> expr AND expr .)
    for             reduce using rule 41 (expr -> expr AND expr .)
    if              reduce using rule 41 (expr -> expr AND expr .)
    LKEY            reduce using rule 41 (expr -> expr AND expr .)
    BLTIN           reduce using rule 41 (expr -> expr AND expr .)
    NUMBER          reduce using rule 41 (expr -> expr AND expr .)
    NOT             reduce using rule 41 (expr -> expr AND expr .)
    INC             reduce using rule 41 (expr -> expr AND expr .)
    DEC             reduce using rule 41 (expr -> expr AND expr .)
    RETURN          reduce using rule 41 (expr -> expr AND expr .)
    read            reduce using rule 41 (expr -> expr AND expr .)
    (               reduce using rule 41 (expr -> expr AND expr .)
    $end            reduce using rule 41 (expr -> expr AND expr .)
    )               reduce using rule 41 (expr -> expr AND expr .)
    RPAREN          reduce using rule 41 (expr -> expr AND expr .)
    ;               reduce using rule 41 (expr -> expr AND expr .)
    RKEY            reduce using rule 41 (expr -> expr AND expr .)
    ,               reduce using rule 41 (expr -> expr AND expr .)
    ELSE            reduce using rule 41 (expr -> expr AND expr .)
    +               shift and go to state 49
    -               shift and go to state 51
    *               shift and go to state 50
    /               shift and go to state 53
    EXPONENT        shift and go to state 48
    %               shift and go to state 47
    LT              shift and go to state 55
    GT              shift and go to state 46
    LE              shift and go to state 56
    GE              shift and go to state 52
    EQ              shift and go to state 57
    NE              shift and go to state 54

  ! +               [ reduce using rule 41 (expr -> expr AND expr .) ]
  ! -               [ reduce using rule 41 (expr -> expr AND expr .) ]
  ! *               [ reduce using rule 41 (expr -> expr AND expr .) ]
  ! /               [ reduce using rule 41 (expr -> expr AND expr .) ]
  ! EXPONENT        [ reduce using rule 41 (expr -> expr AND expr .) ]
  ! %               [ reduce using rule 41 (expr -> expr AND expr .) ]
  ! LT              [ reduce using rule 41 (expr -> expr AND expr .) ]
  ! GT              [ reduce using rule 41 (expr -> expr AND expr .) ]
  ! LE              [ reduce using rule 41 (expr -> expr AND expr .) ]
  ! GE              [ reduce using rule 41 (expr -> expr AND expr .) ]
  ! EQ              [ reduce using rule 41 (expr -> expr AND expr .) ]
  ! NE              [ reduce using rule 41 (expr -> expr AND expr .) ]
  ! OR              [ shift and go to state 58 ]
  ! AND             [ shift and go to state 45 ]


state 80

    (44) expr -> expr GT expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (35) expr -> expr . EXPONENT expr
    (39) expr -> expr . % expr
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr
    (43) expr -> expr . LT expr
    (44) expr -> expr . GT expr
    (45) expr -> expr . LE expr
    (46) expr -> expr . GE expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr

    OR              reduce using rule 44 (expr -> expr GT expr .)
    AND             reduce using rule 44 (expr -> expr GT expr .)
    LT              reduce using rule 44 (expr -> expr GT expr .)
    GT              reduce using rule 44 (expr -> expr GT expr .)
    LE              reduce using rule 44 (expr -> expr GT expr .)
    GE              reduce using rule 44 (expr -> expr GT expr .)
    EQ              reduce using rule 44 (expr -> expr GT expr .)
    NE              reduce using rule 44 (expr -> expr GT expr .)
    ID              reduce using rule 44 (expr -> expr GT expr .)
    procedure       reduce using rule 44 (expr -> expr GT expr .)
    print           reduce using rule 44 (expr -> expr GT expr .)
    while           reduce using rule 44 (expr -> expr GT expr .)
    for             reduce using rule 44 (expr -> expr GT expr .)
    if              reduce using rule 44 (expr -> expr GT expr .)
    LKEY            reduce using rule 44 (expr -> expr GT expr .)
    BLTIN           reduce using rule 44 (expr -> expr GT expr .)
    NUMBER          reduce using rule 44 (expr -> expr GT expr .)
    NOT             reduce using rule 44 (expr -> expr GT expr .)
    INC             reduce using rule 44 (expr -> expr GT expr .)
    DEC             reduce using rule 44 (expr -> expr GT expr .)
    RETURN          reduce using rule 44 (expr -> expr GT expr .)
    read            reduce using rule 44 (expr -> expr GT expr .)
    (               reduce using rule 44 (expr -> expr GT expr .)
    $end            reduce using rule 44 (expr -> expr GT expr .)
    )               reduce using rule 44 (expr -> expr GT expr .)
    RPAREN          reduce using rule 44 (expr -> expr GT expr .)
    ;               reduce using rule 44 (expr -> expr GT expr .)
    RKEY            reduce using rule 44 (expr -> expr GT expr .)
    ,               reduce using rule 44 (expr -> expr GT expr .)
    ELSE            reduce using rule 44 (expr -> expr GT expr .)
    +               shift and go to state 49
    -               shift and go to state 51
    *               shift and go to state 50
    /               shift and go to state 53
    EXPONENT        shift and go to state 48
    %               shift and go to state 47

  ! +               [ reduce using rule 44 (expr -> expr GT expr .) ]
  ! -               [ reduce using rule 44 (expr -> expr GT expr .) ]
  ! *               [ reduce using rule 44 (expr -> expr GT expr .) ]
  ! /               [ reduce using rule 44 (expr -> expr GT expr .) ]
  ! EXPONENT        [ reduce using rule 44 (expr -> expr GT expr .) ]
  ! %               [ reduce using rule 44 (expr -> expr GT expr .) ]
  ! OR              [ shift and go to state 58 ]
  ! AND             [ shift and go to state 45 ]
  ! LT              [ shift and go to state 55 ]
  ! GT              [ shift and go to state 46 ]
  ! LE              [ shift and go to state 56 ]
  ! GE              [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 57 ]
  ! NE              [ shift and go to state 54 ]


state 81

    (39) expr -> expr % expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (35) expr -> expr . EXPONENT expr
    (39) expr -> expr . % expr
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr
    (43) expr -> expr . LT expr
    (44) expr -> expr . GT expr
    (45) expr -> expr . LE expr
    (46) expr -> expr . GE expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr

    +               reduce using rule 39 (expr -> expr % expr .)
    -               reduce using rule 39 (expr -> expr % expr .)
    *               reduce using rule 39 (expr -> expr % expr .)
    /               reduce using rule 39 (expr -> expr % expr .)
    %               reduce using rule 39 (expr -> expr % expr .)
    OR              reduce using rule 39 (expr -> expr % expr .)
    AND             reduce using rule 39 (expr -> expr % expr .)
    LT              reduce using rule 39 (expr -> expr % expr .)
    GT              reduce using rule 39 (expr -> expr % expr .)
    LE              reduce using rule 39 (expr -> expr % expr .)
    GE              reduce using rule 39 (expr -> expr % expr .)
    EQ              reduce using rule 39 (expr -> expr % expr .)
    NE              reduce using rule 39 (expr -> expr % expr .)
    ID              reduce using rule 39 (expr -> expr % expr .)
    procedure       reduce using rule 39 (expr -> expr % expr .)
    print           reduce using rule 39 (expr -> expr % expr .)
    while           reduce using rule 39 (expr -> expr % expr .)
    for             reduce using rule 39 (expr -> expr % expr .)
    if              reduce using rule 39 (expr -> expr % expr .)
    LKEY            reduce using rule 39 (expr -> expr % expr .)
    BLTIN           reduce using rule 39 (expr -> expr % expr .)
    NUMBER          reduce using rule 39 (expr -> expr % expr .)
    NOT             reduce using rule 39 (expr -> expr % expr .)
    INC             reduce using rule 39 (expr -> expr % expr .)
    DEC             reduce using rule 39 (expr -> expr % expr .)
    RETURN          reduce using rule 39 (expr -> expr % expr .)
    read            reduce using rule 39 (expr -> expr % expr .)
    (               reduce using rule 39 (expr -> expr % expr .)
    $end            reduce using rule 39 (expr -> expr % expr .)
    )               reduce using rule 39 (expr -> expr % expr .)
    RPAREN          reduce using rule 39 (expr -> expr % expr .)
    ;               reduce using rule 39 (expr -> expr % expr .)
    RKEY            reduce using rule 39 (expr -> expr % expr .)
    ,               reduce using rule 39 (expr -> expr % expr .)
    ELSE            reduce using rule 39 (expr -> expr % expr .)
    EXPONENT        shift and go to state 48

  ! EXPONENT        [ reduce using rule 39 (expr -> expr % expr .) ]
  ! +               [ shift and go to state 49 ]
  ! -               [ shift and go to state 51 ]
  ! *               [ shift and go to state 50 ]
  ! /               [ shift and go to state 53 ]
  ! %               [ shift and go to state 47 ]
  ! OR              [ shift and go to state 58 ]
  ! AND             [ shift and go to state 45 ]
  ! LT              [ shift and go to state 55 ]
  ! GT              [ shift and go to state 46 ]
  ! LE              [ shift and go to state 56 ]
  ! GE              [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 57 ]
  ! NE              [ shift and go to state 54 ]


state 82

    (35) expr -> expr EXPONENT expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (35) expr -> expr . EXPONENT expr
    (39) expr -> expr . % expr
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr
    (43) expr -> expr . LT expr
    (44) expr -> expr . GT expr
    (45) expr -> expr . LE expr
    (46) expr -> expr . GE expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr

    +               reduce using rule 35 (expr -> expr EXPONENT expr .)
    -               reduce using rule 35 (expr -> expr EXPONENT expr .)
    *               reduce using rule 35 (expr -> expr EXPONENT expr .)
    /               reduce using rule 35 (expr -> expr EXPONENT expr .)
    %               reduce using rule 35 (expr -> expr EXPONENT expr .)
    OR              reduce using rule 35 (expr -> expr EXPONENT expr .)
    AND             reduce using rule 35 (expr -> expr EXPONENT expr .)
    LT              reduce using rule 35 (expr -> expr EXPONENT expr .)
    GT              reduce using rule 35 (expr -> expr EXPONENT expr .)
    LE              reduce using rule 35 (expr -> expr EXPONENT expr .)
    GE              reduce using rule 35 (expr -> expr EXPONENT expr .)
    EQ              reduce using rule 35 (expr -> expr EXPONENT expr .)
    NE              reduce using rule 35 (expr -> expr EXPONENT expr .)
    ID              reduce using rule 35 (expr -> expr EXPONENT expr .)
    procedure       reduce using rule 35 (expr -> expr EXPONENT expr .)
    print           reduce using rule 35 (expr -> expr EXPONENT expr .)
    while           reduce using rule 35 (expr -> expr EXPONENT expr .)
    for             reduce using rule 35 (expr -> expr EXPONENT expr .)
    if              reduce using rule 35 (expr -> expr EXPONENT expr .)
    LKEY            reduce using rule 35 (expr -> expr EXPONENT expr .)
    BLTIN           reduce using rule 35 (expr -> expr EXPONENT expr .)
    NUMBER          reduce using rule 35 (expr -> expr EXPONENT expr .)
    NOT             reduce using rule 35 (expr -> expr EXPONENT expr .)
    INC             reduce using rule 35 (expr -> expr EXPONENT expr .)
    DEC             reduce using rule 35 (expr -> expr EXPONENT expr .)
    RETURN          reduce using rule 35 (expr -> expr EXPONENT expr .)
    read            reduce using rule 35 (expr -> expr EXPONENT expr .)
    (               reduce using rule 35 (expr -> expr EXPONENT expr .)
    $end            reduce using rule 35 (expr -> expr EXPONENT expr .)
    )               reduce using rule 35 (expr -> expr EXPONENT expr .)
    RPAREN          reduce using rule 35 (expr -> expr EXPONENT expr .)
    ;               reduce using rule 35 (expr -> expr EXPONENT expr .)
    RKEY            reduce using rule 35 (expr -> expr EXPONENT expr .)
    ,               reduce using rule 35 (expr -> expr EXPONENT expr .)
    ELSE            reduce using rule 35 (expr -> expr EXPONENT expr .)
    EXPONENT        shift and go to state 48

  ! EXPONENT        [ reduce using rule 35 (expr -> expr EXPONENT expr .) ]
  ! +               [ shift and go to state 49 ]
  ! -               [ shift and go to state 51 ]
  ! *               [ shift and go to state 50 ]
  ! /               [ shift and go to state 53 ]
  ! %               [ shift and go to state 47 ]
  ! OR              [ shift and go to state 58 ]
  ! AND             [ shift and go to state 45 ]
  ! LT              [ shift and go to state 55 ]
  ! GT              [ shift and go to state 46 ]
  ! LE              [ shift and go to state 56 ]
  ! GE              [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 57 ]
  ! NE              [ shift and go to state 54 ]


state 83

    (30) expr -> expr + expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (35) expr -> expr . EXPONENT expr
    (39) expr -> expr . % expr
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr
    (43) expr -> expr . LT expr
    (44) expr -> expr . GT expr
    (45) expr -> expr . LE expr
    (46) expr -> expr . GE expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr

    +               reduce using rule 30 (expr -> expr + expr .)
    -               reduce using rule 30 (expr -> expr + expr .)
    OR              reduce using rule 30 (expr -> expr + expr .)
    AND             reduce using rule 30 (expr -> expr + expr .)
    LT              reduce using rule 30 (expr -> expr + expr .)
    GT              reduce using rule 30 (expr -> expr + expr .)
    LE              reduce using rule 30 (expr -> expr + expr .)
    GE              reduce using rule 30 (expr -> expr + expr .)
    EQ              reduce using rule 30 (expr -> expr + expr .)
    NE              reduce using rule 30 (expr -> expr + expr .)
    ID              reduce using rule 30 (expr -> expr + expr .)
    procedure       reduce using rule 30 (expr -> expr + expr .)
    print           reduce using rule 30 (expr -> expr + expr .)
    while           reduce using rule 30 (expr -> expr + expr .)
    for             reduce using rule 30 (expr -> expr + expr .)
    if              reduce using rule 30 (expr -> expr + expr .)
    LKEY            reduce using rule 30 (expr -> expr + expr .)
    BLTIN           reduce using rule 30 (expr -> expr + expr .)
    NUMBER          reduce using rule 30 (expr -> expr + expr .)
    NOT             reduce using rule 30 (expr -> expr + expr .)
    INC             reduce using rule 30 (expr -> expr + expr .)
    DEC             reduce using rule 30 (expr -> expr + expr .)
    RETURN          reduce using rule 30 (expr -> expr + expr .)
    read            reduce using rule 30 (expr -> expr + expr .)
    (               reduce using rule 30 (expr -> expr + expr .)
    $end            reduce using rule 30 (expr -> expr + expr .)
    )               reduce using rule 30 (expr -> expr + expr .)
    RPAREN          reduce using rule 30 (expr -> expr + expr .)
    ;               reduce using rule 30 (expr -> expr + expr .)
    RKEY            reduce using rule 30 (expr -> expr + expr .)
    ,               reduce using rule 30 (expr -> expr + expr .)
    ELSE            reduce using rule 30 (expr -> expr + expr .)
    *               shift and go to state 50
    /               shift and go to state 53
    EXPONENT        shift and go to state 48
    %               shift and go to state 47

  ! *               [ reduce using rule 30 (expr -> expr + expr .) ]
  ! /               [ reduce using rule 30 (expr -> expr + expr .) ]
  ! EXPONENT        [ reduce using rule 30 (expr -> expr + expr .) ]
  ! %               [ reduce using rule 30 (expr -> expr + expr .) ]
  ! +               [ shift and go to state 49 ]
  ! -               [ shift and go to state 51 ]
  ! OR              [ shift and go to state 58 ]
  ! AND             [ shift and go to state 45 ]
  ! LT              [ shift and go to state 55 ]
  ! GT              [ shift and go to state 46 ]
  ! LE              [ shift and go to state 56 ]
  ! GE              [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 57 ]
  ! NE              [ shift and go to state 54 ]


state 84

    (32) expr -> expr * expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (35) expr -> expr . EXPONENT expr
    (39) expr -> expr . % expr
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr
    (43) expr -> expr . LT expr
    (44) expr -> expr . GT expr
    (45) expr -> expr . LE expr
    (46) expr -> expr . GE expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr

    +               reduce using rule 32 (expr -> expr * expr .)
    -               reduce using rule 32 (expr -> expr * expr .)
    *               reduce using rule 32 (expr -> expr * expr .)
    /               reduce using rule 32 (expr -> expr * expr .)
    %               reduce using rule 32 (expr -> expr * expr .)
    OR              reduce using rule 32 (expr -> expr * expr .)
    AND             reduce using rule 32 (expr -> expr * expr .)
    LT              reduce using rule 32 (expr -> expr * expr .)
    GT              reduce using rule 32 (expr -> expr * expr .)
    LE              reduce using rule 32 (expr -> expr * expr .)
    GE              reduce using rule 32 (expr -> expr * expr .)
    EQ              reduce using rule 32 (expr -> expr * expr .)
    NE              reduce using rule 32 (expr -> expr * expr .)
    ID              reduce using rule 32 (expr -> expr * expr .)
    procedure       reduce using rule 32 (expr -> expr * expr .)
    print           reduce using rule 32 (expr -> expr * expr .)
    while           reduce using rule 32 (expr -> expr * expr .)
    for             reduce using rule 32 (expr -> expr * expr .)
    if              reduce using rule 32 (expr -> expr * expr .)
    LKEY            reduce using rule 32 (expr -> expr * expr .)
    BLTIN           reduce using rule 32 (expr -> expr * expr .)
    NUMBER          reduce using rule 32 (expr -> expr * expr .)
    NOT             reduce using rule 32 (expr -> expr * expr .)
    INC             reduce using rule 32 (expr -> expr * expr .)
    DEC             reduce using rule 32 (expr -> expr * expr .)
    RETURN          reduce using rule 32 (expr -> expr * expr .)
    read            reduce using rule 32 (expr -> expr * expr .)
    (               reduce using rule 32 (expr -> expr * expr .)
    $end            reduce using rule 32 (expr -> expr * expr .)
    )               reduce using rule 32 (expr -> expr * expr .)
    RPAREN          reduce using rule 32 (expr -> expr * expr .)
    ;               reduce using rule 32 (expr -> expr * expr .)
    RKEY            reduce using rule 32 (expr -> expr * expr .)
    ,               reduce using rule 32 (expr -> expr * expr .)
    ELSE            reduce using rule 32 (expr -> expr * expr .)
    EXPONENT        shift and go to state 48

  ! EXPONENT        [ reduce using rule 32 (expr -> expr * expr .) ]
  ! +               [ shift and go to state 49 ]
  ! -               [ shift and go to state 51 ]
  ! *               [ shift and go to state 50 ]
  ! /               [ shift and go to state 53 ]
  ! %               [ shift and go to state 47 ]
  ! OR              [ shift and go to state 58 ]
  ! AND             [ shift and go to state 45 ]
  ! LT              [ shift and go to state 55 ]
  ! GT              [ shift and go to state 46 ]
  ! LE              [ shift and go to state 56 ]
  ! GE              [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 57 ]
  ! NE              [ shift and go to state 54 ]


state 85

    (31) expr -> expr - expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (35) expr -> expr . EXPONENT expr
    (39) expr -> expr . % expr
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr
    (43) expr -> expr . LT expr
    (44) expr -> expr . GT expr
    (45) expr -> expr . LE expr
    (46) expr -> expr . GE expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr

    +               reduce using rule 31 (expr -> expr - expr .)
    -               reduce using rule 31 (expr -> expr - expr .)
    OR              reduce using rule 31 (expr -> expr - expr .)
    AND             reduce using rule 31 (expr -> expr - expr .)
    LT              reduce using rule 31 (expr -> expr - expr .)
    GT              reduce using rule 31 (expr -> expr - expr .)
    LE              reduce using rule 31 (expr -> expr - expr .)
    GE              reduce using rule 31 (expr -> expr - expr .)
    EQ              reduce using rule 31 (expr -> expr - expr .)
    NE              reduce using rule 31 (expr -> expr - expr .)
    ID              reduce using rule 31 (expr -> expr - expr .)
    procedure       reduce using rule 31 (expr -> expr - expr .)
    print           reduce using rule 31 (expr -> expr - expr .)
    while           reduce using rule 31 (expr -> expr - expr .)
    for             reduce using rule 31 (expr -> expr - expr .)
    if              reduce using rule 31 (expr -> expr - expr .)
    LKEY            reduce using rule 31 (expr -> expr - expr .)
    BLTIN           reduce using rule 31 (expr -> expr - expr .)
    NUMBER          reduce using rule 31 (expr -> expr - expr .)
    NOT             reduce using rule 31 (expr -> expr - expr .)
    INC             reduce using rule 31 (expr -> expr - expr .)
    DEC             reduce using rule 31 (expr -> expr - expr .)
    RETURN          reduce using rule 31 (expr -> expr - expr .)
    read            reduce using rule 31 (expr -> expr - expr .)
    (               reduce using rule 31 (expr -> expr - expr .)
    $end            reduce using rule 31 (expr -> expr - expr .)
    )               reduce using rule 31 (expr -> expr - expr .)
    RPAREN          reduce using rule 31 (expr -> expr - expr .)
    ;               reduce using rule 31 (expr -> expr - expr .)
    RKEY            reduce using rule 31 (expr -> expr - expr .)
    ,               reduce using rule 31 (expr -> expr - expr .)
    ELSE            reduce using rule 31 (expr -> expr - expr .)
    *               shift and go to state 50
    /               shift and go to state 53
    EXPONENT        shift and go to state 48
    %               shift and go to state 47

  ! *               [ reduce using rule 31 (expr -> expr - expr .) ]
  ! /               [ reduce using rule 31 (expr -> expr - expr .) ]
  ! EXPONENT        [ reduce using rule 31 (expr -> expr - expr .) ]
  ! %               [ reduce using rule 31 (expr -> expr - expr .) ]
  ! +               [ shift and go to state 49 ]
  ! -               [ shift and go to state 51 ]
  ! OR              [ shift and go to state 58 ]
  ! AND             [ shift and go to state 45 ]
  ! LT              [ shift and go to state 55 ]
  ! GT              [ shift and go to state 46 ]
  ! LE              [ shift and go to state 56 ]
  ! GE              [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 57 ]
  ! NE              [ shift and go to state 54 ]


state 86

    (46) expr -> expr GE expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (35) expr -> expr . EXPONENT expr
    (39) expr -> expr . % expr
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr
    (43) expr -> expr . LT expr
    (44) expr -> expr . GT expr
    (45) expr -> expr . LE expr
    (46) expr -> expr . GE expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr

    OR              reduce using rule 46 (expr -> expr GE expr .)
    AND             reduce using rule 46 (expr -> expr GE expr .)
    LT              reduce using rule 46 (expr -> expr GE expr .)
    GT              reduce using rule 46 (expr -> expr GE expr .)
    LE              reduce using rule 46 (expr -> expr GE expr .)
    GE              reduce using rule 46 (expr -> expr GE expr .)
    EQ              reduce using rule 46 (expr -> expr GE expr .)
    NE              reduce using rule 46 (expr -> expr GE expr .)
    ID              reduce using rule 46 (expr -> expr GE expr .)
    procedure       reduce using rule 46 (expr -> expr GE expr .)
    print           reduce using rule 46 (expr -> expr GE expr .)
    while           reduce using rule 46 (expr -> expr GE expr .)
    for             reduce using rule 46 (expr -> expr GE expr .)
    if              reduce using rule 46 (expr -> expr GE expr .)
    LKEY            reduce using rule 46 (expr -> expr GE expr .)
    BLTIN           reduce using rule 46 (expr -> expr GE expr .)
    NUMBER          reduce using rule 46 (expr -> expr GE expr .)
    NOT             reduce using rule 46 (expr -> expr GE expr .)
    INC             reduce using rule 46 (expr -> expr GE expr .)
    DEC             reduce using rule 46 (expr -> expr GE expr .)
    RETURN          reduce using rule 46 (expr -> expr GE expr .)
    read            reduce using rule 46 (expr -> expr GE expr .)
    (               reduce using rule 46 (expr -> expr GE expr .)
    $end            reduce using rule 46 (expr -> expr GE expr .)
    )               reduce using rule 46 (expr -> expr GE expr .)
    RPAREN          reduce using rule 46 (expr -> expr GE expr .)
    ;               reduce using rule 46 (expr -> expr GE expr .)
    RKEY            reduce using rule 46 (expr -> expr GE expr .)
    ,               reduce using rule 46 (expr -> expr GE expr .)
    ELSE            reduce using rule 46 (expr -> expr GE expr .)
    +               shift and go to state 49
    -               shift and go to state 51
    *               shift and go to state 50
    /               shift and go to state 53
    EXPONENT        shift and go to state 48
    %               shift and go to state 47

  ! +               [ reduce using rule 46 (expr -> expr GE expr .) ]
  ! -               [ reduce using rule 46 (expr -> expr GE expr .) ]
  ! *               [ reduce using rule 46 (expr -> expr GE expr .) ]
  ! /               [ reduce using rule 46 (expr -> expr GE expr .) ]
  ! EXPONENT        [ reduce using rule 46 (expr -> expr GE expr .) ]
  ! %               [ reduce using rule 46 (expr -> expr GE expr .) ]
  ! OR              [ shift and go to state 58 ]
  ! AND             [ shift and go to state 45 ]
  ! LT              [ shift and go to state 55 ]
  ! GT              [ shift and go to state 46 ]
  ! LE              [ shift and go to state 56 ]
  ! GE              [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 57 ]
  ! NE              [ shift and go to state 54 ]


state 87

    (33) expr -> expr / expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (35) expr -> expr . EXPONENT expr
    (39) expr -> expr . % expr
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr
    (43) expr -> expr . LT expr
    (44) expr -> expr . GT expr
    (45) expr -> expr . LE expr
    (46) expr -> expr . GE expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr

    +               reduce using rule 33 (expr -> expr / expr .)
    -               reduce using rule 33 (expr -> expr / expr .)
    *               reduce using rule 33 (expr -> expr / expr .)
    /               reduce using rule 33 (expr -> expr / expr .)
    %               reduce using rule 33 (expr -> expr / expr .)
    OR              reduce using rule 33 (expr -> expr / expr .)
    AND             reduce using rule 33 (expr -> expr / expr .)
    LT              reduce using rule 33 (expr -> expr / expr .)
    GT              reduce using rule 33 (expr -> expr / expr .)
    LE              reduce using rule 33 (expr -> expr / expr .)
    GE              reduce using rule 33 (expr -> expr / expr .)
    EQ              reduce using rule 33 (expr -> expr / expr .)
    NE              reduce using rule 33 (expr -> expr / expr .)
    ID              reduce using rule 33 (expr -> expr / expr .)
    procedure       reduce using rule 33 (expr -> expr / expr .)
    print           reduce using rule 33 (expr -> expr / expr .)
    while           reduce using rule 33 (expr -> expr / expr .)
    for             reduce using rule 33 (expr -> expr / expr .)
    if              reduce using rule 33 (expr -> expr / expr .)
    LKEY            reduce using rule 33 (expr -> expr / expr .)
    BLTIN           reduce using rule 33 (expr -> expr / expr .)
    NUMBER          reduce using rule 33 (expr -> expr / expr .)
    NOT             reduce using rule 33 (expr -> expr / expr .)
    INC             reduce using rule 33 (expr -> expr / expr .)
    DEC             reduce using rule 33 (expr -> expr / expr .)
    RETURN          reduce using rule 33 (expr -> expr / expr .)
    read            reduce using rule 33 (expr -> expr / expr .)
    (               reduce using rule 33 (expr -> expr / expr .)
    $end            reduce using rule 33 (expr -> expr / expr .)
    )               reduce using rule 33 (expr -> expr / expr .)
    RPAREN          reduce using rule 33 (expr -> expr / expr .)
    ;               reduce using rule 33 (expr -> expr / expr .)
    RKEY            reduce using rule 33 (expr -> expr / expr .)
    ,               reduce using rule 33 (expr -> expr / expr .)
    ELSE            reduce using rule 33 (expr -> expr / expr .)
    EXPONENT        shift and go to state 48

  ! EXPONENT        [ reduce using rule 33 (expr -> expr / expr .) ]
  ! +               [ shift and go to state 49 ]
  ! -               [ shift and go to state 51 ]
  ! *               [ shift and go to state 50 ]
  ! /               [ shift and go to state 53 ]
  ! %               [ shift and go to state 47 ]
  ! OR              [ shift and go to state 58 ]
  ! AND             [ shift and go to state 45 ]
  ! LT              [ shift and go to state 55 ]
  ! GT              [ shift and go to state 46 ]
  ! LE              [ shift and go to state 56 ]
  ! GE              [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 57 ]
  ! NE              [ shift and go to state 54 ]


state 88

    (48) expr -> expr NE expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (35) expr -> expr . EXPONENT expr
    (39) expr -> expr . % expr
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr
    (43) expr -> expr . LT expr
    (44) expr -> expr . GT expr
    (45) expr -> expr . LE expr
    (46) expr -> expr . GE expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr

    OR              reduce using rule 48 (expr -> expr NE expr .)
    AND             reduce using rule 48 (expr -> expr NE expr .)
    LT              reduce using rule 48 (expr -> expr NE expr .)
    GT              reduce using rule 48 (expr -> expr NE expr .)
    LE              reduce using rule 48 (expr -> expr NE expr .)
    GE              reduce using rule 48 (expr -> expr NE expr .)
    EQ              reduce using rule 48 (expr -> expr NE expr .)
    NE              reduce using rule 48 (expr -> expr NE expr .)
    ID              reduce using rule 48 (expr -> expr NE expr .)
    procedure       reduce using rule 48 (expr -> expr NE expr .)
    print           reduce using rule 48 (expr -> expr NE expr .)
    while           reduce using rule 48 (expr -> expr NE expr .)
    for             reduce using rule 48 (expr -> expr NE expr .)
    if              reduce using rule 48 (expr -> expr NE expr .)
    LKEY            reduce using rule 48 (expr -> expr NE expr .)
    BLTIN           reduce using rule 48 (expr -> expr NE expr .)
    NUMBER          reduce using rule 48 (expr -> expr NE expr .)
    NOT             reduce using rule 48 (expr -> expr NE expr .)
    INC             reduce using rule 48 (expr -> expr NE expr .)
    DEC             reduce using rule 48 (expr -> expr NE expr .)
    RETURN          reduce using rule 48 (expr -> expr NE expr .)
    read            reduce using rule 48 (expr -> expr NE expr .)
    (               reduce using rule 48 (expr -> expr NE expr .)
    $end            reduce using rule 48 (expr -> expr NE expr .)
    )               reduce using rule 48 (expr -> expr NE expr .)
    RPAREN          reduce using rule 48 (expr -> expr NE expr .)
    ;               reduce using rule 48 (expr -> expr NE expr .)
    RKEY            reduce using rule 48 (expr -> expr NE expr .)
    ,               reduce using rule 48 (expr -> expr NE expr .)
    ELSE            reduce using rule 48 (expr -> expr NE expr .)
    +               shift and go to state 49
    -               shift and go to state 51
    *               shift and go to state 50
    /               shift and go to state 53
    EXPONENT        shift and go to state 48
    %               shift and go to state 47

  ! +               [ reduce using rule 48 (expr -> expr NE expr .) ]
  ! -               [ reduce using rule 48 (expr -> expr NE expr .) ]
  ! *               [ reduce using rule 48 (expr -> expr NE expr .) ]
  ! /               [ reduce using rule 48 (expr -> expr NE expr .) ]
  ! EXPONENT        [ reduce using rule 48 (expr -> expr NE expr .) ]
  ! %               [ reduce using rule 48 (expr -> expr NE expr .) ]
  ! OR              [ shift and go to state 58 ]
  ! AND             [ shift and go to state 45 ]
  ! LT              [ shift and go to state 55 ]
  ! GT              [ shift and go to state 46 ]
  ! LE              [ shift and go to state 56 ]
  ! GE              [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 57 ]
  ! NE              [ shift and go to state 54 ]


state 89

    (43) expr -> expr LT expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (35) expr -> expr . EXPONENT expr
    (39) expr -> expr . % expr
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr
    (43) expr -> expr . LT expr
    (44) expr -> expr . GT expr
    (45) expr -> expr . LE expr
    (46) expr -> expr . GE expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr

    OR              reduce using rule 43 (expr -> expr LT expr .)
    AND             reduce using rule 43 (expr -> expr LT expr .)
    LT              reduce using rule 43 (expr -> expr LT expr .)
    GT              reduce using rule 43 (expr -> expr LT expr .)
    LE              reduce using rule 43 (expr -> expr LT expr .)
    GE              reduce using rule 43 (expr -> expr LT expr .)
    EQ              reduce using rule 43 (expr -> expr LT expr .)
    NE              reduce using rule 43 (expr -> expr LT expr .)
    ID              reduce using rule 43 (expr -> expr LT expr .)
    procedure       reduce using rule 43 (expr -> expr LT expr .)
    print           reduce using rule 43 (expr -> expr LT expr .)
    while           reduce using rule 43 (expr -> expr LT expr .)
    for             reduce using rule 43 (expr -> expr LT expr .)
    if              reduce using rule 43 (expr -> expr LT expr .)
    LKEY            reduce using rule 43 (expr -> expr LT expr .)
    BLTIN           reduce using rule 43 (expr -> expr LT expr .)
    NUMBER          reduce using rule 43 (expr -> expr LT expr .)
    NOT             reduce using rule 43 (expr -> expr LT expr .)
    INC             reduce using rule 43 (expr -> expr LT expr .)
    DEC             reduce using rule 43 (expr -> expr LT expr .)
    RETURN          reduce using rule 43 (expr -> expr LT expr .)
    read            reduce using rule 43 (expr -> expr LT expr .)
    (               reduce using rule 43 (expr -> expr LT expr .)
    $end            reduce using rule 43 (expr -> expr LT expr .)
    )               reduce using rule 43 (expr -> expr LT expr .)
    RPAREN          reduce using rule 43 (expr -> expr LT expr .)
    ;               reduce using rule 43 (expr -> expr LT expr .)
    RKEY            reduce using rule 43 (expr -> expr LT expr .)
    ,               reduce using rule 43 (expr -> expr LT expr .)
    ELSE            reduce using rule 43 (expr -> expr LT expr .)
    +               shift and go to state 49
    -               shift and go to state 51
    *               shift and go to state 50
    /               shift and go to state 53
    EXPONENT        shift and go to state 48
    %               shift and go to state 47

  ! +               [ reduce using rule 43 (expr -> expr LT expr .) ]
  ! -               [ reduce using rule 43 (expr -> expr LT expr .) ]
  ! *               [ reduce using rule 43 (expr -> expr LT expr .) ]
  ! /               [ reduce using rule 43 (expr -> expr LT expr .) ]
  ! EXPONENT        [ reduce using rule 43 (expr -> expr LT expr .) ]
  ! %               [ reduce using rule 43 (expr -> expr LT expr .) ]
  ! OR              [ shift and go to state 58 ]
  ! AND             [ shift and go to state 45 ]
  ! LT              [ shift and go to state 55 ]
  ! GT              [ shift and go to state 46 ]
  ! LE              [ shift and go to state 56 ]
  ! GE              [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 57 ]
  ! NE              [ shift and go to state 54 ]


state 90

    (45) expr -> expr LE expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (35) expr -> expr . EXPONENT expr
    (39) expr -> expr . % expr
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr
    (43) expr -> expr . LT expr
    (44) expr -> expr . GT expr
    (45) expr -> expr . LE expr
    (46) expr -> expr . GE expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr

    OR              reduce using rule 45 (expr -> expr LE expr .)
    AND             reduce using rule 45 (expr -> expr LE expr .)
    LT              reduce using rule 45 (expr -> expr LE expr .)
    GT              reduce using rule 45 (expr -> expr LE expr .)
    LE              reduce using rule 45 (expr -> expr LE expr .)
    GE              reduce using rule 45 (expr -> expr LE expr .)
    EQ              reduce using rule 45 (expr -> expr LE expr .)
    NE              reduce using rule 45 (expr -> expr LE expr .)
    ID              reduce using rule 45 (expr -> expr LE expr .)
    procedure       reduce using rule 45 (expr -> expr LE expr .)
    print           reduce using rule 45 (expr -> expr LE expr .)
    while           reduce using rule 45 (expr -> expr LE expr .)
    for             reduce using rule 45 (expr -> expr LE expr .)
    if              reduce using rule 45 (expr -> expr LE expr .)
    LKEY            reduce using rule 45 (expr -> expr LE expr .)
    BLTIN           reduce using rule 45 (expr -> expr LE expr .)
    NUMBER          reduce using rule 45 (expr -> expr LE expr .)
    NOT             reduce using rule 45 (expr -> expr LE expr .)
    INC             reduce using rule 45 (expr -> expr LE expr .)
    DEC             reduce using rule 45 (expr -> expr LE expr .)
    RETURN          reduce using rule 45 (expr -> expr LE expr .)
    read            reduce using rule 45 (expr -> expr LE expr .)
    (               reduce using rule 45 (expr -> expr LE expr .)
    $end            reduce using rule 45 (expr -> expr LE expr .)
    )               reduce using rule 45 (expr -> expr LE expr .)
    RPAREN          reduce using rule 45 (expr -> expr LE expr .)
    ;               reduce using rule 45 (expr -> expr LE expr .)
    RKEY            reduce using rule 45 (expr -> expr LE expr .)
    ,               reduce using rule 45 (expr -> expr LE expr .)
    ELSE            reduce using rule 45 (expr -> expr LE expr .)
    +               shift and go to state 49
    -               shift and go to state 51
    *               shift and go to state 50
    /               shift and go to state 53
    EXPONENT        shift and go to state 48
    %               shift and go to state 47

  ! +               [ reduce using rule 45 (expr -> expr LE expr .) ]
  ! -               [ reduce using rule 45 (expr -> expr LE expr .) ]
  ! *               [ reduce using rule 45 (expr -> expr LE expr .) ]
  ! /               [ reduce using rule 45 (expr -> expr LE expr .) ]
  ! EXPONENT        [ reduce using rule 45 (expr -> expr LE expr .) ]
  ! %               [ reduce using rule 45 (expr -> expr LE expr .) ]
  ! OR              [ shift and go to state 58 ]
  ! AND             [ shift and go to state 45 ]
  ! LT              [ shift and go to state 55 ]
  ! GT              [ shift and go to state 46 ]
  ! LE              [ shift and go to state 56 ]
  ! GE              [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 57 ]
  ! NE              [ shift and go to state 54 ]


state 91

    (47) expr -> expr EQ expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (35) expr -> expr . EXPONENT expr
    (39) expr -> expr . % expr
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr
    (43) expr -> expr . LT expr
    (44) expr -> expr . GT expr
    (45) expr -> expr . LE expr
    (46) expr -> expr . GE expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr

    OR              reduce using rule 47 (expr -> expr EQ expr .)
    AND             reduce using rule 47 (expr -> expr EQ expr .)
    LT              reduce using rule 47 (expr -> expr EQ expr .)
    GT              reduce using rule 47 (expr -> expr EQ expr .)
    LE              reduce using rule 47 (expr -> expr EQ expr .)
    GE              reduce using rule 47 (expr -> expr EQ expr .)
    EQ              reduce using rule 47 (expr -> expr EQ expr .)
    NE              reduce using rule 47 (expr -> expr EQ expr .)
    ID              reduce using rule 47 (expr -> expr EQ expr .)
    procedure       reduce using rule 47 (expr -> expr EQ expr .)
    print           reduce using rule 47 (expr -> expr EQ expr .)
    while           reduce using rule 47 (expr -> expr EQ expr .)
    for             reduce using rule 47 (expr -> expr EQ expr .)
    if              reduce using rule 47 (expr -> expr EQ expr .)
    LKEY            reduce using rule 47 (expr -> expr EQ expr .)
    BLTIN           reduce using rule 47 (expr -> expr EQ expr .)
    NUMBER          reduce using rule 47 (expr -> expr EQ expr .)
    NOT             reduce using rule 47 (expr -> expr EQ expr .)
    INC             reduce using rule 47 (expr -> expr EQ expr .)
    DEC             reduce using rule 47 (expr -> expr EQ expr .)
    RETURN          reduce using rule 47 (expr -> expr EQ expr .)
    read            reduce using rule 47 (expr -> expr EQ expr .)
    (               reduce using rule 47 (expr -> expr EQ expr .)
    $end            reduce using rule 47 (expr -> expr EQ expr .)
    )               reduce using rule 47 (expr -> expr EQ expr .)
    RPAREN          reduce using rule 47 (expr -> expr EQ expr .)
    ;               reduce using rule 47 (expr -> expr EQ expr .)
    RKEY            reduce using rule 47 (expr -> expr EQ expr .)
    ,               reduce using rule 47 (expr -> expr EQ expr .)
    ELSE            reduce using rule 47 (expr -> expr EQ expr .)
    +               shift and go to state 49
    -               shift and go to state 51
    *               shift and go to state 50
    /               shift and go to state 53
    EXPONENT        shift and go to state 48
    %               shift and go to state 47

  ! +               [ reduce using rule 47 (expr -> expr EQ expr .) ]
  ! -               [ reduce using rule 47 (expr -> expr EQ expr .) ]
  ! *               [ reduce using rule 47 (expr -> expr EQ expr .) ]
  ! /               [ reduce using rule 47 (expr -> expr EQ expr .) ]
  ! EXPONENT        [ reduce using rule 47 (expr -> expr EQ expr .) ]
  ! %               [ reduce using rule 47 (expr -> expr EQ expr .) ]
  ! OR              [ shift and go to state 58 ]
  ! AND             [ shift and go to state 45 ]
  ! LT              [ shift and go to state 55 ]
  ! GT              [ shift and go to state 46 ]
  ! LE              [ shift and go to state 56 ]
  ! GE              [ shift and go to state 52 ]
  ! EQ              [ shift and go to state 57 ]
  ! NE              [ shift and go to state 54 ]


state 92

    (40) expr -> expr OR expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (35) expr -> expr . EXPONENT expr
    (39) expr -> expr . % expr
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr
    (43) expr -> expr . LT expr
    (44) expr -> expr . GT expr
    (45) expr -> expr . LE expr
    (46) expr -> expr . GE expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr

    OR              reduce using rule 40 (expr -> expr OR expr .)
    ID              reduce using rule 40 (expr -> expr OR expr .)
    procedure       reduce using rule 40 (expr -> expr OR expr .)
    print           reduce using rule 40 (expr -> expr OR expr .)
    while           reduce using rule 40 (expr -> expr OR expr .)
    for             reduce using rule 40 (expr -> expr OR expr .)
    if              reduce using rule 40 (expr -> expr OR expr .)
    LKEY            reduce using rule 40 (expr -> expr OR expr .)
    BLTIN           reduce using rule 40 (expr -> expr OR expr .)
    NUMBER          reduce using rule 40 (expr -> expr OR expr .)
    NOT             reduce using rule 40 (expr -> expr OR expr .)
    INC             reduce using rule 40 (expr -> expr OR expr .)
    DEC             reduce using rule 40 (expr -> expr OR expr .)
    RETURN          reduce using rule 40 (expr -> expr OR expr .)
    read            reduce using rule 40 (expr -> expr OR expr .)
    (               reduce using rule 40 (expr -> expr OR expr .)
    $end            reduce using rule 40 (expr -> expr OR expr .)
    )               reduce using rule 40 (expr -> expr OR expr .)
    RPAREN          reduce using rule 40 (expr -> expr OR expr .)
    ;               reduce using rule 40 (expr -> expr OR expr .)
    RKEY            reduce using rule 40 (expr -> expr OR expr .)
    ,               reduce using rule 40 (expr -> expr OR expr .)
    ELSE            reduce using rule 40 (expr -> expr OR expr .)
    +               shift and go to state 49
    -               shift and go to state 51
    *               shift and go to state 50
    /               shift and go to state 53
    EXPONENT        shift and go to state 48
    %               shift and go to state 47
    AND             shift and go to state 45
    LT              shift and go to state 55
    GT              shift and go to state 46
    LE              shift and go to state 56
    GE              shift and go to state 52
    EQ              shift and go to state 57
    NE              shift and go to state 54

  ! +               [ reduce using rule 40 (expr -> expr OR expr .) ]
  ! -               [ reduce using rule 40 (expr -> expr OR expr .) ]
  ! *               [ reduce using rule 40 (expr -> expr OR expr .) ]
  ! /               [ reduce using rule 40 (expr -> expr OR expr .) ]
  ! EXPONENT        [ reduce using rule 40 (expr -> expr OR expr .) ]
  ! %               [ reduce using rule 40 (expr -> expr OR expr .) ]
  ! AND             [ reduce using rule 40 (expr -> expr OR expr .) ]
  ! LT              [ reduce using rule 40 (expr -> expr OR expr .) ]
  ! GT              [ reduce using rule 40 (expr -> expr OR expr .) ]
  ! LE              [ reduce using rule 40 (expr -> expr OR expr .) ]
  ! GE              [ reduce using rule 40 (expr -> expr OR expr .) ]
  ! EQ              [ reduce using rule 40 (expr -> expr OR expr .) ]
  ! NE              [ reduce using rule 40 (expr -> expr OR expr .) ]
  ! OR              [ shift and go to state 58 ]


state 93

    (14) stmt -> while LPAREN cond . RPAREN stmt end

    RPAREN          shift and go to state 102


state 94

    (12) stmt -> procedure begin LPAREN . arglist RPAREN
    (60) arglist -> . empty
    (61) arglist -> . arglist , expr
    (62) arglist -> . expr
    (63) empty -> .
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    RPAREN          reduce using rule 63 (empty -> .)
    ,               reduce using rule 63 (empty -> .)
    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    read            shift and go to state 13
    (               shift and go to state 7

    expr                           shift and go to state 105
    term                           shift and go to state 17
    asgn                           shift and go to state 26
    factor                         shift and go to state 9
    arglist                        shift and go to state 103
    empty                          shift and go to state 104

state 95

    (16) stmt -> if LPAREN cond RPAREN . stmt end
    (17) stmt -> if LPAREN cond RPAREN . stmt end ELSE stmt end
    (10) stmt -> . expr
    (11) stmt -> . return LPAREN expr RPAREN
    (12) stmt -> . procedure begin LPAREN arglist RPAREN
    (13) stmt -> . print prlist
    (14) stmt -> . while LPAREN cond RPAREN stmt end
    (15) stmt -> . for LPAREN cond ; cond ; cond RPAREN stmt end
    (16) stmt -> . if LPAREN cond RPAREN stmt end
    (17) stmt -> . if LPAREN cond RPAREN stmt end ELSE stmt end
    (18) stmt -> . LKEY stmtlist RKEY
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (23) return -> . RETURN
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    procedure       shift and go to state 22
    print           shift and go to state 10
    while           shift and go to state 20
    for             shift and go to state 6
    if              shift and go to state 5
    LKEY            shift and go to state 12
    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    RETURN          shift and go to state 3
    read            shift and go to state 13
    (               shift and go to state 7

    return                         shift and go to state 11
    expr                           shift and go to state 19
    term                           shift and go to state 17
    stmt                           shift and go to state 106
    asgn                           shift and go to state 26
    factor                         shift and go to state 9

state 96

    (15) stmt -> for LPAREN cond ; . cond ; cond RPAREN stmt end
    (19) cond -> . expr
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    read            shift and go to state 13
    (               shift and go to state 7

    term                           shift and go to state 17
    expr                           shift and go to state 64
    asgn                           shift and go to state 26
    cond                           shift and go to state 107
    factor                         shift and go to state 9

state 97

    (55) prlist -> prlist , STRING .

    ,               reduce using rule 55 (prlist -> prlist , STRING .)
    ID              reduce using rule 55 (prlist -> prlist , STRING .)
    procedure       reduce using rule 55 (prlist -> prlist , STRING .)
    print           reduce using rule 55 (prlist -> prlist , STRING .)
    while           reduce using rule 55 (prlist -> prlist , STRING .)
    for             reduce using rule 55 (prlist -> prlist , STRING .)
    if              reduce using rule 55 (prlist -> prlist , STRING .)
    LKEY            reduce using rule 55 (prlist -> prlist , STRING .)
    BLTIN           reduce using rule 55 (prlist -> prlist , STRING .)
    NUMBER          reduce using rule 55 (prlist -> prlist , STRING .)
    NOT             reduce using rule 55 (prlist -> prlist , STRING .)
    INC             reduce using rule 55 (prlist -> prlist , STRING .)
    DEC             reduce using rule 55 (prlist -> prlist , STRING .)
    RETURN          reduce using rule 55 (prlist -> prlist , STRING .)
    read            reduce using rule 55 (prlist -> prlist , STRING .)
    (               reduce using rule 55 (prlist -> prlist , STRING .)
    $end            reduce using rule 55 (prlist -> prlist , STRING .)
    RKEY            reduce using rule 55 (prlist -> prlist , STRING .)
    ELSE            reduce using rule 55 (prlist -> prlist , STRING .)


state 98

    (54) prlist -> prlist , expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (35) expr -> expr . EXPONENT expr
    (39) expr -> expr . % expr
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr
    (43) expr -> expr . LT expr
    (44) expr -> expr . GT expr
    (45) expr -> expr . LE expr
    (46) expr -> expr . GE expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr

    ,               reduce using rule 54 (prlist -> prlist , expr .)
    ID              reduce using rule 54 (prlist -> prlist , expr .)
    procedure       reduce using rule 54 (prlist -> prlist , expr .)
    print           reduce using rule 54 (prlist -> prlist , expr .)
    while           reduce using rule 54 (prlist -> prlist , expr .)
    for             reduce using rule 54 (prlist -> prlist , expr .)
    if              reduce using rule 54 (prlist -> prlist , expr .)
    LKEY            reduce using rule 54 (prlist -> prlist , expr .)
    BLTIN           reduce using rule 54 (prlist -> prlist , expr .)
    NUMBER          reduce using rule 54 (prlist -> prlist , expr .)
    NOT             reduce using rule 54 (prlist -> prlist , expr .)
    INC             reduce using rule 54 (prlist -> prlist , expr .)
    DEC             reduce using rule 54 (prlist -> prlist , expr .)
    RETURN          reduce using rule 54 (prlist -> prlist , expr .)
    read            reduce using rule 54 (prlist -> prlist , expr .)
    (               reduce using rule 54 (prlist -> prlist , expr .)
    $end            reduce using rule 54 (prlist -> prlist , expr .)
    RKEY            reduce using rule 54 (prlist -> prlist , expr .)
    ELSE            reduce using rule 54 (prlist -> prlist , expr .)
    +               shift and go to state 49
    -               shift and go to state 51
    *               shift and go to state 50
    /               shift and go to state 53
    EXPONENT        shift and go to state 48
    %               shift and go to state 47
    OR              shift and go to state 58
    AND             shift and go to state 45
    LT              shift and go to state 55
    GT              shift and go to state 46
    LE              shift and go to state 56
    GE              shift and go to state 52
    EQ              shift and go to state 57
    NE              shift and go to state 54


state 99

    (11) stmt -> return LPAREN expr RPAREN .

    ELSE            reduce using rule 11 (stmt -> return LPAREN expr RPAREN .)
    ID              reduce using rule 11 (stmt -> return LPAREN expr RPAREN .)
    procedure       reduce using rule 11 (stmt -> return LPAREN expr RPAREN .)
    print           reduce using rule 11 (stmt -> return LPAREN expr RPAREN .)
    while           reduce using rule 11 (stmt -> return LPAREN expr RPAREN .)
    for             reduce using rule 11 (stmt -> return LPAREN expr RPAREN .)
    if              reduce using rule 11 (stmt -> return LPAREN expr RPAREN .)
    LKEY            reduce using rule 11 (stmt -> return LPAREN expr RPAREN .)
    BLTIN           reduce using rule 11 (stmt -> return LPAREN expr RPAREN .)
    NUMBER          reduce using rule 11 (stmt -> return LPAREN expr RPAREN .)
    NOT             reduce using rule 11 (stmt -> return LPAREN expr RPAREN .)
    INC             reduce using rule 11 (stmt -> return LPAREN expr RPAREN .)
    DEC             reduce using rule 11 (stmt -> return LPAREN expr RPAREN .)
    RETURN          reduce using rule 11 (stmt -> return LPAREN expr RPAREN .)
    read            reduce using rule 11 (stmt -> return LPAREN expr RPAREN .)
    (               reduce using rule 11 (stmt -> return LPAREN expr RPAREN .)
    $end            reduce using rule 11 (stmt -> return LPAREN expr RPAREN .)
    RKEY            reduce using rule 11 (stmt -> return LPAREN expr RPAREN .)


state 100

    (27) term -> read ( ID ) .

    +               reduce using rule 27 (term -> read ( ID ) .)
    -               reduce using rule 27 (term -> read ( ID ) .)
    *               reduce using rule 27 (term -> read ( ID ) .)
    /               reduce using rule 27 (term -> read ( ID ) .)
    EXPONENT        reduce using rule 27 (term -> read ( ID ) .)
    %               reduce using rule 27 (term -> read ( ID ) .)
    OR              reduce using rule 27 (term -> read ( ID ) .)
    AND             reduce using rule 27 (term -> read ( ID ) .)
    LT              reduce using rule 27 (term -> read ( ID ) .)
    GT              reduce using rule 27 (term -> read ( ID ) .)
    LE              reduce using rule 27 (term -> read ( ID ) .)
    GE              reduce using rule 27 (term -> read ( ID ) .)
    EQ              reduce using rule 27 (term -> read ( ID ) .)
    NE              reduce using rule 27 (term -> read ( ID ) .)
    ID              reduce using rule 27 (term -> read ( ID ) .)
    procedure       reduce using rule 27 (term -> read ( ID ) .)
    print           reduce using rule 27 (term -> read ( ID ) .)
    while           reduce using rule 27 (term -> read ( ID ) .)
    for             reduce using rule 27 (term -> read ( ID ) .)
    if              reduce using rule 27 (term -> read ( ID ) .)
    LKEY            reduce using rule 27 (term -> read ( ID ) .)
    BLTIN           reduce using rule 27 (term -> read ( ID ) .)
    NUMBER          reduce using rule 27 (term -> read ( ID ) .)
    NOT             reduce using rule 27 (term -> read ( ID ) .)
    INC             reduce using rule 27 (term -> read ( ID ) .)
    DEC             reduce using rule 27 (term -> read ( ID ) .)
    RETURN          reduce using rule 27 (term -> read ( ID ) .)
    read            reduce using rule 27 (term -> read ( ID ) .)
    (               reduce using rule 27 (term -> read ( ID ) .)
    $end            reduce using rule 27 (term -> read ( ID ) .)
    )               reduce using rule 27 (term -> read ( ID ) .)
    RPAREN          reduce using rule 27 (term -> read ( ID ) .)
    ;               reduce using rule 27 (term -> read ( ID ) .)
    RKEY            reduce using rule 27 (term -> read ( ID ) .)
    ,               reduce using rule 27 (term -> read ( ID ) .)
    ELSE            reduce using rule 27 (term -> read ( ID ) .)


state 101

    (28) expr -> BLTIN ( expr ) .

    +               reduce using rule 28 (expr -> BLTIN ( expr ) .)
    -               reduce using rule 28 (expr -> BLTIN ( expr ) .)
    *               reduce using rule 28 (expr -> BLTIN ( expr ) .)
    /               reduce using rule 28 (expr -> BLTIN ( expr ) .)
    EXPONENT        reduce using rule 28 (expr -> BLTIN ( expr ) .)
    %               reduce using rule 28 (expr -> BLTIN ( expr ) .)
    OR              reduce using rule 28 (expr -> BLTIN ( expr ) .)
    AND             reduce using rule 28 (expr -> BLTIN ( expr ) .)
    LT              reduce using rule 28 (expr -> BLTIN ( expr ) .)
    GT              reduce using rule 28 (expr -> BLTIN ( expr ) .)
    LE              reduce using rule 28 (expr -> BLTIN ( expr ) .)
    GE              reduce using rule 28 (expr -> BLTIN ( expr ) .)
    EQ              reduce using rule 28 (expr -> BLTIN ( expr ) .)
    NE              reduce using rule 28 (expr -> BLTIN ( expr ) .)
    ID              reduce using rule 28 (expr -> BLTIN ( expr ) .)
    procedure       reduce using rule 28 (expr -> BLTIN ( expr ) .)
    print           reduce using rule 28 (expr -> BLTIN ( expr ) .)
    while           reduce using rule 28 (expr -> BLTIN ( expr ) .)
    for             reduce using rule 28 (expr -> BLTIN ( expr ) .)
    if              reduce using rule 28 (expr -> BLTIN ( expr ) .)
    LKEY            reduce using rule 28 (expr -> BLTIN ( expr ) .)
    BLTIN           reduce using rule 28 (expr -> BLTIN ( expr ) .)
    NUMBER          reduce using rule 28 (expr -> BLTIN ( expr ) .)
    NOT             reduce using rule 28 (expr -> BLTIN ( expr ) .)
    INC             reduce using rule 28 (expr -> BLTIN ( expr ) .)
    DEC             reduce using rule 28 (expr -> BLTIN ( expr ) .)
    RETURN          reduce using rule 28 (expr -> BLTIN ( expr ) .)
    read            reduce using rule 28 (expr -> BLTIN ( expr ) .)
    (               reduce using rule 28 (expr -> BLTIN ( expr ) .)
    $end            reduce using rule 28 (expr -> BLTIN ( expr ) .)
    )               reduce using rule 28 (expr -> BLTIN ( expr ) .)
    RPAREN          reduce using rule 28 (expr -> BLTIN ( expr ) .)
    ;               reduce using rule 28 (expr -> BLTIN ( expr ) .)
    RKEY            reduce using rule 28 (expr -> BLTIN ( expr ) .)
    ,               reduce using rule 28 (expr -> BLTIN ( expr ) .)
    ELSE            reduce using rule 28 (expr -> BLTIN ( expr ) .)


state 102

    (14) stmt -> while LPAREN cond RPAREN . stmt end
    (10) stmt -> . expr
    (11) stmt -> . return LPAREN expr RPAREN
    (12) stmt -> . procedure begin LPAREN arglist RPAREN
    (13) stmt -> . print prlist
    (14) stmt -> . while LPAREN cond RPAREN stmt end
    (15) stmt -> . for LPAREN cond ; cond ; cond RPAREN stmt end
    (16) stmt -> . if LPAREN cond RPAREN stmt end
    (17) stmt -> . if LPAREN cond RPAREN stmt end ELSE stmt end
    (18) stmt -> . LKEY stmtlist RKEY
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (23) return -> . RETURN
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    procedure       shift and go to state 22
    print           shift and go to state 10
    while           shift and go to state 20
    for             shift and go to state 6
    if              shift and go to state 5
    LKEY            shift and go to state 12
    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    RETURN          shift and go to state 3
    read            shift and go to state 13
    (               shift and go to state 7

    return                         shift and go to state 11
    expr                           shift and go to state 19
    term                           shift and go to state 17
    stmt                           shift and go to state 108
    asgn                           shift and go to state 26
    factor                         shift and go to state 9

state 103

    (12) stmt -> procedure begin LPAREN arglist . RPAREN
    (61) arglist -> arglist . , expr

    RPAREN          shift and go to state 109
    ,               shift and go to state 110


state 104

    (60) arglist -> empty .

    RPAREN          reduce using rule 60 (arglist -> empty .)
    ,               reduce using rule 60 (arglist -> empty .)


state 105

    (62) arglist -> expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (35) expr -> expr . EXPONENT expr
    (39) expr -> expr . % expr
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr
    (43) expr -> expr . LT expr
    (44) expr -> expr . GT expr
    (45) expr -> expr . LE expr
    (46) expr -> expr . GE expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr

    RPAREN          reduce using rule 62 (arglist -> expr .)
    ,               reduce using rule 62 (arglist -> expr .)
    +               shift and go to state 49
    -               shift and go to state 51
    *               shift and go to state 50
    /               shift and go to state 53
    EXPONENT        shift and go to state 48
    %               shift and go to state 47
    OR              shift and go to state 58
    AND             shift and go to state 45
    LT              shift and go to state 55
    GT              shift and go to state 46
    LE              shift and go to state 56
    GE              shift and go to state 52
    EQ              shift and go to state 57
    NE              shift and go to state 54


state 106

    (16) stmt -> if LPAREN cond RPAREN stmt . end
    (17) stmt -> if LPAREN cond RPAREN stmt . end ELSE stmt end
    (21) end -> .

    ELSE            reduce using rule 21 (end -> .)
    ID              reduce using rule 21 (end -> .)
    procedure       reduce using rule 21 (end -> .)
    print           reduce using rule 21 (end -> .)
    while           reduce using rule 21 (end -> .)
    for             reduce using rule 21 (end -> .)
    if              reduce using rule 21 (end -> .)
    LKEY            reduce using rule 21 (end -> .)
    BLTIN           reduce using rule 21 (end -> .)
    NUMBER          reduce using rule 21 (end -> .)
    NOT             reduce using rule 21 (end -> .)
    INC             reduce using rule 21 (end -> .)
    DEC             reduce using rule 21 (end -> .)
    RETURN          reduce using rule 21 (end -> .)
    read            reduce using rule 21 (end -> .)
    (               reduce using rule 21 (end -> .)
    $end            reduce using rule 21 (end -> .)
    RKEY            reduce using rule 21 (end -> .)

    end                            shift and go to state 111

state 107

    (15) stmt -> for LPAREN cond ; cond . ; cond RPAREN stmt end

    ;               shift and go to state 112


state 108

    (14) stmt -> while LPAREN cond RPAREN stmt . end
    (21) end -> .

    ID              reduce using rule 21 (end -> .)
    procedure       reduce using rule 21 (end -> .)
    print           reduce using rule 21 (end -> .)
    while           reduce using rule 21 (end -> .)
    for             reduce using rule 21 (end -> .)
    if              reduce using rule 21 (end -> .)
    LKEY            reduce using rule 21 (end -> .)
    BLTIN           reduce using rule 21 (end -> .)
    NUMBER          reduce using rule 21 (end -> .)
    NOT             reduce using rule 21 (end -> .)
    INC             reduce using rule 21 (end -> .)
    DEC             reduce using rule 21 (end -> .)
    RETURN          reduce using rule 21 (end -> .)
    read            reduce using rule 21 (end -> .)
    (               reduce using rule 21 (end -> .)
    $end            reduce using rule 21 (end -> .)
    RKEY            reduce using rule 21 (end -> .)
    ELSE            reduce using rule 21 (end -> .)

    end                            shift and go to state 113

state 109

    (12) stmt -> procedure begin LPAREN arglist RPAREN .

    ELSE            reduce using rule 12 (stmt -> procedure begin LPAREN arglist RPAREN .)
    ID              reduce using rule 12 (stmt -> procedure begin LPAREN arglist RPAREN .)
    procedure       reduce using rule 12 (stmt -> procedure begin LPAREN arglist RPAREN .)
    print           reduce using rule 12 (stmt -> procedure begin LPAREN arglist RPAREN .)
    while           reduce using rule 12 (stmt -> procedure begin LPAREN arglist RPAREN .)
    for             reduce using rule 12 (stmt -> procedure begin LPAREN arglist RPAREN .)
    if              reduce using rule 12 (stmt -> procedure begin LPAREN arglist RPAREN .)
    LKEY            reduce using rule 12 (stmt -> procedure begin LPAREN arglist RPAREN .)
    BLTIN           reduce using rule 12 (stmt -> procedure begin LPAREN arglist RPAREN .)
    NUMBER          reduce using rule 12 (stmt -> procedure begin LPAREN arglist RPAREN .)
    NOT             reduce using rule 12 (stmt -> procedure begin LPAREN arglist RPAREN .)
    INC             reduce using rule 12 (stmt -> procedure begin LPAREN arglist RPAREN .)
    DEC             reduce using rule 12 (stmt -> procedure begin LPAREN arglist RPAREN .)
    RETURN          reduce using rule 12 (stmt -> procedure begin LPAREN arglist RPAREN .)
    read            reduce using rule 12 (stmt -> procedure begin LPAREN arglist RPAREN .)
    (               reduce using rule 12 (stmt -> procedure begin LPAREN arglist RPAREN .)
    $end            reduce using rule 12 (stmt -> procedure begin LPAREN arglist RPAREN .)
    RKEY            reduce using rule 12 (stmt -> procedure begin LPAREN arglist RPAREN .)


state 110

    (61) arglist -> arglist , . expr
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    read            shift and go to state 13
    (               shift and go to state 7

    expr                           shift and go to state 114
    term                           shift and go to state 17
    factor                         shift and go to state 9
    asgn                           shift and go to state 26

state 111

    (16) stmt -> if LPAREN cond RPAREN stmt end .
    (17) stmt -> if LPAREN cond RPAREN stmt end . ELSE stmt end

    ID              reduce using rule 16 (stmt -> if LPAREN cond RPAREN stmt end .)
    procedure       reduce using rule 16 (stmt -> if LPAREN cond RPAREN stmt end .)
    print           reduce using rule 16 (stmt -> if LPAREN cond RPAREN stmt end .)
    while           reduce using rule 16 (stmt -> if LPAREN cond RPAREN stmt end .)
    for             reduce using rule 16 (stmt -> if LPAREN cond RPAREN stmt end .)
    if              reduce using rule 16 (stmt -> if LPAREN cond RPAREN stmt end .)
    LKEY            reduce using rule 16 (stmt -> if LPAREN cond RPAREN stmt end .)
    BLTIN           reduce using rule 16 (stmt -> if LPAREN cond RPAREN stmt end .)
    NUMBER          reduce using rule 16 (stmt -> if LPAREN cond RPAREN stmt end .)
    NOT             reduce using rule 16 (stmt -> if LPAREN cond RPAREN stmt end .)
    INC             reduce using rule 16 (stmt -> if LPAREN cond RPAREN stmt end .)
    DEC             reduce using rule 16 (stmt -> if LPAREN cond RPAREN stmt end .)
    RETURN          reduce using rule 16 (stmt -> if LPAREN cond RPAREN stmt end .)
    read            reduce using rule 16 (stmt -> if LPAREN cond RPAREN stmt end .)
    (               reduce using rule 16 (stmt -> if LPAREN cond RPAREN stmt end .)
    $end            reduce using rule 16 (stmt -> if LPAREN cond RPAREN stmt end .)
    RKEY            reduce using rule 16 (stmt -> if LPAREN cond RPAREN stmt end .)
    ELSE            shift and go to state 115

  ! ELSE            [ reduce using rule 16 (stmt -> if LPAREN cond RPAREN stmt end .) ]


state 112

    (15) stmt -> for LPAREN cond ; cond ; . cond RPAREN stmt end
    (19) cond -> . expr
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    read            shift and go to state 13
    (               shift and go to state 7

    term                           shift and go to state 17
    expr                           shift and go to state 64
    asgn                           shift and go to state 26
    cond                           shift and go to state 116
    factor                         shift and go to state 9

state 113

    (14) stmt -> while LPAREN cond RPAREN stmt end .

    ELSE            reduce using rule 14 (stmt -> while LPAREN cond RPAREN stmt end .)
    ID              reduce using rule 14 (stmt -> while LPAREN cond RPAREN stmt end .)
    procedure       reduce using rule 14 (stmt -> while LPAREN cond RPAREN stmt end .)
    print           reduce using rule 14 (stmt -> while LPAREN cond RPAREN stmt end .)
    while           reduce using rule 14 (stmt -> while LPAREN cond RPAREN stmt end .)
    for             reduce using rule 14 (stmt -> while LPAREN cond RPAREN stmt end .)
    if              reduce using rule 14 (stmt -> while LPAREN cond RPAREN stmt end .)
    LKEY            reduce using rule 14 (stmt -> while LPAREN cond RPAREN stmt end .)
    BLTIN           reduce using rule 14 (stmt -> while LPAREN cond RPAREN stmt end .)
    NUMBER          reduce using rule 14 (stmt -> while LPAREN cond RPAREN stmt end .)
    NOT             reduce using rule 14 (stmt -> while LPAREN cond RPAREN stmt end .)
    INC             reduce using rule 14 (stmt -> while LPAREN cond RPAREN stmt end .)
    DEC             reduce using rule 14 (stmt -> while LPAREN cond RPAREN stmt end .)
    RETURN          reduce using rule 14 (stmt -> while LPAREN cond RPAREN stmt end .)
    read            reduce using rule 14 (stmt -> while LPAREN cond RPAREN stmt end .)
    (               reduce using rule 14 (stmt -> while LPAREN cond RPAREN stmt end .)
    $end            reduce using rule 14 (stmt -> while LPAREN cond RPAREN stmt end .)
    RKEY            reduce using rule 14 (stmt -> while LPAREN cond RPAREN stmt end .)


state 114

    (61) arglist -> arglist , expr .
    (30) expr -> expr . + expr
    (31) expr -> expr . - expr
    (32) expr -> expr . * expr
    (33) expr -> expr . / expr
    (35) expr -> expr . EXPONENT expr
    (39) expr -> expr . % expr
    (40) expr -> expr . OR expr
    (41) expr -> expr . AND expr
    (43) expr -> expr . LT expr
    (44) expr -> expr . GT expr
    (45) expr -> expr . LE expr
    (46) expr -> expr . GE expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr

    RPAREN          reduce using rule 61 (arglist -> arglist , expr .)
    ,               reduce using rule 61 (arglist -> arglist , expr .)
    +               shift and go to state 49
    -               shift and go to state 51
    *               shift and go to state 50
    /               shift and go to state 53
    EXPONENT        shift and go to state 48
    %               shift and go to state 47
    OR              shift and go to state 58
    AND             shift and go to state 45
    LT              shift and go to state 55
    GT              shift and go to state 46
    LE              shift and go to state 56
    GE              shift and go to state 52
    EQ              shift and go to state 57
    NE              shift and go to state 54


state 115

    (17) stmt -> if LPAREN cond RPAREN stmt end ELSE . stmt end
    (10) stmt -> . expr
    (11) stmt -> . return LPAREN expr RPAREN
    (12) stmt -> . procedure begin LPAREN arglist RPAREN
    (13) stmt -> . print prlist
    (14) stmt -> . while LPAREN cond RPAREN stmt end
    (15) stmt -> . for LPAREN cond ; cond ; cond RPAREN stmt end
    (16) stmt -> . if LPAREN cond RPAREN stmt end
    (17) stmt -> . if LPAREN cond RPAREN stmt end ELSE stmt end
    (18) stmt -> . LKEY stmtlist RKEY
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (23) return -> . RETURN
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    procedure       shift and go to state 22
    print           shift and go to state 10
    while           shift and go to state 20
    for             shift and go to state 6
    if              shift and go to state 5
    LKEY            shift and go to state 12
    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    RETURN          shift and go to state 3
    read            shift and go to state 13
    (               shift and go to state 7

    return                         shift and go to state 11
    expr                           shift and go to state 19
    term                           shift and go to state 17
    stmt                           shift and go to state 117
    asgn                           shift and go to state 26
    factor                         shift and go to state 9

state 116

    (15) stmt -> for LPAREN cond ; cond ; cond . RPAREN stmt end

    RPAREN          shift and go to state 118


state 117

    (17) stmt -> if LPAREN cond RPAREN stmt end ELSE stmt . end
    (21) end -> .

    ID              reduce using rule 21 (end -> .)
    procedure       reduce using rule 21 (end -> .)
    print           reduce using rule 21 (end -> .)
    while           reduce using rule 21 (end -> .)
    for             reduce using rule 21 (end -> .)
    if              reduce using rule 21 (end -> .)
    LKEY            reduce using rule 21 (end -> .)
    BLTIN           reduce using rule 21 (end -> .)
    NUMBER          reduce using rule 21 (end -> .)
    NOT             reduce using rule 21 (end -> .)
    INC             reduce using rule 21 (end -> .)
    DEC             reduce using rule 21 (end -> .)
    RETURN          reduce using rule 21 (end -> .)
    read            reduce using rule 21 (end -> .)
    (               reduce using rule 21 (end -> .)
    $end            reduce using rule 21 (end -> .)
    RKEY            reduce using rule 21 (end -> .)
    ELSE            reduce using rule 21 (end -> .)

    end                            shift and go to state 119

state 118

    (15) stmt -> for LPAREN cond ; cond ; cond RPAREN . stmt end
    (10) stmt -> . expr
    (11) stmt -> . return LPAREN expr RPAREN
    (12) stmt -> . procedure begin LPAREN arglist RPAREN
    (13) stmt -> . print prlist
    (14) stmt -> . while LPAREN cond RPAREN stmt end
    (15) stmt -> . for LPAREN cond ; cond ; cond RPAREN stmt end
    (16) stmt -> . if LPAREN cond RPAREN stmt end
    (17) stmt -> . if LPAREN cond RPAREN stmt end ELSE stmt end
    (18) stmt -> . LKEY stmtlist RKEY
    (26) expr -> . ID
    (28) expr -> . BLTIN ( expr )
    (29) expr -> . asgn
    (30) expr -> . expr + expr
    (31) expr -> . expr - expr
    (32) expr -> . expr * expr
    (33) expr -> . expr / expr
    (34) expr -> . NUMBER
    (35) expr -> . expr EXPONENT expr
    (36) expr -> . term
    (39) expr -> . expr % expr
    (40) expr -> . expr OR expr
    (41) expr -> . expr AND expr
    (42) expr -> . NOT expr
    (43) expr -> . expr LT expr
    (44) expr -> . expr GT expr
    (45) expr -> . expr LE expr
    (46) expr -> . expr GE expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . INC ID
    (50) expr -> . DEC ID
    (51) expr -> . ID DEC
    (52) expr -> . ID INC
    (23) return -> . RETURN
    (4) asgn -> . ID = expr
    (5) asgn -> . ID ADDEQ expr
    (6) asgn -> . ID SUBEQ expr
    (7) asgn -> . ID MULEQ expr
    (8) asgn -> . ID DIVEQ expr
    (9) asgn -> . ID MODEQ expr
    (27) term -> . read ( ID )
    (37) term -> . factor
    (38) factor -> . ( expr )

    procedure       shift and go to state 22
    print           shift and go to state 10
    while           shift and go to state 20
    for             shift and go to state 6
    if              shift and go to state 5
    LKEY            shift and go to state 12
    ID              shift and go to state 27
    BLTIN           shift and go to state 15
    NUMBER          shift and go to state 4
    NOT             shift and go to state 21
    INC             shift and go to state 23
    DEC             shift and go to state 18
    RETURN          shift and go to state 3
    read            shift and go to state 13
    (               shift and go to state 7

    return                         shift and go to state 11
    expr                           shift and go to state 19
    term                           shift and go to state 17
    stmt                           shift and go to state 120
    asgn                           shift and go to state 26
    factor                         shift and go to state 9

state 119

    (17) stmt -> if LPAREN cond RPAREN stmt end ELSE stmt end .

    ELSE            reduce using rule 17 (stmt -> if LPAREN cond RPAREN stmt end ELSE stmt end .)
    ID              reduce using rule 17 (stmt -> if LPAREN cond RPAREN stmt end ELSE stmt end .)
    procedure       reduce using rule 17 (stmt -> if LPAREN cond RPAREN stmt end ELSE stmt end .)
    print           reduce using rule 17 (stmt -> if LPAREN cond RPAREN stmt end ELSE stmt end .)
    while           reduce using rule 17 (stmt -> if LPAREN cond RPAREN stmt end ELSE stmt end .)
    for             reduce using rule 17 (stmt -> if LPAREN cond RPAREN stmt end ELSE stmt end .)
    if              reduce using rule 17 (stmt -> if LPAREN cond RPAREN stmt end ELSE stmt end .)
    LKEY            reduce using rule 17 (stmt -> if LPAREN cond RPAREN stmt end ELSE stmt end .)
    BLTIN           reduce using rule 17 (stmt -> if LPAREN cond RPAREN stmt end ELSE stmt end .)
    NUMBER          reduce using rule 17 (stmt -> if LPAREN cond RPAREN stmt end ELSE stmt end .)
    NOT             reduce using rule 17 (stmt -> if LPAREN cond RPAREN stmt end ELSE stmt end .)
    INC             reduce using rule 17 (stmt -> if LPAREN cond RPAREN stmt end ELSE stmt end .)
    DEC             reduce using rule 17 (stmt -> if LPAREN cond RPAREN stmt end ELSE stmt end .)
    RETURN          reduce using rule 17 (stmt -> if LPAREN cond RPAREN stmt end ELSE stmt end .)
    read            reduce using rule 17 (stmt -> if LPAREN cond RPAREN stmt end ELSE stmt end .)
    (               reduce using rule 17 (stmt -> if LPAREN cond RPAREN stmt end ELSE stmt end .)
    $end            reduce using rule 17 (stmt -> if LPAREN cond RPAREN stmt end ELSE stmt end .)
    RKEY            reduce using rule 17 (stmt -> if LPAREN cond RPAREN stmt end ELSE stmt end .)


state 120

    (15) stmt -> for LPAREN cond ; cond ; cond RPAREN stmt . end
    (21) end -> .

    ID              reduce using rule 21 (end -> .)
    procedure       reduce using rule 21 (end -> .)
    print           reduce using rule 21 (end -> .)
    while           reduce using rule 21 (end -> .)
    for             reduce using rule 21 (end -> .)
    if              reduce using rule 21 (end -> .)
    LKEY            reduce using rule 21 (end -> .)
    BLTIN           reduce using rule 21 (end -> .)
    NUMBER          reduce using rule 21 (end -> .)
    NOT             reduce using rule 21 (end -> .)
    INC             reduce using rule 21 (end -> .)
    DEC             reduce using rule 21 (end -> .)
    RETURN          reduce using rule 21 (end -> .)
    read            reduce using rule 21 (end -> .)
    (               reduce using rule 21 (end -> .)
    $end            reduce using rule 21 (end -> .)
    RKEY            reduce using rule 21 (end -> .)
    ELSE            reduce using rule 21 (end -> .)

    end                            shift and go to state 121

state 121

    (15) stmt -> for LPAREN cond ; cond ; cond RPAREN stmt end .

    ELSE            reduce using rule 15 (stmt -> for LPAREN cond ; cond ; cond RPAREN stmt end .)
    ID              reduce using rule 15 (stmt -> for LPAREN cond ; cond ; cond RPAREN stmt end .)
    procedure       reduce using rule 15 (stmt -> for LPAREN cond ; cond ; cond RPAREN stmt end .)
    print           reduce using rule 15 (stmt -> for LPAREN cond ; cond ; cond RPAREN stmt end .)
    while           reduce using rule 15 (stmt -> for LPAREN cond ; cond ; cond RPAREN stmt end .)
    for             reduce using rule 15 (stmt -> for LPAREN cond ; cond ; cond RPAREN stmt end .)
    if              reduce using rule 15 (stmt -> for LPAREN cond ; cond ; cond RPAREN stmt end .)
    LKEY            reduce using rule 15 (stmt -> for LPAREN cond ; cond ; cond RPAREN stmt end .)
    BLTIN           reduce using rule 15 (stmt -> for LPAREN cond ; cond ; cond RPAREN stmt end .)
    NUMBER          reduce using rule 15 (stmt -> for LPAREN cond ; cond ; cond RPAREN stmt end .)
    NOT             reduce using rule 15 (stmt -> for LPAREN cond ; cond ; cond RPAREN stmt end .)
    INC             reduce using rule 15 (stmt -> for LPAREN cond ; cond ; cond RPAREN stmt end .)
    DEC             reduce using rule 15 (stmt -> for LPAREN cond ; cond ; cond RPAREN stmt end .)
    RETURN          reduce using rule 15 (stmt -> for LPAREN cond ; cond ; cond RPAREN stmt end .)
    read            reduce using rule 15 (stmt -> for LPAREN cond ; cond ; cond RPAREN stmt end .)
    (               reduce using rule 15 (stmt -> for LPAREN cond ; cond ; cond RPAREN stmt end .)
    $end            reduce using rule 15 (stmt -> for LPAREN cond ; cond ; cond RPAREN stmt end .)
    RKEY            reduce using rule 15 (stmt -> for LPAREN cond ; cond ; cond RPAREN stmt end .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for DEC in state 16 resolved as shift
WARNING: shift/reduce conflict for INC in state 16 resolved as shift
WARNING: shift/reduce conflict for DEC in state 27 resolved as shift
WARNING: shift/reduce conflict for INC in state 27 resolved as shift
WARNING: reduce/reduce conflict in state 8 resolved using rule (list -> list asgn)
WARNING: rejected rule (expr -> asgn) in state 8
